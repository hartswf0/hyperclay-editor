<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#0a0a08">
<title>HYPERCLAY // MANIFOLD</title>
<style>
    :root {
        --bg: #0a0a08;
        --panel: #141210;
        --border: #333;
        --accent: #d4a418;
        --text: #c2b280;
        --text-dim: #635147;
        --rack-height: 240px; 
        --font-mono: 'Courier New', monospace;
        --font-ui: 'Inter', system-ui, sans-serif;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
    
    body {
        margin: 0; padding: 0;
        background: var(--bg); color: var(--text);
        font-family: var(--font-ui);
        height: 100vh; width: 100vw;
        overflow: hidden;
        display: flex; flex-direction: column;
    }

    /* --- HEADER --- */
    header {
        height: 50px; background: #0f0f0f; border-bottom: 1px solid var(--border);
        display: flex; align-items: center; justify-content: space-between;
        padding: 0 12px; z-index: 20; flex-shrink: 0;
    }
    .header-grp { display: flex; gap: 8px; align-items: center; }
    
    .brand { font-family: var(--font-mono); font-weight: 800; color: var(--accent); letter-spacing: 2px; font-size: 14px; margin-right: 10px; }
    
    .bpm-ctrl {
        display: flex; align-items: center; background: #1a1a1a; 
        border: 1px solid var(--border); border-radius: 4px; padding: 2px;
    }
    .bpm-val { font-family: var(--font-mono); font-size: 12px; color: var(--text); width: 30px; text-align: center; }
    .bpm-btn {
        width: 24px; height: 24px; background: transparent; border: none; 
        color: var(--text-dim); cursor: pointer; display: grid; place-items: center;
        font-weight: bold; font-size: 14px;
    }
    .bpm-btn:active { color: var(--accent); background: rgba(255,255,255,0.05); }

    .btn-icon {
        background: none; border: 1px solid var(--border); color: var(--text-dim);
        width: 32px; height: 32px; border-radius: 4px;
        display: grid; place-items: center; cursor: pointer; font-size: 12px;
        transition: all 0.2s;
    }
    .btn-icon:hover { border-color: var(--text); color: var(--text); }
    .btn-icon.active { background: var(--accent); color: #000; border-color: var(--accent); }

    /* --- RACK LIST --- */
    #rack-container {
        flex-grow: 1; overflow-y: auto; overflow-x: hidden;
        padding: 0; /* Removed padding */
        display: flex; flex-direction: column; 
        gap: 0; /* Removed gap */
    }

    .rack {
        background: var(--panel); 
        border-bottom: 1px solid var(--border); /* Only bottom border */
        height: var(--rack-height);
        display: grid; grid-template-columns: 70px 1fr 60px;
        overflow: hidden; 
        position: relative;
    }
    .rack.muted .screen-area { opacity: 0.3; filter: grayscale(1); }
    .rack.paused .screen-area canvas { opacity: 0.5; }

    /* --- CONTROLS LEFT (Dials) --- */
    .controls-left {
        padding: 12px 0; border-right: 1px solid var(--border);
        display: flex; flex-direction: column; justify-content: space-between;
        align-items: center; background: #0d0d0d;
    }
    .dial-wrapper { display: flex; flex-direction: column; align-items: center; width: 100%; height: 33%; justify-content: center; }
    .dial-svg { width: 38px; height: 38px; cursor: ns-resize; touch-action: none; }
    .dial-bg { fill: none; stroke: #222; stroke-width: 3; }
    .dial-val { 
        fill: none; stroke: var(--accent); stroke-width: 3; stroke-linecap: round; 
        stroke-dasharray: 0 100; transform: rotate(-90deg); transform-origin: 50% 50%;
    }
    .dial-label { font-size: 8px; color: var(--text-dim); margin-top: 4px; font-weight: 700; letter-spacing: 0.5px; }

    /* --- SCREEN AREA --- */
    .screen-area { position: relative; background: #000; cursor: crosshair; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }
    
    .toolbar {
        position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
        display: flex; flex-direction: column; gap: 8px; pointer-events: none;
    }
    .tool-btn {
        width: 28px; height: 28px; background: rgba(20,20,20,0.9);
        border: 1px solid var(--border); border-radius: 4px; pointer-events: auto;
        color: var(--text-dim); font-size: 14px; display: grid; place-items: center;
        cursor: pointer; transition: all 0.2s;
    }
    .tool-btn.active { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 10px rgba(212, 164, 24, 0.2); }

    .rack-label {
        position: absolute; top: 8px; right: 8px; 
        font-family: var(--font-mono); font-size: 10px; font-weight: bold;
        background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 2px;
        pointer-events: none; letter-spacing: 1px;
    }

    /* --- CONTROLS RIGHT (Buttons) --- */
    .controls-right {
        border-left: 1px solid var(--border); background: #0d0d0d;
        display: flex; flex-direction: column; align-items: center; justify-content: space-evenly;
        padding: 8px 6px;
    }
    .btn-rect {
        width: 100%; height: 22%; /* Proportional height */
        background: #181818; border: 1px solid var(--border);
        color: var(--text-dim); font-size: 9px; display: grid; place-items: center;
        cursor: pointer; border-radius: 2px; font-weight: 700; letter-spacing: 0.5px;
        transition: all 0.1s;
    }
    .btn-rect.active { background: var(--accent); color: #000; border-color: var(--accent); }
    .btn-rect:active { transform: scale(0.95); }

    /* --- FAB --- */
    #fab {
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
        background: rgba(10,10,10,0.95); backdrop-filter: blur(8px);
        border: 1px solid var(--border); border-radius: 50px;
        padding: 8px 16px; display: flex; gap: 16px; align-items: center;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8); z-index: 100;
    }
    .fab-play {
        width: 64px; height: 64px; background: var(--accent); color: #000;
        border-radius: 50%; display: grid; place-items: center;
        font-size: 28px; margin: -25px 0; border: 4px solid #000;
        cursor: pointer;
    }

    /* --- MODALS --- */
    .overlay {
        position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 999;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 0.3s; pointer-events: none; opacity: 0;
    }
    .overlay.visible { opacity: 1; pointer-events: auto; }
    
    .modal-card { 
        max-width: 300px; text-align: center; color: var(--text); line-height: 1.6; font-size: 12px; 
    }
    .modal-title { font-size: 18px; color: var(--accent); margin-bottom: 15px; font-weight: 800; letter-spacing: 2px; }
    
    .loader-btn {
        background: transparent; border: 1px solid var(--accent); color: var(--accent);
        padding: 15px 40px; font-size: 12px; letter-spacing: 3px; font-weight: 800;
        margin-top: 30px; cursor: pointer; transition: all 0.2s;
    }
    .loader-btn:hover { background: var(--accent); color: #000; }
    .close-btn { margin-top: 20px; text-decoration: underline; cursor: pointer; color: var(--text-dim); }

</style>
</head>
<body>

<!-- START SCREEN -->
<div id="start-overlay" class="overlay visible">
    <div style="color:#555; font-size:10px; margin-bottom:12px; font-family:monospace; letter-spacing: 1px;">HYPERCLAY // SYSTEM_READY</div>
    <div style="font-family:monospace; color:var(--text); font-size:32px; font-weight:800; letter-spacing: -1px;">MANIFOLD</div>
    <div style="color:var(--accent); font-size:12px; letter-spacing: 4px; margin-top:5px;">MATRIX_GRID</div>
    <button class="loader-btn" id="start-btn">INITIALIZE</button>
</div>

<!-- HELP SCREEN -->
<div id="help-overlay" class="overlay">
    <div class="modal-card">
        <div class="modal-title">ABOUT</div>
        <p>HYPERCLAY MANIFOLD is a polyphonic mesh sequencer.</p>
        <p><strong>SCULPT MODE:</strong> Drag on the canvas to warp the grid geometry. Higher terrain = Higher pitch.</p>
        <p><strong>SEQ MODE:</strong> Tap cells to activate notes. Active notes trigger based on their mesh height.</p>
        <div class="close-btn" onclick="document.getElementById('help-overlay').classList.remove('visible')">CLOSE</div>
    </div>
</div>

<header>
    <div class="header-grp">
        <div class="brand">HYPERCLAY</div>
        <div class="bpm-ctrl">
            <button class="bpm-btn" id="bpm-dec">-</button>
            <div class="bpm-val" id="bpm-display">110</div>
            <button class="bpm-btn" id="bpm-inc">+</button>
        </div>
    </div>
    <div class="header-grp">
        <button class="btn-icon" id="btn-help" title="About">?</button>
        <button class="btn-icon" id="btn-full" title="Fullscreen">⛶</button>
        <button class="btn-icon" id="global-mute" title="Mute All">M</button>
    </div>
</header>

<div id="rack-container"></div>

<div id="fab">
    <button class="fab-play" id="play-btn">▶</button>
</div>

<script>
/**
 * HYPERCLAY // MANIFOLD
 * v3.0 - Optimized UI
 */

const CONFIG = {
    bpm: 110,
    steps: 16,
    rows: 6,
    colors: {
        kick: '#d4a418',
        snare: '#b84a39',
        hat: '#c2b280',
        bass: '#635147',
        lead: '#8a9a5b'
    }
};

const AudioEngine = {
    ctx: null, master: null, limiter: null,
    nextNoteTime: 0.0, currentStep: 0, timerID: null, isPlaying: false,

    init() {
        if (this.ctx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AC({ latencyHint: 'interactive' });
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -3.0;
        this.master = this.ctx.createGain(); this.master.gain.value = 0.7;
        this.master.connect(this.limiter); this.limiter.connect(this.ctx.destination);
    },

    resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },

    play() {
        if (this.isPlaying) return;
        this.resume();
        this.isPlaying = true;
        this.currentStep = 0;
        this.nextNoteTime = this.ctx.currentTime + 0.05;
        this.scheduler();
        document.getElementById('play-btn').innerText = '■';
    },

    stop() {
        this.isPlaying = false;
        window.clearTimeout(this.timerID);
        document.getElementById('play-btn').innerText = '▶';
    },

    toggle() { this.isPlaying ? this.stop() : this.play(); },

    scheduler() {
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
            this.scheduleNote(this.currentStep, this.nextNoteTime);
            this.nextStep();
        }
        this.timerID = window.setTimeout(() => this.scheduler(), 25);
    },

    nextStep() {
        this.nextNoteTime += 0.25 * (60.0 / CONFIG.bpm);
        this.currentStep = (this.currentStep + 1) % CONFIG.steps;
    },

    scheduleNote(step, time) {
        requestAnimationFrame(() => App.racks.forEach(r => r.onStep(step)));
        App.racks.forEach(r => r.triggerColumn(step, time));
    }
};

const Synths = {
    kick(ctx, dest, time, warp, params) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const freq = 140 - (warp * 40);
        osc.frequency.setValueAtTime(freq, time);
        osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
        gain.gain.setValueAtTime(0.8, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
        osc.connect(gain); gain.connect(dest);
        osc.start(time); osc.stop(time + 0.5);
    },
    snare(ctx, dest, time, warp, params) {
        const noise = ctx.createBufferSource();
        const buf = ctx.createBuffer(1, ctx.sampleRate*0.2, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<buf.length; i++) data[i] = Math.random()*2-1;
        noise.buffer = buf;
        const nFlt = ctx.createBiquadFilter();
        nFlt.type = 'highpass'; nFlt.frequency.value = params.filter;
        const nGain = ctx.createGain();
        nGain.gain.setValueAtTime(0.7, time);
        nGain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
        noise.connect(nFlt).connect(nGain).connect(dest);
        noise.start(time);
        
        const osc = ctx.createOscillator();
        const oGain = ctx.createGain();
        osc.frequency.setValueAtTime(200 + (warp*200), time);
        oGain.gain.setValueAtTime(0.5, time);
        oGain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
        osc.connect(oGain).connect(dest);
        osc.start(time); osc.stop(time + 0.15);
    },
    hat(ctx, dest, time, warp, params) {
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(800 + (warp*5000), time);
        const flt = ctx.createBiquadFilter();
        flt.type = 'highpass'; flt.frequency.value = 5000;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
        osc.connect(flt).connect(gain).connect(dest);
        osc.start(time); osc.stop(time + 0.1);
    },
    bass(ctx, dest, time, warp, params) {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        const notes = [55, 65, 73, 82, 98, 110, 130, 146];
        osc.frequency.value = notes[Math.floor(warp * (notes.length - 1))];
        const flt = ctx.createBiquadFilter();
        flt.type = 'lowpass'; flt.frequency.setValueAtTime(params.filter/2, time);
        flt.frequency.exponentialRampToValueAtTime(100, time+0.4);
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.5, time);
        gain.gain.linearRampToValueAtTime(0, time + 0.4);
        osc.connect(flt).connect(gain).connect(dest);
        osc.start(time); osc.stop(time + 0.5);
    },
    lead(ctx, dest, time, warp, params) {
        const osc = ctx.createOscillator();
        osc.type = 'triangle';
        const notes = [261, 311, 392, 523, 622, 784, 1046];
        osc.frequency.value = notes[Math.floor(warp * (notes.length - 1))];
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.3, time + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.6);
        const dly = ctx.createDelay(); dly.delayTime.value=0.3;
        const fb = ctx.createGain(); fb.gain.value=0.3;
        osc.connect(gain); gain.connect(dest); gain.connect(dly);
        dly.connect(fb); fb.connect(dly); dly.connect(dest);
        osc.start(time); osc.stop(time + 1.0);
    }
};

class Rack {
    constructor(id, type, container) {
        this.id = id; this.type = type; this.baseColor = CONFIG.colors[type];
        this.params = { strength: 10, radius: 60, filter: 2000, decay: 400 };
        this.mode = 'sculpt'; this.tool = 'push'; 
        this.muted = false; this.active = true; // Playing state
        
        // 16x6 Grid
        this.grid = Array(16).fill().map(() => Array(6).fill().map(() => ({ active: false, warp: 0 })));

        // Initial Dimensions
        this.w = 0; this.h = 0;
        
        this.el = document.createElement('div');
        this.el.className = 'rack';
        this.el.innerHTML = `
            <div class="controls-left">
                ${this.dial('strength', 1, 20, 10, 'FORCE')}
                ${this.dial('radius', 20, 150, 60, 'SIZE')}
                ${this.dial('filter', 200, 8000, 2000, 'TONE')}
            </div>
            <div class="screen-area">
                <canvas></canvas>
                <div class="rack-label" style="color:${this.baseColor}">${this.id} // ${this.type.toUpperCase()}</div>
                <div class="toolbar">
                    <div class="tool-btn active" data-t="push">●</div>
                    <div class="tool-btn" data-t="pull">○</div>
                    <div class="tool-btn" data-t="noise">∿</div>
                </div>
            </div>
            <div class="controls-right">
                <div class="btn-rect active" data-a="play">PLAY</div>
                <div class="btn-rect" data-a="mute">MUTE</div>
                <div class="btn-rect" data-a="clear">CLR</div>
                <div class="btn-rect" data-a="mode">SCULPT</div>
            </div>`;
        container.appendChild(this.el);

        this.cv = this.el.querySelector('canvas');
        this.ctx = this.cv.getContext('2d', { alpha: false });
        this.pts = [];
        
        this.bindEvents();
    }

    dial(p, min, max, val, lbl) {
        return `<div class="dial-wrapper">
            <svg class="dial-svg" data-p="${p}" data-min="${min}" data-max="${max}" data-val="${val}" viewBox="0 0 36 36">
                <path class="dial-bg" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
                <path class="dial-val" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
            </svg>
            <div class="dial-label">${lbl}</div>
        </div>`;
    }

    resize() {
        const rect = this.cv.parentElement.getBoundingClientRect();
        if(rect.width === 0) return; 
        
        this.w = rect.width; this.h = rect.height;
        const dpr = window.devicePixelRatio || 1;
        this.cv.width = this.w * dpr; this.cv.height = this.h * dpr;
        this.ctx.scale(dpr, dpr);
        
        if (this.pts.length === 0) this.initMesh();
        else this.initMesh(); 
    }

    initMesh() {
        this.pts = [];
        const cols = 16, rows = 6;
        for(let r=0; r<=rows; r++) {
            for(let c=0; c<=cols; c++) {
                const x = (c/cols) * this.w;
                const y = (r/rows) * this.h;
                this.pts.push({ x, y, ox: x, oy: y });
            }
        }
        this.calcWarp();
    }

    calcWarp() {
        if(!this.h) return;
        const cols = 16, rows = 6;
        for(let c=0; c<cols; c++) {
            for(let r=0; r<rows; r++) {
                const tl = this.pts[r*(cols+1)+c];
                const bl = this.pts[(r+1)*(cols+1)+c];
                if(tl && bl) {
                    const avg = (tl.y + bl.y) / 2;
                    this.grid[c][r].warp = Math.max(0, Math.min(1, 1 - (avg / this.h)));
                }
            }
        }
    }

    updateDials() {
        this.el.querySelectorAll('.dial-svg').forEach(el => {
            const p = el.dataset.p, min=parseFloat(el.dataset.min), max=parseFloat(el.dataset.max);
            const val = this.params[p];
            const pct = (val - min) / (max - min);
            el.querySelector('.dial-val').style.strokeDasharray = `${pct * 100}, 100`;
        });
    }

    bindEvents() {
        // Dials
        this.el.querySelectorAll('.dial-svg').forEach(el => {
            el.addEventListener('pointerdown', e => {
                el.setPointerCapture(e.pointerId);
                const p=el.dataset.p, min=parseFloat(el.dataset.min), max=parseFloat(el.dataset.max);
                const startY=e.clientY, startVal=this.params[p];
                const move = ev => {
                    this.params[p] = Math.max(min, Math.min(max, startVal + (startY - ev.clientY)*0.5));
                    this.updateDials();
                };
                const up = () => { el.removeEventListener('pointermove', move); el.removeEventListener('pointerup', up); };
                el.addEventListener('pointermove', move); el.addEventListener('pointerup', up);
            });
        });
        this.updateDials();

        // Right Buttons
        const btns = this.el.querySelectorAll('.btn-rect');
        // Play
        btns[0].onclick = () => { 
            this.active = !this.active; 
            btns[0].classList.toggle('active', this.active);
            btns[0].innerText = this.active ? "PLAY" : "PAUSED";
            this.el.classList.toggle('paused', !this.active);
        };
        // Mute
        btns[1].onclick = () => { 
            this.muted = !this.muted; 
            this.el.classList.toggle('muted', this.muted); 
            btns[1].classList.toggle('active', this.muted); 
        };
        // Clear
        btns[2].onclick = () => { this.initMesh(); this.grid.forEach(col => col.forEach(c => c.active=false)); };
        // Mode
        btns[3].onclick = () => { 
            this.mode = this.mode==='sculpt'?'seq':'sculpt'; 
            btns[3].innerText = this.mode.toUpperCase(); 
            btns[3].classList.toggle('active', this.mode==='seq'); 
        };

        // Tools
        this.el.querySelectorAll('.tool-btn').forEach(b => b.onclick = () => {
            this.el.querySelectorAll('.tool-btn').forEach(btn=>btn.classList.remove('active'));
            b.classList.add('active'); this.tool = b.dataset.t;
        });

        // Canvas
        const onPtr = e => {
            const rect = this.cv.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            if(e.type === 'pointerdown') {
                this.cv.setPointerCapture(e.pointerId);
                this.isDown = true;
                if(this.mode === 'seq') this.handleTap(x, y);
                else this.sculpt(x, y);
            } else if(e.type === 'pointermove' && this.isDown) {
                if(this.mode === 'sculpt') this.sculpt(x, y);
            } else if(e.type === 'pointerup') {
                this.isDown = false;
            }
        };
        this.cv.addEventListener('pointerdown', onPtr);
        this.cv.addEventListener('pointermove', onPtr);
        this.cv.addEventListener('pointerup', onPtr);
    }

    handleTap(x, y) {
        const cols=16, rows=6;
        for(let c=0; c<cols; c++) {
            for(let r=0; r<rows; r++) {
                const p1 = this.pts[r*(cols+1)+c];
                const p3 = this.pts[(r+1)*(cols+1)+(c+1)];
                const minX = Math.min(p1.x, p3.x) - 2; 
                const maxX = Math.max(p1.x, p3.x) + 2;
                const minY = Math.min(p1.y, p3.y) - 2;
                const maxY = Math.max(p1.y, p3.y) + 2;

                if(x >= minX && x <= maxX && y >= minY && y <= maxY) {
                    this.grid[c][r].active = !this.grid[c][r].active;
                    if(this.grid[c][r].active && AudioEngine.ctx) {
                        const fn = Synths[this.type];
                        if(fn) fn(AudioEngine.ctx, AudioEngine.master, AudioEngine.ctx.currentTime, this.grid[c][r].warp, this.params);
                    }
                    return;
                }
            }
        }
    }

    sculpt(mx, my) {
        const rSq = this.params.radius ** 2;
        this.pts.forEach(p => {
            const dx = p.x - mx, dy = p.y - my;
            const dSq = dx*dx + dy*dy;
            if(dSq < rSq) {
                const f = (1 - Math.sqrt(dSq)/this.params.radius) * (this.params.strength/10);
                const dir = this.tool==='pull' ? -1 : 1;
                const noise = this.tool==='noise' ? (Math.random()-0.5)*3 : 1;
                p.x += (dx * 0.05 * f * dir * noise);
                p.y += (dy * 0.2 * f * dir * noise);
                p.y = Math.max(0, Math.min(this.h, p.y));
            }
        });
        this.calcWarp();
    }

    triggerColumn(step, time) {
        if(this.muted || !this.active) return;
        this.grid[step].forEach(cell => {
            if(cell.active) {
                const fn = Synths[this.type];
                if(fn) fn(AudioEngine.ctx, AudioEngine.master, time, cell.warp, this.params);
            }
        });
    }

    onStep(s) { this.currStep = s; }

    draw() {
        if (!this.w || !this.h) return;

        const ctx = this.ctx;
        const grad = ctx.createLinearGradient(0, 0, 0, this.h);
        grad.addColorStop(0, '#0a0a08'); grad.addColorStop(1, '#1a1815');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, this.w, this.h);

        const cols=16, rows=6;
        if(this.pts.length < 4) return;

        // Draw Cells
        for(let c=0; c<cols; c++) {
            for(let r=0; r<rows; r++) {
                const cell = this.grid[c][r];
                const active = cell.active;
                const playing = this.active && this.currStep === c;
                
                ctx.beginPath();
                const p1 = this.pts[r*(cols+1)+c];
                const p2 = this.pts[r*(cols+1)+(c+1)];
                const p3 = this.pts[(r+1)*(cols+1)+(c+1)];
                const p4 = this.pts[(r+1)*(cols+1)+c];
                
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                
                if(active) {
                    ctx.fillStyle = this.baseColor;
                    ctx.globalAlpha = 0.6 + (1 - r/rows)*0.3; 
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                } else {
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = 0.03;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }

                if(playing) {
                    ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.2; ctx.fill(); ctx.globalAlpha=1;
                }
            }
        }

        // Draw Mesh Lines
        ctx.lineWidth = 0.5; ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.beginPath();
        for(let c=0; c<=cols; c++) {
            for(let r=0; r<=rows; r++) {
                const p = this.pts[r*(cols+1)+c];
                if(r===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            }
        }
        for(let r=0; r<=rows; r++) {
            for(let c=0; c<=cols; c++) {
                const p = this.pts[r*(cols+1)+c];
                if(c===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            }
        }
        ctx.stroke();
    }
}

const App = {
    racks: [],
    init() {
        const container = document.getElementById('rack-container');
        const units = [
            { id: 'ALPHA', type: 'kick' },
            { id: 'BETA', type: 'snare' },
            { id: 'GAMMA', type: 'hat' },
            { id: 'DELTA', type: 'bass' },
            { id: 'EPSILON', type: 'lead' }
        ];

        units.forEach(u => this.racks.push(new Rack(u.id, u.type, container)));

        document.getElementById('start-btn').onclick = () => {
            AudioEngine.init(); AudioEngine.resume();
            document.getElementById('start-overlay').classList.remove('visible');
            setTimeout(() => {
                document.getElementById('start-overlay').style.display='none';
                this.racks.forEach(r => r.resize());
            }, 500);
        };
        
        document.getElementById('play-btn').onclick = () => AudioEngine.toggle();
        document.getElementById('global-mute').onclick = (e) => {
            const anyMuted = this.racks.some(r => r.muted);
            this.racks.forEach(r => {
                r.muted = !anyMuted;
                r.el.classList.toggle('muted', !anyMuted);
            });
            e.target.classList.toggle('active', !anyMuted);
        };

        // Header controls
        document.getElementById('btn-help').onclick = () => document.getElementById('help-overlay').classList.add('visible');
        document.getElementById('btn-full').onclick = () => {
            if(!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        };
        document.getElementById('bpm-inc').onclick = () => { CONFIG.bpm+=5; document.getElementById('bpm-display').innerText = CONFIG.bpm; };
        document.getElementById('bpm-dec').onclick = () => { CONFIG.bpm-=5; document.getElementById('bpm-display').innerText = CONFIG.bpm; };

        window.addEventListener('resize', () => this.racks.forEach(r => r.resize()));
        setTimeout(() => this.racks.forEach(r => r.resize()), 50);
        this.loop();
    },

    loop() {
        requestAnimationFrame(() => this.loop());
        this.racks.forEach(r => r.draw());
    }
};

window.onload = () => App.init();

</script>
</body>
</html>
