<!DOCTYPE html>
<html>
<head>
    <title>Reality Media Memory Palace - Natural Aura</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #87CEEB;
            font-family: "Georgia", serif;
            background: rgba(34, 139, 34, 0.6);
            padding: 15px;
            border-radius: 15px;
            pointer-events: none;
            border: 2px solid #8B4513;
        }
    </style>
</head>
<body>
    <div id="info">NATURAL PRESENCE | EMBODIED AURA</div>
    <a href="index_hub.html" style="position: fixed; bottom: 20px; left: 20px; color: #8B4513; background: rgba(34, 139, 34, 0.5); padding: 10px 20px; border-radius: 5px; text-decoration: none; font-family: 'Georgia', serif; z-index: 100;">Return to Hub</a>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        const branches = [];
        const leaves = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x228B22, 0.001);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            createNaturalEnvironment();
            createTreeStructure();
            createLeaves();

            window.addEventListener('resize', onWindowResize, false);
        }

        function createNaturalEnvironment() {
            // Ground
            const groundGeometry = new THREE.CircleGeometry(50, 32);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.5);
            scene.add(ambientLight);

            // Directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xFFFFFF, 1);
            sunLight.position.set(50, 100, 50);
            scene.add(sunLight);
        }

        function createTreeStructure() {
            function createBranch(startPoint, direction, length, thickness, depth) {
                if (depth <= 0) return;

                const endPoint = startPoint.clone().add(direction.multiplyScalar(length));
                
                const branchGeometry = new THREE.CylinderGeometry(
                    thickness * 0.7, thickness, length, 8
                );
                const branchMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8B4513,
                    shininess: 5
                });
                
                const branch = new THREE.Mesh(branchGeometry, branchMaterial);
                branch.position.copy(startPoint.clone().add(endPoint).multiplyScalar(0.5));
                branch.lookAt(endPoint);
                branch.rotateX(Math.PI / 2);
                
                branches.push(branch);
                scene.add(branch);

                if (depth > 0) {
                    const numBranches = 3;
                    for (let i = 0; i < numBranches; i++) {
                        const angle = (i / numBranches) * Math.PI * 2;
                        const newDirection = new THREE.Vector3(
                            Math.cos(angle) * 0.3,
                            0.7,
                            Math.sin(angle) * 0.3
                        ).normalize();
                        
                        createBranch(
                            endPoint,
                            newDirection,
                            length * 0.7,
                            thickness * 0.7,
                            depth - 1
                        );
                    }
                }
            }

            const startPoint = new THREE.Vector3(0, 0, 0);
            const direction = new THREE.Vector3(0, 1, 0);
            createBranch(startPoint, direction, 15, 1, 4);
        }

        function createLeaves() {
            const leafGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const leafMaterial = new THREE.MeshPhongMaterial({
                color: 0x228B22,
                shininess: 10
            });

            for (let i = 0; i < 500; i++) {
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                
                // Position leaves around the branches
                const radius = 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                leaf.position.x = radius * Math.sin(phi) * Math.cos(theta);
                leaf.position.y = 15 + radius * Math.cos(phi);
                leaf.position.z = radius * Math.sin(phi) * Math.sin(theta);
                
                leaf.scale.x = 1 + Math.random() * 0.5;
                leaf.scale.y = 0.3;
                leaf.scale.z = 1 + Math.random() * 0.5;
                
                leaf.rotation.x = Math.random() * Math.PI;
                leaf.rotation.y = Math.random() * Math.PI;
                leaf.rotation.z = Math.random() * Math.PI;
                
                leaf.userData = {
                    originalY: leaf.position.y,
                    phase: Math.random() * Math.PI * 2
                };
                
                leaves.push(leaf);
                scene.add(leaf);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Animate branches
            branches.forEach(branch => {
                branch.rotation.y += 0.001;
            });

            // Animate leaves
            const time = Date.now() * 0.001;
            leaves.forEach(leaf => {
                leaf.position.y = leaf.userData.originalY + 
                    Math.sin(time + leaf.userData.phase) * 0.2;
                leaf.rotation.x += 0.01;
                leaf.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }
        
        // Expose renderer, scene, and camera for video capture
        window._captureData = {
            renderer: renderer,
            scene: scene,
            camera: camera
        };
        
        // Also expose directly on window for easier access by video capture system
        window.renderer = renderer;
        window.scene = scene;
        window.camera = camera;
        
        // Create a special function to ensure proper rendering for video capture
        window.captureCurrentView = function() {
            // Make sure we're using a good camera position
            controls.update();
            
            // Force a render with current camera and scene
            renderer.render(scene, camera);
            
            // Return true to indicate success
            return true;
        };
        
        // Signal to parent that the scene is ready
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({ type: 'SCENE_READY' }, '*');
        }
    </script>
</body>
</html>
