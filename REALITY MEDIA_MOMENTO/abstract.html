<!DOCTYPE html>
<html>
<head>
    <title>Reality Media Memory Palace - Abstract Aura</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #FFFFFF;
            font-family: "Helvetica Neue", sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 2px;
            pointer-events: none;
            letter-spacing: 2px;
            border: 1px solid #FFFFFF;
        }
    </style>
</head>
<body>
    <div id="info">ABSTRACT PRESENCE | TEMPORAL FLOW</div>
    <a href="index_hub.html" style="position: fixed; bottom: 20px; left: 20px; color: #FFFFFF; background: rgba(128, 128, 128, 0.5); padding: 10px 20px; border-radius: 5px; text-decoration: none; font-family: 'Helvetica Neue', sans-serif; z-index: 100;">Return to Hub</a>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        const timelineObjects = [];
        const mediaNodes = [];

        // Timeline data from 3000 BCE to 2025 CE
        const timelineData = {
            eras: [
                { name: "Writing Era", start: -3000, end: 1440 },
                { name: "Print Era", start: 1440, end: 1900 },
                { name: "Broadcast Media", start: 1900, end: 2000 },
                { name: "Social Media", start: 2000, end: 2025 }
            ],
            theories: [
                { name: "Media Determinism", start: 1960, end: 2025 },
                { name: "Platform Paradox", start: 2005, end: 2025 },
                { name: "Wrong Theory", start: 2015, end: 2025 },
                { name: "Media Evolution", start: -3000, end: 2025 }
            ]
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            createAbstractEnvironment();
            createTimeline();
            createTheoryNodes();
            createConnections();

            window.addEventListener('resize', onWindowResize, false);
        }

        function createAbstractEnvironment() {
            // Create infinite grid
            const size = 1000;
            const divisions = 100;
            const gridHelper = new THREE.GridHelper(size, divisions, 0xFFFFFF, 0x404040);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.1;
            scene.add(gridHelper);

            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.2);
            scene.add(ambientLight);

            // Directional lights
            [-1, 1].forEach(direction => {
                const light = new THREE.DirectionalLight(0xFFFFFF, 0.5);
                light.position.set(direction * 50, 100, direction * 50);
                scene.add(light);
            });
        }

        function createTimeline() {
            // Main timeline axis
            const axisGeometry = new THREE.BoxGeometry(200, 0.5, 0.5);
            const axisMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const axis = new THREE.Mesh(axisGeometry, axisMaterial);
            scene.add(axis);

            // Create era markers
            timelineData.eras.forEach(era => {
                const duration = era.end - era.start;
                const position = mapTimeToPosition(era.start + duration/2);
                const width = mapTimeToWidth(duration);

                const markerGeometry = new THREE.BoxGeometry(width, 2, 2);
                const markerMaterial = new THREE.MeshPhongMaterial({
                    color: 0x808080,
                    transparent: true,
                    opacity: 0.3
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.x = position;
                marker.position.y = -2;
                timelineObjects.push(marker);
                scene.add(marker);
            });
        }

        function createTheoryNodes() {
            timelineData.theories.forEach((theory, i) => {
                const duration = theory.end - theory.start;
                const position = mapTimeToPosition(theory.start + duration/2);
                const size = mapTimeToWidth(duration) * 0.1;

                const geometry = new THREE.OctahedronGeometry(size);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xFFFFFF,
                    wireframe: true
                });
                const node = new THREE.Mesh(geometry, material);
                node.position.set(position, 10 + i * 5, 0);
                node.userData = { theory };
                mediaNodes.push(node);
                scene.add(node);

                // Add orbiting particles
                createOrbitingParticles(node, 10);
            });
        }

        function createOrbitingParticles(node, count) {
            for(let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(0.1);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.5
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.userData = {
                    orbit: {
                        radius: 2 + Math.random() * 2,
                        speed: 0.001 + Math.random() * 0.002,
                        offset: Math.random() * Math.PI * 2
                    },
                    center: node.position.clone()
                };
                
                timelineObjects.push(particle);
                scene.add(particle);
            }
        }

        function createConnections() {
            // Create connections between related theories
            const connections = [
                [0, 2], // Media Determinism - Wrong Theory
                [1, 2], // Platform Paradox - Wrong Theory
                [2, 3], // Wrong Theory - Media Evolution
                [0, 3]  // Media Determinism - Media Evolution
            ];

            connections.forEach(([from, to]) => {
                const fromNode = mediaNodes[from];
                const toNode = mediaNodes[to];
                
                const points = [];
                points.push(fromNode.position);
                points.push(toNode.position);

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.2
                });
                const line = new THREE.Line(geometry, material);
                timelineObjects.push(line);
                scene.add(line);
            });
        }

        function mapTimeToPosition(year) {
            const timeRange = 5025; // From -3000 to 2025
            const position = ((year + 3000) / timeRange) * 200 - 100;
            return position;
        }

        function mapTimeToWidth(duration) {
            const timeRange = 5025;
            return (duration / timeRange) * 200;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.001;

            // Rotate theory nodes
            mediaNodes.forEach(node => {
                node.rotation.x += 0.01;
                node.rotation.y += 0.01;
            });

            // Animate orbiting particles
            timelineObjects.forEach(obj => {
                if(obj.userData && obj.userData.orbit) {
                    const orbit = obj.userData.orbit;
                    const center = obj.userData.center;
                    
                    obj.position.x = center.x + Math.cos(time * orbit.speed + orbit.offset) * orbit.radius;
                    obj.position.y = center.y + Math.sin(time * orbit.speed + orbit.offset) * orbit.radius;
                    obj.position.z = center.z + Math.cos(time * orbit.speed * 2) * orbit.radius * 0.5;
                }
            });

            renderer.render(scene, camera);
        }
        
        // Expose renderer, scene, and camera for video capture
        window._captureData = {
            renderer: renderer,
            scene: scene,
            camera: camera
        };
        
        // Also expose directly on window for easier access by video capture system
        window.renderer = renderer;
        window.scene = scene;
        window.camera = camera;
        
        // Create a special function to ensure proper rendering for video capture
        window.captureCurrentView = function() {
            // Make sure we're using a good camera position
            controls.update();
            
            // Force a render with current camera and scene
            renderer.render(scene, camera);
            
            // Return true to indicate success
            return true;
        };
        
        // Signal to parent that the scene is ready
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({ type: 'SCENE_READY' }, '*');
        }
    </script>
</body>
</html>
