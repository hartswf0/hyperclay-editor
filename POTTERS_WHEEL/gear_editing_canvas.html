<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Main Gear Film Engine — Single-File POC</title>
<style>
  :root{
    --bg:#0b0c10;--ink:#eae7df;--muted:#9aa0a6;--accent:#00d0b4;--gold:#c8a552;--rose:#ff4d6d;--ok:#19c37d;--warn:#e6b800;--bad:#ff4d4f;
    --rim:#161a20;--tick:#252c33;--panel:#0f1319f2;--glass:#0b0f14cc;--btn:#131922;--btnb:#29303a;--blue:#5aa9e6;--purple:#8a5cf6;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #c{position:fixed;inset:0;display:block}
  /* Top toolbar */
  #toolbar{position:fixed;top:8px;left:8px;right:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;z-index:5}
  .badge{background:var(--glass);border:1px solid #1e2530;border-radius:999px;padding:6px 10px;font-size:12px;line-height:1;user-select:none}
  .badge .k{opacity:.7;margin-right:6px}
  .badge.toggle{cursor:pointer}
  .dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px;background:#5a616c}
  /* Bottom HUD */
  #hud{position:fixed;left:0;right:0;bottom:8px;display:flex;justify-content:center;gap:8px;z-index:6}
  button,input[type=file]::file-selector-button{font:600 12px/1 system-ui;border-radius:12px;border:1px solid var(--btnb);background:var(--btn);color:var(--ink);padding:10px 12px;cursor:pointer}
  button.icon{width:40px;height:40px;border-radius:50%}
  button.primary{border-color:#1d3c35;background:#0e2724}
  button.rec{background:#2d1212;border-color:#5a1f1f;color:#ff9a9a}
  a#dl{display:none;margin-left:8px;text-decoration:none}
  /* Panels */
  .panel{position:fixed;right:12px;top:56px;bottom:56px;width:min(420px,92vw);background:var(--panel);border:1px solid #1e2530;border-radius:16px;box-shadow:0 20px 50px #0008;overflow:auto;padding:14px 14px 90px;z-index:10;display:none}
  .panel.open{display:block}
  .panel h3{margin:6px 0 8px;font-size:14px;color:#cfd3d8}
  .row{display:flex;align-items:center;gap:8px;margin:6px 0}
  .row label{flex:0 0 120px;font-size:12px;color:#c0c6cf}
  .row input[type=range]{flex:1}
  .seg{border:1px solid #28303a;border-radius:10px;padding:8px;margin:8px 0;background:#0c1218}
  .seg .row label{flex-basis:90px}
  .seg header{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:#bac2cc;margin-bottom:6px}
  .seg header .ops button{margin-left:6px}
  .pill{display:inline-block;padding:3px 8px;border:1px solid #2a313b;border-radius:999px;font-size:11px;color:#c9d0d9}
  .kbd{font-family:ui-monospace,Consolas,monospace;background:#10161f;border:1px solid #26303c;border-radius:6px;padding:2px 6px}
  .ghost{opacity:.65}
  .hint{opacity:.8;font-size:12px;margin:8px 0 0}
</style>
</head>
<body>
  <!-- Top toolbar badges -->
  <div id="toolbar">
    <div class="badge" id="driveBadge"><span class="k">Drive:</span><span id="driveVal">MAIN</span></div>
    <div class="badge toggle" id="bpmBadge"><span class="k">BPM:</span><span id="bpmVal">Free</span></div>
    <div class="badge toggle" id="quantBadge"><span class="k">Quant:</span><span id="quantVal">Off</span></div>
    <div class="badge toggle" id="mixBadge"><span class="k">Mix:</span><span id="mixVal">source-over</span></div>
    <div class="badge toggle" id="outBadge"><span class="k">Output:</span><span id="outVal">Normal</span></div>
    <div class="badge toggle" id="arcsBadge"><span class="k">ARCS</span><span id="arcsVal">on</span></div>
  </div>

  <!-- Main canvas -->
  <canvas id="c"></canvas>

  <!-- Bottom HUD -->
  <div id="hud">
    <label class="badge">
      Add Video
      <input id="addVideo" type="file" accept="video/*" multiple style="display:none" />
    </label>
    <label class="badge">
      Add Image
      <input id="addImage" type="file" accept="image/*" multiple style="display:none" />
    </label>
    <label class="badge">
      Add Audio
      <input id="addAudio" type="file" accept="audio/*" multiple style="display:none" />
    </label>
    <button id="addText">Add Text</button>
    <button id="playPause" class="primary">Play</button>
    <button id="hapticT" title="Haptics on/off">HAPTIC</button>
    <button id="route">Route</button>
    <button id="record" class="rec">● Record</button>
    <a id="dl" download>Download</a>
    <button id="settingsBtn">Settings: Center Ring</button>
  </div>

  <!-- Inspector Panel -->
  <aside id="inspector" class="panel" aria-label="Inspector" tabindex="-1"></aside>
  <!-- Settings Panel -->
  <aside id="settings" class="panel" aria-label="Settings" tabindex="-1"></aside>

<script>
(() => {
  // ====== Constants ======
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  const TOOTH_PITCH = 16; // px between teeth along circumference
  const PX_PER_SEC = 5;   // radius scaling: r = k * duration
  const TWO_PI = Math.PI * 2;
  const MINOR_DIV = 60; // 1/60th
  const MAJOR_DIV = 12; // 1/12th
  const STAGE_SCALE = 0.62; // of viewport, fit 16:9
  const GHOST_ALPHA = 0.25;

  // ====== State ======
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const toolbar = {
    drive: document.getElementById('driveVal'),
    bpmBadge: document.getElementById('bpmBadge'),
    bpmVal: document.getElementById('bpmVal'),
    quantBadge: document.getElementById('quantBadge'),
    quantVal: document.getElementById('quantVal'),
    mixBadge: document.getElementById('mixBadge'),
    mixVal: document.getElementById('mixVal'),
    outBadge: document.getElementById('outBadge'),
    outVal: document.getElementById('outVal'),
    arcsBadge: document.getElementById('arcsBadge'),
    arcsVal: document.getElementById('arcsVal'),
  };
  const hud = {
    addVideo: document.getElementById('addVideo'),
    addImage: document.getElementById('addImage'),
    addAudio: document.getElementById('addAudio'),
    addText: document.getElementById('addText'),
    playPause: document.getElementById('playPause'),
    hapticT: document.getElementById('hapticT'),
    route: document.getElementById('route'),
    record: document.getElementById('record'),
    dl: document.getElementById('dl'),
    settingsBtn: document.getElementById('settingsBtn'),
  };
  const inspectorEl = document.getElementById('inspector');
  const settingsEl = document.getElementById('settings');

  const stage = {
    cv: document.createElement('canvas'),
    ctx: null,
    rect: {x:0,y:0,w:0,h:0},
    mix: 'source-over'
  };
  stage.ctx = stage.cv.getContext('2d', { alpha: true, desynchronized: true });

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let sfxGain = audioCtx.createGain(); sfxGain.gain.value = 0.3; sfxGain.connect(audioCtx.destination);

  const haptics = {
    on: true,
    bpm: null,
    minorMs: 8,
    majorMs: 16,
    perfectPattern: [12,24,12],
    volMinor: 0.08,
    volMajor: 0.12,
    volPerfect: 0.2,
  };

  let gears = [];
  let selectedId = null; // for inspector & route
  let driveIndex = 0; // index in gears for drive, MAIN=0
  let playing = true;
  let showArcs = true;
  let outputMode = 'Normal'; // or 'Canvas'
  let quantMode = 'Off'; // Off|60th|12th
  let rec = {recorder:null, chunks:[], stream:null, target:'stage'};

  // ====== Utilities ======
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const mod = (n,m)=>((n % m) + m) % m;
  const now = ()=>performance.now();
  const dist = (x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
  function id(){return 'g'+Math.random().toString(36).slice(2,8)}

  function secToRadius(sec){return Math.max(30, sec*PX_PER_SEC)}
  function radiusToSec(r){return r/PX_PER_SEC}
  function teethForR(r){return Math.max(6, Math.round((TWO_PI*r)/TOOTH_PITCH))}

  function dbToGain(db){return Math.pow(10, db/20)}

  // SFX blip
  function tone(freq=440, ms=20, vol=0.1){
    try{
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = vol; o.frequency.value = freq;
      o.connect(g); g.connect(sfxGain);
      o.start(); g.gain.setValueAtTime(vol, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + ms/1000);
      o.stop(audioCtx.currentTime + ms/1000);
    }catch(e){}
  }
  function vibrate(pattern){ if(haptics.on && navigator.vibrate) navigator.vibrate(pattern); }

  // ====== Stage sizing ======
  function sizeAll(){
    const w = Math.floor(window.innerWidth * DPR);
    const h = Math.floor(window.innerHeight * DPR);
    canvas.width = w; canvas.height = h; canvas.style.width = window.innerWidth+'px'; canvas.style.height = window.innerHeight+'px';
    // Stage rect centered, 62% of viewport fit to 16:9
    const vw = window.innerWidth, vh = window.innerHeight;
    let targetW = vw * STAGE_SCALE, targetH = targetW * 9/16;
    if(targetH > vh*STAGE_SCALE){ targetH = vh*STAGE_SCALE; targetW = targetH * 16/9; }
    stage.rect.w = Math.floor(targetW); stage.rect.h = Math.floor(targetH);
    stage.rect.x = Math.floor((vw - targetW)/2); stage.rect.y = Math.floor((vh - targetH)/2);
    stage.cv.width = Math.floor(stage.rect.w * DPR); stage.cv.height = Math.floor(stage.rect.h * DPR);
  }
  sizeAll();
  new ResizeObserver(sizeAll).observe(document.body);

  // ====== Gear model ======
  function makeGear({kind='group', label='GEAR', duration=8, x, y, routed=false, throttle=1, ease='linear', seq=[]}={}){
    const r = secToRadius(duration);
    const g = {
      id: id(), x: x??(canvas.width/(2*DPR)), y: y??(canvas.height/(2*DPR)), r,
      teeth: teethForR(r), angle: 0, omega: 0,
      duration, label, kind, routed, throttle, ease,
      seq: ensureSeq(seq), eligible: true, meshed: false, quant:'Off',
      lastMinorStep:0, lastMajorStep:0,
    };
    return g;
  }

  function ensureSeq(seq){
    if(!seq || !seq.length) return [{type:'placeholder',label:'Empty',w:1,offset:0,stretch:1,opacity:1,gain:0,fin:0,fout:0,blend:'source-over'}];
    // normalize: ensure keys
    return seq.map(s=>({
      type:s.type||'placeholder', label:s.label||s.type||'seg',
      w:(s.w??1), offset:(s.offset??0), stretch:(s.stretch??1), opacity:(s.opacity??1),
      gain:(s.gain??0), fin:(s.fin??0), fout:(s.fout??0), blend:(s.blend||'source-over'), lines:s.lines, media:s.media
    }));
  }

  // MAIN gear
  const MAIN = makeGear({label:'MAIN', duration:12, routed:true});
  MAIN.kind='group';
  gears.push(MAIN);

  // ====== Input: add media/text ======
  hud.addVideo.addEventListener('change', e=>handleFiles(e.target.files,'video'));
  hud.addImage.addEventListener('change', e=>handleFiles(e.target.files,'img'));
  hud.addAudio.addEventListener('change', e=>handleFiles(e.target.files,'audio'));
  hud.addText.addEventListener('click', ()=>{
    const t = prompt('Enter text (
 makes new line)');
    if(!t) return;
    const lines = t.split(/
+/).map(s=>s.trim()).filter(Boolean);
    const g = makeGear({kind:'text', label:'TEXT', duration: Math.max(4, lines.length*2), routed:false});
    g.seq = [{type:'text', label:'Text', w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.2, fout:.2, blend:'source-over', lines}];
    placeOuter(g);
    gears.push(g);
    select(g.id);
  });

  function handleFiles(files, kind){
    [...files].forEach(file=>{
      const url = URL.createObjectURL(file);
      if(kind==='video'){
        const v = document.createElement('video');
        v.src=url; v.loop=true; v.muted=true; v.playsInline=true; v.preload='auto';
        v.addEventListener('loadedmetadata',()=>{ v.currentTime=0; });
        const g = makeGear({kind:'video', label:file.name, duration: Math.max(6, Math.min(24, (v.duration||8))), routed:false});
        g.seq = [{type:'video', label:file.name, w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.15, fout:.15, blend:'source-over', media:v}];
        placeOuter(g); gears.push(g); select(g.id);
      } else if(kind==='img'){
        const im = new Image(); im.src=url;
        const g = makeGear({kind:'img', label:file.name, duration:8, routed:false});
        g.seq = [{type:'img', label:file.name, w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.15, fout:.15, blend:'source-over', media:im}];
        placeOuter(g); gears.push(g); select(g.id);
      } else if(kind==='audio'){
        const a = document.createElement('audio');
        a.src=url; a.loop=true; a.preload='auto'; a.crossOrigin='anonymous';
        a.addEventListener('loadedmetadata',()=>{ a.currentTime=0; });
        const g = makeGear({kind:'audio', label:file.name, duration:12, routed:false});
        g.seq = [{type:'audio', label:file.name, w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.15, fout:.15, blend:'source-over', media:a}];
        placeOuter(g); gears.push(g); select(g.id);
      }
    });
    // reset so same file can be re-added
    hud.addVideo.value=''; hud.addImage.value=''; hud.addAudio.value='';
  }

  function placeOuter(g){
    // place roughly on rim at random angle
    const ang = Math.random()*TWO_PI;
    const cx = canvas.width/(2*DPR), cy = canvas.height/(2*DPR);
    const R = MAIN.r + g.r + 6; // small gap before snap
    g.x = cx + Math.cos(ang)*R; g.y = cy + Math.sin(ang)*R;
  }

  // ====== Selection & inspector ======
  function select(id){ selectedId=id; renderInspector(); updateToolbar(); }
  function selected(){ return gears.find(g=>g.id===selectedId) || MAIN }

  function renderInspector(){
    const g = selected();
    const qOpts = ['Off','60th','12th'];
    const easeOpts = ['linear','ease-in','ease-out','ease-in-out'];
    const blends = ['source-over','multiply','screen','overlay','lighten'];
    inspectorEl.innerHTML = `
      <h3>Inspector — <span class="pill">${g.label}</span> <span class="ghost">#${g.id}</span></h3>
      <div class="row"><label>Duration (s)</label><input id="dur" type="range" min="2" max="60" step="1" value="${g.duration}"><span class="pill">${g.duration}</span></div>
      <div class="row"><label>Ease</label>
        <select id="ease">${easeOpts.map(o=>`<option ${o===g.ease?'selected':''}>${o}</option>`).join('')}</select>
      </div>
      <div class="row"><label>Route to Stage</label><input id="routeChk" type="checkbox" ${g.routed?'checked':''}></div>
      <div class="row"><label>Drive throttle</label><input id="throttle" type="range" min="0" max="2" step="0.01" value="${g.throttle}"><span class="pill">${g.throttle.toFixed(2)}</span></div>
      <div class="row"><label>Quantize arcs</label>
        <select id="quantSel">${qOpts.map(o=>`<option ${o===g.quant?'selected':''}>${o}</option>`).join('')}</select>
      </div>
      <h3>Segments</h3>
      ${g.seq.map((s,idx)=>`<div class="seg" data-i="${idx}">
        <header><span>${idx+1}. ${s.label} <span class="ghost">(${s.type})</span></span>
          <span class="ops">
            <button class="del">Delete</button>
            <button class="up">↑</button>
            <button class="down">↓</button>
          </span>
        </header>
        <div class="row"><label>w (weight)</label><input class="w" type="range" min="0.01" max="1" step="0.01" value="${s.w}"><span class="pill">${s.w.toFixed(2)}</span></div>
        <div class="row"><label>offset (s)</label><input class="offset" type="number" step="0.01" value="${s.offset}"></div>
        <div class="row"><label>stretch</label><input class="stretch" type="number" step="0.01" value="${s.stretch}"></div>
        <div class="row"><label>opacity</label><input class="opacity" type="range" min="0" max="1" step="0.01" value="${s.opacity}"><span class="pill">${Math.round(s.opacity*100)}%</span></div>
        <div class="row"><label>gain (dB)</label><input class="gain" type="number" step="0.5" value="${s.gain}"></div>
        <div class="row"><label>fade in (s)</label><input class="fin" type="number" step="0.01" value="${s.fin}"></div>
        <div class="row"><label>fade out (s)</label><input class="fout" type="number" step="0.01" value="${s.fout}"></div>
        <div class="row"><label>blend</label>
          <select class="blend">${blends.map(b=>`<option ${b===s.blend?'selected':''}>${b}</option>`).join('')}</select>
        </div>
      </div>`).join('')}
      <div class="row">
        <button id="addTextSeg">+Text</button>
        <span class="hint">Weights are normalized to 1. Quant rounds to ${quantMode==='60th'?'1/60th':quantMode==='12th'?'1/12th':'off'}.</span>
      </div>
    `;
    inspectorEl.classList.add('open');
  }

  inspectorEl.addEventListener('input', (e)=>{
    const g = selected();
    if(e.target.id==='dur'){
      g.duration = parseFloat(e.target.value);
      g.r = secToRadius(g.duration); g.teeth = teethForR(g.r);
    }
    if(e.target.id==='ease'){ g.ease = e.target.value; }
    if(e.target.id==='routeChk'){ g.routed = e.target.checked; }
    if(e.target.id==='throttle'){ g.throttle = parseFloat(e.target.value); }
    if(e.target.id==='quantSel'){ g.quant = e.target.value; }
    const segEl = e.target.closest('.seg');
    if(segEl){
      const i = +segEl.dataset.i; const s = g.seq[i];
      if(e.target.classList.contains('w')) s.w = parseFloat(e.target.value);
      if(e.target.classList.contains('offset')) s.offset = parseFloat(e.target.value);
      if(e.target.classList.contains('stretch')) s.stretch = parseFloat(e.target.value);
      if(e.target.classList.contains('opacity')) s.opacity = parseFloat(e.target.value);
      if(e.target.classList.contains('gain')) s.gain = parseFloat(e.target.value);
      if(e.target.classList.contains('fin')) s.fin = parseFloat(e.target.value);
      if(e.target.classList.contains('fout')) s.fout = parseFloat(e.target.value);
      if(e.target.classList.contains('blend')) s.blend = e.target.value;
    }
  });
  inspectorEl.addEventListener('click',(e)=>{
    const g = selected();
    if(e.target.id==='addTextSeg'){
      const t = prompt('Text lines (
 separated)'); if(!t) return;
      const seg = {type:'text', label:'Text', lines:t.split(/
+/), w:.5, offset:0, stretch:1, opacity:1, gain:0, fin:.1, fout:.1, blend:'source-over'};
      g.seq.push(seg); renderInspector();
    }
    const segEl = e.target.closest('.seg'); if(!segEl) return;
    const i = +segEl.dataset.i;
    if(e.target.classList.contains('del')){ g.seq.splice(i,1); renderInspector(); }
    if(e.target.classList.contains('up')){ if(i>0){ [g.seq[i-1],g.seq[i]]=[g.seq[i],g.seq[i-1]]; renderInspector(); } }
    if(e.target.classList.contains('down')){ if(i<g.seq.length-1){ [g.seq[i+1],g.seq[i]]=[g.seq[i],g.seq[i+1]]; renderInspector(); } }
  });

  // Settings Panel (Center Ring / Haptics)
  function renderSettings(){
    settingsEl.innerHTML = `
      <h3>Center Ring — Haptics & Tempo</h3>
      <div class="row"><label>BPM (empty = Free)</label><input id="bpmInput" type="number" step="1" min="1" value="${haptics.bpm??''}"></div>
      <div class="row"><label>Minor vib (ms)</label><input id="vMinor" type="number" value="${haptics.minorMs}"></div>
      <div class="row"><label>Major vib (ms)</label><input id="vMajor" type="number" value="${haptics.majorMs}"></div>
      <div class="row"><label>Perfect pattern</label><input id="vPerfect" type="text" value="${haptics.perfectPattern.join(',')}"></div>
      <div class="row"><label>Vol minor</label><input id="volMinor" type="number" step="0.01" value="${haptics.volMinor}"></div>
      <div class="row"><label>Vol major</label><input id="volMajor" type="number" step="0.01" value="${haptics.volMajor}"></div>
      <div class="row"><label>Vol perfect</label><input id="volPerfect" type="number" step="0.01" value="${haptics.volPerfect}"></div>
      <p class="hint">ESC or click outside to close.</p>
    `;
    settingsEl.classList.add('open');
  }
  settingsEl.addEventListener('input',(e)=>{
    if(e.target.id==='bpmInput'){ const val=e.target.value.trim(); haptics.bpm = val===''?null:parseFloat(val)||null; }
    if(e.target.id==='vMinor') haptics.minorMs = parseInt(e.target.value)||8;
    if(e.target.id==='vMajor') haptics.majorMs = parseInt(e.target.value)||16;
    if(e.target.id==='vPerfect') haptics.perfectPattern = e.target.value.split(',').map(s=>parseInt(s)||0).filter(Boolean);
    if(e.target.id==='volMinor') haptics.volMinor = parseFloat(e.target.value)||0.08;
    if(e.target.id==='volMajor') haptics.volMajor = parseFloat(e.target.value)||0.12;
    if(e.target.id==='volPerfect') haptics.volPerfect = parseFloat(e.target.value)||0.2;
  });

  // ====== Toolbar/HUD interactions ======
  toolbar.bpmBadge.addEventListener('click', ()=>{
    const inp = prompt('BPM (empty for Free)', haptics.bpm??'');
    haptics.bpm = (inp===''||inp===null)?null:parseFloat(inp)||null;
    updateToolbar();
  });
  const quantModes = ['Off','60th','12th'];
  toolbar.quantBadge.addEventListener('click', ()=>{
    const i = (quantModes.indexOf(quantMode)+1)%quantModes.length; quantMode = quantModes[i]; updateToolbar();
  });
  const mixes = ['source-over','screen','multiply','overlay','lighten'];
  toolbar.mixBadge.addEventListener('click', ()=>{
    const i = (mixes.indexOf(stage.mix)+1)%mixes.length; stage.mix = mixes[i]; updateToolbar();
  });
  toolbar.outBadge.addEventListener('click', ()=>{
    outputMode = outputMode==='Normal'?'Canvas':'Normal'; updateToolbar();
  });
  toolbar.arcsBadge.addEventListener('click', ()=>{ showArcs=!showArcs; updateToolbar(); });

  hud.playPause.addEventListener('click', ()=>{ playing=!playing; hud.playPause.textContent = playing?'Pause':'Play'; });
  hud.hapticT.addEventListener('click', ()=>{ haptics.on=!haptics.on; hud.hapticT.classList.toggle('primary', haptics.on); });
  hud.route.addEventListener('click', ()=>{ const g=selected(); if(g){ g.routed=!g.routed; renderInspector(); }});
  hud.settingsBtn.addEventListener('click', renderSettings);

  // Recording
  hud.record.addEventListener('click', ()=>{
    if(rec.recorder){ stopRecording(); } else { startRecording(); }
  });

  function updateToolbar(){
    toolbar.drive.textContent = selected().label || 'MAIN';
    toolbar.bpmVal.textContent = haptics.bpm?String(haptics.bpm):'Free';
    toolbar.quantVal.textContent = quantMode;
    toolbar.mixVal.textContent = stage.mix;
    toolbar.outVal.textContent = outputMode;
    toolbar.arcsVal.textContent = showArcs?'on':'off';
  }
  updateToolbar();

  // ====== Pointer interactions (drag / rotate / snap) ======
  let pointer = {down:false, id:null, x:0,y:0, lastA:0, mode:null}; // mode: 'move'|'rotate'

  canvas.addEventListener('pointerdown', (e)=>{
    audioCtx.resume?.();
    const x = e.clientX, y = e.clientY; pointer.down=true; pointer.id=e.pointerId; pointer.x=x; pointer.y=y;
    // select nearest gear within radius
    const g = pickGear(x,y);
    if(g){ select(g.id); const dx=x-g.x, dy=y-g.y; const d=Math.hypot(dx,dy);
      pointer.mode = (d>g.r*0.7)?'rotate':'move';
      pointer.lastA = Math.atan2(dy,dx);
    } else { pointer.mode=null; selectedId = MAIN.id; }
  });
  window.addEventListener('pointermove', (e)=>{
    if(!pointer.down) return; const g = selected(); if(!g) return; const x=e.clientX, y=e.clientY; const dx=x-g.x, dy=y-g.y; const ang = Math.atan2(dy,dx);
    if(pointer.mode==='move'){
      g.x = x; g.y = y; // snap check
      const cx=canvas.width/(2*DPR), cy=canvas.height/(2*DPR);
      const d = dist(g.x,g.y,cx,cy);
      const ideal = MAIN.r + g.r;
      if(Math.abs(d-ideal) < 12){
        // snap to tangency
        const a = Math.atan2(g.y-cy, g.x-cx);
        g.x = cx + Math.cos(a)*ideal;
        g.y = cy + Math.sin(a)*ideal;
        if(!g.meshed){ perfectHaptic(); g.meshed=true; }
      } else { g.meshed=false; }
    } else if(pointer.mode==='rotate'){
      const delta = ang - pointer.lastA; g.angle += delta; pointer.lastA = ang;
    }
  });
  window.addEventListener('pointerup', ()=>{ pointer.down=false; pointer.mode=null; });

  function pickGear(x,y){
    let best=null, bestD=1e9; for(const g of gears){ const d = Math.hypot(x-g.x, y-g.y); if(d < g.r+20 && d<bestD){ best=g; bestD=d; } }
    return best;
  }

  function perfectHaptic(){ vibrate(haptics.perfectPattern); tone(220,50,haptics.volPerfect); tone(110,70,haptics.volPerfect*0.7); }

  // ====== Playback clock ======
  let lastT = now();
  function step(){
    const t = now();
    const dt = Math.min(50, t-lastT)/1000; // seconds
    lastT = t;

    // compute MAIN omega
    if(haptics.bpm){ MAIN.omega = TWO_PI / ((60/haptics.bpm)*4); } else { MAIN.omega = TWO_PI / MAIN.duration; }

    // advance angles
    for(let i=0;i<gears.length;i++){
      const g = gears[i];
      // coupling
      if(g===MAIN){ if(playing) g.angle += g.omega*dt; }
      else {
        if(g.meshed){ g.omega = -MAIN.omega * (MAIN.r / g.r) * g.throttle; if(playing) g.angle += g.omega*dt; }
        else { if(playing) g.angle += g.omega*dt*0.98; } // free
      }
      // wrap
      g.angle = mod(g.angle, TWO_PI);
      // haptics
      fireHaptics(g);
      // sync media (audio/video)
      syncMedia(g);
    }

    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function fireHaptics(g){
    // minor at 1/60th, major at 1/12th crossings
    const minorStep = Math.floor((g.angle/(TWO_PI)) * MINOR_DIV);
    const majorStep = Math.floor((g.angle/(TWO_PI)) * MAJOR_DIV);
    if(minorStep !== g.lastMinorStep){ g.lastMinorStep = minorStep; vibrate(haptics.minorMs); tone(880, 8, haptics.volMinor); }
    if(majorStep !== g.lastMajorStep){ g.lastMajorStep = majorStep; vibrate(haptics.majorMs); tone(440, 14, haptics.volMajor); }
  }

  // ====== Media sync & Stage resolve ======
  function seqWeights(g){
    let wsum = g.seq.reduce((a,s)=>a+(s.w||0),0); if(wsum<=0) wsum=1;
    // quantize if requested
    const qm = (g.quant!=='Off')?g.quant:quantMode;
    if(qm!=='Off'){
      const div = (qm==='60th')?60:12;
      // round each segment to nearest 1/div of full rotation
      const total = g.seq.length>0?g.seq.reduce((a,s)=>a+s.w,0):1;
      const scaled = g.seq.map(s=>s.w/total);
      let rounded = scaled.map(x=>Math.max(1/div, Math.round(x*div)/div));
      let sum = rounded.reduce((a,b)=>a+b,0);
      // normalize to 1
      rounded = rounded.map(x=>x/sum);
      return rounded;
    } else {
      return g.seq.map(s=> (s.w||0)/wsum );
    }
  }

  function currentSeg(g){
    const w = seqWeights(g);
    const p = g.angle/TWO_PI; // 0..1
    let acc=0;
    for(let i=0;i<g.seq.length;i++){
      const span = w[i];
      if(p >= acc && p < acc+span){
        const within = (p - acc)/span; // 0..1 within segment
        return {i, within, span};
      }
      acc += span;
    }
    // fallback last
    const i=g.seq.length-1; return {i, within:0, span:w[i]||1};
  }

  function syncMedia(g){
    const seg = currentSeg(g); const s = g.seq[seg.i];
    const gearDur = g.duration; const segDur = seg.span*gearDur; const localT = seg.within*segDur;
    const tMedia = (s.offset + localT*(s.stretch||1));
    if(s.type==='video' && s.media && s.media.readyState>=2){ try{ s.media.currentTime = tMedia % Math.max(0.001,(s.media.duration||1e6)); }catch(e){} }
    if(s.type==='audio' && s.media){ try{ s.media.currentTime = tMedia % Math.max(0.001,(s.media.duration||1e6)); s.media.volume = clamp(dbToGain(s.gain),0,1); if(playing && s.media.paused){ s.media.play().catch(()=>{}); } }catch(e){} }
  }

  function drawStage(){
    const sctx = stage.ctx; const {w,h} = stage.cv; sctx.save(); sctx.clearRect(0,0,w,h);
    const active = activeRoutedGear();
    if(active){
      const seg = currentSeg(active); const S = active.seq[seg.i];
      const gearDur=active.duration; const segDur=seg.span*gearDur; const localT = seg.within*segDur; const tMedia = (S.offset + localT*(S.stretch||1));
      const alphaEnv = (t)=>{ let a=1; if(S.fin>0) a*= clamp(t/S.fin,0,1); if(S.fout>0) a*= clamp((segDur - t)/S.fout,0,1); return a; };
      const alpha = clamp((S.opacity||1) * alphaEnv(localT), 0, 1);
      sctx.globalCompositeOperation = 'source-over';
      sctx.globalAlpha = alpha;
      sctx.fillStyle = '#000'; sctx.fillRect(0,0,w,h);

      if(S.type==='video' && S.media){ drawMediaCover(sctx,S.media,w,h); }
      else if(S.type==='img' && S.media){ drawMediaCover(sctx,S.media,w,h); }
      else if(S.type==='text' && S.lines){ drawTextBlock(sctx,S.lines,w,h); }
      else if(S.type==='audio'){ drawAudioPulse(sctx, tMedia, w,h); }

      // Per-segment blend could be applied if layering multiple, but here we render single active.
      sctx.globalAlpha = 1;
    } else {
      sctx.fillStyle = '#000'; sctx.fillRect(0,0,w,h);
    }
    sctx.restore();
  }

  function activeRoutedGear(){
    const routed = gears.filter(g=>g.routed);
    if(!routed.length) return MAIN;
    // choose smallest radius (fine control) as priority
    routed.sort((a,b)=>a.r-b.r);
    return routed[0];
  }

  function drawMediaCover(sctx, media, w, h){
    // draw image/video covering while preserving aspect
    const mw = media.videoWidth||media.naturalWidth||w; const mh = media.videoHeight||media.naturalHeight||h;
    if(!mw||!mh) return;
    const r = Math.max(w/mw, h/mh); const dw = Math.floor(mw*r), dh = Math.floor(mh*r);
    const dx = Math.floor((w - dw)/2), dy = Math.floor((h - dh)/2);
    sctx.drawImage(media, dx, dy, dw, dh);
  }
  function drawTextBlock(sctx, lines, w, h){
    sctx.fillStyle = '#0b0c10'; sctx.fillRect(0,0,w,h);
    sctx.fillStyle = '#eae7df'; sctx.textAlign='center'; sctx.textBaseline='middle';
    let size = Math.max(16, Math.floor(h*0.05)); sctx.font=`${size}px system-ui, sans-serif`;
    const y0 = h*0.35; const lh = size*1.2;
    lines.forEach((ln,i)=>{ sctx.fillText(ln, w/2, y0 + i*lh); });
  }
  function drawAudioPulse(sctx, t, w, h){
    sctx.fillStyle = '#0b0c10'; sctx.fillRect(0,0,w,h);
    const cx=w/2, cy=h/2; const R = Math.min(w,h)*0.3; const k = 0.5+0.5*Math.sin(t*6.283*0.5);
    sctx.beginPath(); sctx.arc(cx,cy, R*(0.8+k*0.2), 0, TWO_PI); sctx.fillStyle='#1aa7a1'; sctx.fill();
  }

  // ====== Draw main canvas ======
  function draw(){
    const W = canvas.width, H = canvas.height; ctx.save(); ctx.clearRect(0,0,W,H);

    // draw center stage first into offscreen, then composite
    drawStage();

    // background grid
    ctx.fillStyle = '#0b0c10'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#0f1319'; ctx.lineWidth = 1*DPR; for(let x=0;x<W;x+=32*DPR){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<H;y+=32*DPR){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

    // draw connection lines & gears
    const cx=W/2/DPR, cy=H/2/DPR;
    for(const g of gears){ if(g!==MAIN){
      const d = dist(g.x,g.y,cx,cy); const ideal = MAIN.r+g.r; const at = Math.abs(d-ideal)<0.5; // at tangency
      ctx.save(); ctx.translate(0,0);
      ctx.strokeStyle = at?'#19c37d':'#3a424e'; ctx.lineWidth = (at?2.5:1.5)*DPR; ctx.beginPath(); ctx.moveTo(cx*DPR,cy*DPR); ctx.lineTo(g.x*DPR,g.y*DPR); ctx.stroke(); ctx.restore();
    }}

    // draw gears
    for(const g of gears){ drawGear(g); }

    // draw Stage composited onto main
    ctx.save(); ctx.globalCompositeOperation = stage.mix; ctx.imageSmoothingEnabled = true;
    ctx.drawImage(stage.cv, stage.rect.x*DPR, stage.rect.y*DPR, stage.rect.w*DPR, stage.rect.h*DPR);
    ctx.restore();

    ctx.restore();
  }

  function drawGear(g){
    const X = g.x*DPR, Y = g.y*DPR; const r = g.r*DPR; ctx.save(); ctx.translate(X,Y); ctx.rotate(g.angle);

    // rim
    ctx.fillStyle = g===MAIN? '#0d141c' : '#0c1218';
    ctx.strokeStyle = '#1f2630'; ctx.lineWidth = 2*DPR; ctx.beginPath(); ctx.arc(0,0,r,0,TWO_PI); ctx.fill(); ctx.stroke();

    // teeth
    ctx.strokeStyle = '#2a323d'; ctx.lineWidth = 2*DPR; const teeth = g.teeth; const step = TWO_PI/teeth; for(let i=0;i<teeth;i++){
      ctx.beginPath(); ctx.moveTo(r,0); ctx.lineTo(r+8*DPR,0); ctx.stroke(); ctx.rotate(step);
    }

    // arcs (segments)
    if(showArcs){
      const w = seqWeights(g); let a0=0; for(let i=0;i<g.seq.length;i++){
        const a1 = a0 + w[i]*TWO_PI; ctx.beginPath(); ctx.strokeStyle = ['#00d0b4','#c8a552','#5aa9e6','#8a5cf6','#ff4d6d'][i%5];
        ctx.lineWidth = 8*DPR; ctx.arc(0,0,r-10*DPR, a0, a1); ctx.stroke(); a0=a1;
      }
    }

    // minor/major ticks
    ctx.save(); ctx.strokeStyle = '#2b313a'; for(let i=0;i<MAJOR_DIV;i++){
      ctx.beginPath(); ctx.moveTo(r-16*DPR,0); ctx.lineTo(r,0); ctx.stroke(); for(let j=1;j<MINOR_DIV/MAJOR_DIV;j++){
        ctx.rotate(TWO_PI/MINOR_DIV); ctx.beginPath(); ctx.moveTo(r-10*DPR,0); ctx.lineTo(r,0); ctx.stroke();
      } ctx.rotate(TWO_PI/MINOR_DIV); }
    ctx.restore();

    // label & selection
    ctx.rotate(-g.angle); ctx.fillStyle = '#cfd3d8'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${Math.max(12, Math.floor(12*DPR))}px system-ui`;
    ctx.fillText(g===MAIN? 'MAIN' : (g.label||'GEAR'), 0, 0);
    if(selectedId===g.id){ ctx.beginPath(); ctx.strokeStyle = '#19c37d'; ctx.lineWidth=2*DPR; ctx.arc(0,0,r+10*DPR,0,TWO_PI); ctx.stroke(); }

    ctx.restore();
  }

  // ====== Recording ======
  function startRecording(){
    try{
      const fps = 30; const target = (outputMode==='Canvas')?canvas:stage.cv; const stream = target.captureStream(fps);
      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')?'video/webm;codecs=vp9':'video/webm;codecs=vp8';
      const recoder = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 6_000_000});
      recoder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) rec.chunks.push(e.data); };
      recoder.onstop = ()=>{
        const blob = new Blob(rec.chunks, {type: mime});
        const url = URL.createObjectURL(blob);
        hud.dl.href = url; const ts = new Date().toISOString().replace(/[:.]/g,'-');
        hud.dl.download = `gear-film-${outputMode.toLowerCase()}-${ts}.webm`;
        hud.dl.style.display='inline-block';
        hud.record.textContent='● Record';
        rec.recorder=null; rec.chunks=[]; rec.stream=null;
      };
      rec.chunks=[]; rec.recorder=recoder; rec.stream=stream; recoder.start();
      hud.record.textContent='■ Stop'; hud.dl.style.display='none';
    }catch(err){ alert('MediaRecorder unsupported in this browser.'); }
  }
  function stopRecording(){ if(rec.recorder){ rec.recorder.stop(); rec.stream?.getTracks().forEach(t=>t.stop()); } }

  // ====== Keyboard ======
  window.addEventListener('keydown',(e)=>{
    if(e.key===' '){ e.preventDefault(); playing=!playing; hud.playPause.textContent = playing?'Pause':'Play'; }
    if(e.key==='['){ driveIndex = (driveIndex-1+gears.length)%gears.length; select(gears[driveIndex].id); }
    if(e.key===']'){ driveIndex = (driveIndex+1)%gears.length; select(gears[driveIndex].id); }
    if(e.key==='\'){ /* AutoShift placeholder */ }
    if(e.key==='O' || e.key==='o'){ outputMode = outputMode==='Normal'?'Canvas':'Normal'; updateToolbar(); }
    if(e.key==='P' || e.key==='p'){ if(!inspectorEl.classList.contains('open')) renderInspector(); else inspectorEl.classList.remove('open'); }
    if(e.key==='Escape'){ inspectorEl.classList.remove('open'); settingsEl.classList.remove('open'); }
  });

  // Close panels on outside click
  document.addEventListener('click',(e)=>{
    if(inspectorEl.classList.contains('open') && !inspectorEl.contains(e.target) && e.target!==canvas){ inspectorEl.classList.remove('open'); }
    if(settingsEl.classList.contains('open') && !settingsEl.contains(e.target) && e.target!==hud.settingsBtn){ settingsEl.classList.remove('open'); }
  });

  // ====== Init ======
  // Center MAIN gear
  MAIN.x = canvas.width/(2*DPR); MAIN.y = canvas.height/(2*DPR); MAIN.meshed=false;
  select(MAIN.id);
})();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Main Gear Film Engine — Single-File POC</title>
<style>
  :root{
    --bg:#0b0c10;--ink:#eae7df;--muted:#9aa0a6;--accent:#00d0b4;--gold:#c8a552;--rose:#ff4d6d;--ok:#19c37d;--warn:#e6b800;--bad:#ff4d4f;
    --rim:#161a20;--tick:#252c33;--panel:#0f1319f2;--glass:#0b0f14cc;--btn:#131922;--btnb:#29303a;--blue:#5aa9e6;--purple:#8a5cf6;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #c{position:fixed;inset:0;display:block}
  /* Top toolbar */
  #toolbar{position:fixed;top:8px;left:8px;right:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;z-index:5}
  .badge{background:var(--glass);border:1px solid #1e2530;border-radius:999px;padding:6px 10px;font-size:12px;line-height:1;user-select:none}
  .badge .k{opacity:.7;margin-right:6px}
  .badge.toggle{cursor:pointer}
  .dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px;background:#5a616c}
  /* Bottom HUD */
  #hud{position:fixed;left:0;right:0;bottom:8px;display:flex;justify-content:center;gap:8px;z-index:6}
  button,input[type=file]::file-selector-button{font:600 12px/1 system-ui;border-radius:12px;border:1px solid var(--btnb);background:var(--btn);color:var(--ink);padding:10px 12px;cursor:pointer}
  button.icon{width:40px;height:40px;border-radius:50%}
  button.primary{border-color:#1d3c35;background:#0e2724}
  button.rec{background:#2d1212;border-color:#5a1f1f;color:#ff9a9a}
  a#dl{display:none;margin-left:8px;text-decoration:none}
  /* Panels */
  .panel{position:fixed;right:12px;top:56px;bottom:56px;width:min(420px,92vw);background:var(--panel);border:1px solid #1e2530;border-radius:16px;box-shadow:0 20px 50px #0008;overflow:auto;padding:14px 14px 90px;z-index:10;display:none}
  .panel.open{display:block}
  .panel h3{margin:6px 0 8px;font-size:14px;color:#cfd3d8}
  .row{display:flex;align-items:center;gap:8px;margin:6px 0}
  .row label{flex:0 0 120px;font-size:12px;color:#c0c6cf}
  .row input[type=range]{flex:1}
  .seg{border:1px solid #28303a;border-radius:10px;padding:8px;margin:8px 0;background:#0c1218}
  .seg .row label{flex-basis:90px}
  .seg header{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:#bac2cc;margin-bottom:6px}
  .seg header .ops button{margin-left:6px}
  .pill{display:inline-block;padding:3px 8px;border:1px solid #2a313b;border-radius:999px;font-size:11px;color:#c9d0d9}
  .kbd{font-family:ui-monospace,Consolas,monospace;background:#10161f;border:1px solid #26303c;border-radius:6px;padding:2px 6px}
  .ghost{opacity:.65}
  .hint{opacity:.8;font-size:12px;margin:8px 0 0}
</style>
</head>
<body>
  <!-- Top toolbar badges -->
  <div id="toolbar">
    <div class="badge" id="driveBadge"><span class="k">Drive:</span><span id="driveVal">MAIN</span></div>
    <div class="badge toggle" id="bpmBadge"><span class="k">BPM:</span><span id="bpmVal">Free</span></div>
    <div class="badge toggle" id="quantBadge"><span class="k">Quant:</span><span id="quantVal">Off</span></div>
    <div class="badge toggle" id="mixBadge"><span class="k">Mix:</span><span id="mixVal">source-over</span></div>
    <div class="badge toggle" id="outBadge"><span class="k">Output:</span><span id="outVal">Normal</span></div>
    <div class="badge toggle" id="arcsBadge"><span class="k">ARCS</span><span id="arcsVal">on</span></div>
  </div>

  <!-- Main canvas -->
  <canvas id="c"></canvas>

  <!-- Bottom HUD -->
  <div id="hud">
    <label class="badge">
      Add Video
      <input id="addVideo" type="file" accept="video/*" multiple style="display:none" />
    </label>
    <label class="badge">
      Add Image
      <input id="addImage" type="file" accept="image/*" multiple style="display:none" />
    </label>
    <label class="badge">
      Add Audio
      <input id="addAudio" type="file" accept="audio/*" multiple style="display:none" />
    </label>
    <button id="addText">Add Text</button>
    <button id="playPause" class="primary">Play</button>
    <button id="hapticT" title="Haptics on/off">HAPTIC</button>
    <button id="route">Route</button>
    <button id="record" class="rec">● Record</button>
    <a id="dl" download>Download</a>
    <button id="settingsBtn">Settings: Center Ring</button>
  </div>

  <!-- Inspector Panel -->
  <aside id="inspector" class="panel" aria-label="Inspector" tabindex="-1"></aside>
  <!-- Settings Panel -->
  <aside id="settings" class="panel" aria-label="Settings" tabindex="-1"></aside>

<script>
(() => {
  // ====== Constants ======
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  const TOOTH_PITCH = 16; // px between teeth along circumference
  const PX_PER_SEC = 5;   // radius scaling: r = k * duration
  const TWO_PI = Math.PI * 2;
  const MINOR_DIV = 60; // 1/60th
  const MAJOR_DIV = 12; // 1/12th
  const STAGE_SCALE = 0.62; // of viewport, fit 16:9
  const GHOST_ALPHA = 0.25;

  // ====== State ======
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const toolbar = {
    drive: document.getElementById('driveVal'),
    bpmBadge: document.getElementById('bpmBadge'),
    bpmVal: document.getElementById('bpmVal'),
    quantBadge: document.getElementById('quantBadge'),
    quantVal: document.getElementById('quantVal'),
    mixBadge: document.getElementById('mixBadge'),
    mixVal: document.getElementById('mixVal'),
    outBadge: document.getElementById('outBadge'),
    outVal: document.getElementById('outVal'),
    arcsBadge: document.getElementById('arcsBadge'),
    arcsVal: document.getElementById('arcsVal'),
  };
  const hud = {
    addVideo: document.getElementById('addVideo'),
    addImage: document.getElementById('addImage'),
    addAudio: document.getElementById('addAudio'),
    addText: document.getElementById('addText'),
    playPause: document.getElementById('playPause'),
    hapticT: document.getElementById('hapticT'),
    route: document.getElementById('route'),
    record: document.getElementById('record'),
    dl: document.getElementById('dl'),
    settingsBtn: document.getElementById('settingsBtn'),
  };
  const inspectorEl = document.getElementById('inspector');
  const settingsEl = document.getElementById('settings');

  const stage = {
    cv: document.createElement('canvas'),
    ctx: null,
    rect: {x:0,y:0,w:0,h:0},
    mix: 'source-over'
  };
  stage.ctx = stage.cv.getContext('2d', { alpha: true, desynchronized: true });

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let sfxGain = audioCtx.createGain(); sfxGain.gain.value = 0.3; sfxGain.connect(audioCtx.destination);

  const haptics = {
    on: true,
    bpm: null,
    minorMs: 8,
    majorMs: 16,
    perfectPattern: [12,24,12],
    volMinor: 0.08,
    volMajor: 0.12,
    volPerfect: 0.2,
  };

  let gears = [];
  let selectedId = null; // for inspector & route
  let driveIndex = 0; // index in gears for drive, MAIN=0
  let playing = true;
  let showArcs = true;
  let outputMode = 'Normal'; // or 'Canvas'
  let quantMode = 'Off'; // Off|60th|12th
  let rec = {recorder:null, chunks:[], stream:null, target:'stage'};

  // ====== Utilities ======
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const mod = (n,m)=>((n % m) + m) % m;
  const now = ()=>performance.now();
  const dist = (x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
  function id(){return 'g'+Math.random().toString(36).slice(2,8)}

  function secToRadius(sec){return Math.max(30, sec*PX_PER_SEC)}
  function radiusToSec(r){return r/PX_PER_SEC}
  function teethForR(r){return Math.max(6, Math.round((TWO_PI*r)/TOOTH_PITCH))}

  function dbToGain(db){return Math.pow(10, db/20)}

  // SFX blip
  function tone(freq=440, ms=20, vol=0.1){
    try{
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = vol; o.frequency.value = freq;
      o.connect(g); g.connect(sfxGain);
      o.start(); g.gain.setValueAtTime(vol, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + ms/1000);
      o.stop(audioCtx.currentTime + ms/1000);
    }catch(e){}
  }
  function vibrate(pattern){ if(haptics.on && navigator.vibrate) navigator.vibrate(pattern); }

  // ====== Stage sizing ======
  function sizeAll(){
    const w = Math.floor(window.innerWidth * DPR);
    const h = Math.floor(window.innerHeight * DPR);
    canvas.width = w; canvas.height = h; canvas.style.width = window.innerWidth+'px'; canvas.style.height = window.innerHeight+'px';
    // Stage rect centered, 62% of viewport fit to 16:9
    const vw = window.innerWidth, vh = window.innerHeight;
    let targetW = vw * STAGE_SCALE, targetH = targetW * 9/16;
    if(targetH > vh*STAGE_SCALE){ targetH = vh*STAGE_SCALE; targetW = targetH * 16/9; }
    stage.rect.w = Math.floor(targetW); stage.rect.h = Math.floor(targetH);
    stage.rect.x = Math.floor((vw - targetW)/2); stage.rect.y = Math.floor((vh - targetH)/2);
    stage.cv.width = Math.floor(stage.rect.w * DPR); stage.cv.height = Math.floor(stage.rect.h * DPR);
  }
  sizeAll();
  new ResizeObserver(sizeAll).observe(document.body);

  // ====== Gear model ======
  function makeGear({kind='group', label='GEAR', duration=8, x, y, routed=false, throttle=1, ease='linear', seq=[]}={}){
    const r = secToRadius(duration);
    const g = {
      id: id(), x: x??(canvas.width/(2*DPR)), y: y??(canvas.height/(2*DPR)), r,
      teeth: teethForR(r), angle: 0, omega: 0,
      duration, label, kind, routed, throttle, ease,
      seq: ensureSeq(seq), eligible: true, meshed: false, quant:'Off',
      lastMinorStep:0, lastMajorStep:0,
    };
    return g;
  }

  function ensureSeq(seq){
    if(!seq || !seq.length) return [{type:'placeholder',label:'Empty',w:1,offset:0,stretch:1,opacity:1,gain:0,fin:0,fout:0,blend:'source-over'}];
    // normalize: ensure keys
    return seq.map(s=>({
      type:s.type||'placeholder', label:s.label||s.type||'seg',
      w:(s.w??1), offset:(s.offset??0), stretch:(s.stretch??1), opacity:(s.opacity??1),
      gain:(s.gain??0), fin:(s.fin??0), fout:(s.fout??0), blend:(s.blend||'source-over'), lines:s.lines, media:s.media
    }));
  }

  // MAIN gear
  const MAIN = makeGear({label:'MAIN', duration:12, routed:true});
  MAIN.kind='group';
  gears.push(MAIN);

  // ====== Input: add media/text ======
  hud.addVideo.addEventListener('change', e=>handleFiles(e.target.files,'video'));
  hud.addImage.addEventListener('change', e=>handleFiles(e.target.files,'img'));
  hud.addAudio.addEventListener('change', e=>handleFiles(e.target.files,'audio'));
  hud.addText.addEventListener('click', ()=>{
    const t = prompt('Enter text (
 makes new line)');
    if(!t) return;
    const lines = t.split(/
+/).map(s=>s.trim()).filter(Boolean);
    const g = makeGear({kind:'text', label:'TEXT', duration: Math.max(4, lines.length*2), routed:false});
    g.seq = [{type:'text', label:'Text', w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.2, fout:.2, blend:'source-over', lines}];
    placeOuter(g);
    gears.push(g);
    select(g.id);
  });

  function handleFiles(files, kind){
    [...files].forEach(file=>{
      const url = URL.createObjectURL(file);
      if(kind==='video'){
        const v = document.createElement('video');
        v.src=url; v.loop=true; v.muted=true; v.playsInline=true; v.preload='auto';
        v.addEventListener('loadedmetadata',()=>{ v.currentTime=0; });
        const g = makeGear({kind:'video', label:file.name, duration: Math.max(6, Math.min(24, (v.duration||8))), routed:false});
        g.seq = [{type:'video', label:file.name, w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.15, fout:.15, blend:'source-over', media:v}];
        placeOuter(g); gears.push(g); select(g.id);
      } else if(kind==='img'){
        const im = new Image(); im.src=url;
        const g = makeGear({kind:'img', label:file.name, duration:8, routed:false});
        g.seq = [{type:'img', label:file.name, w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.15, fout:.15, blend:'source-over', media:im}];
        placeOuter(g); gears.push(g); select(g.id);
      } else if(kind==='audio'){
        const a = document.createElement('audio');
        a.src=url; a.loop=true; a.preload='auto'; a.crossOrigin='anonymous';
        a.addEventListener('loadedmetadata',()=>{ a.currentTime=0; });
        const g = makeGear({kind:'audio', label:file.name, duration:12, routed:false});
        g.seq = [{type:'audio', label:file.name, w:1, offset:0, stretch:1, opacity:1, gain:0, fin:.15, fout:.15, blend:'source-over', media:a}];
        placeOuter(g); gears.push(g); select(g.id);
      }
    });
    // reset so same file can be re-added
    hud.addVideo.value=''; hud.addImage.value=''; hud.addAudio.value='';
  }

  function placeOuter(g){
    // place roughly on rim at random angle
    const ang = Math.random()*TWO_PI;
    const cx = canvas.width/(2*DPR), cy = canvas.height/(2*DPR);
    const R = MAIN.r + g.r + 6; // small gap before snap
    g.x = cx + Math.cos(ang)*R; g.y = cy + Math.sin(ang)*R;
  }

  // ====== Selection & inspector ======
  function select(id){ selectedId=id; renderInspector(); updateToolbar(); }
  function selected(){ return gears.find(g=>g.id===selectedId) || MAIN }

  function renderInspector(){
    const g = selected();
    const qOpts = ['Off','60th','12th'];
    const easeOpts = ['linear','ease-in','ease-out','ease-in-out'];
    const blends = ['source-over','multiply','screen','overlay','lighten'];
    inspectorEl.innerHTML = `
      <h3>Inspector — <span class="pill">${g.label}</span> <span class="ghost">#${g.id}</span></h3>
      <div class="row"><label>Duration (s)</label><input id="dur" type="range" min="2" max="60" step="1" value="${g.duration}"><span class="pill">${g.duration}</span></div>
      <div class="row"><label>Ease</label>
        <select id="ease">${easeOpts.map(o=>`<option ${o===g.ease?'selected':''}>${o}</option>`).join('')}</select>
      </div>
      <div class="row"><label>Route to Stage</label><input id="routeChk" type="checkbox" ${g.routed?'checked':''}></div>
      <div class="row"><label>Drive throttle</label><input id="throttle" type="range" min="0" max="2" step="0.01" value="${g.throttle}"><span class="pill">${g.throttle.toFixed(2)}</span></div>
      <div class="row"><label>Quantize arcs</label>
        <select id="quantSel">${qOpts.map(o=>`<option ${o===g.quant?'selected':''}>${o}</option>`).join('')}</select>
      </div>
      <h3>Segments</h3>
      ${g.seq.map((s,idx)=>`<div class="seg" data-i="${idx}">
        <header><span>${idx+1}. ${s.label} <span class="ghost">(${s.type})</span></span>
          <span class="ops">
            <button class="del">Delete</button>
            <button class="up">↑</button>
            <button class="down">↓</button>
          </span>
        </header>
        <div class="row"><label>w (weight)</label><input class="w" type="range" min="0.01" max="1" step="0.01" value="${s.w}"><span class="pill">${s.w.toFixed(2)}</span></div>
        <div class="row"><label>offset (s)</label><input class="offset" type="number" step="0.01" value="${s.offset}"></div>
        <div class="row"><label>stretch</label><input class="stretch" type="number" step="0.01" value="${s.stretch}"></div>
        <div class="row"><label>opacity</label><input class="opacity" type="range" min="0" max="1" step="0.01" value="${s.opacity}"><span class="pill">${Math.round(s.opacity*100)}%</span></div>
        <div class="row"><label>gain (dB)</label><input class="gain" type="number" step="0.5" value="${s.gain}"></div>
        <div class="row"><label>fade in (s)</label><input class="fin" type="number" step="0.01" value="${s.fin}"></div>
        <div class="row"><label>fade out (s)</label><input class="fout" type="number" step="0.01" value="${s.fout}"></div>
        <div class="row"><label>blend</label>
          <select class="blend">${blends.map(b=>`<option ${b===s.blend?'selected':''}>${b}</option>`).join('')}</select>
        </div>
      </div>`).join('')}
      <div class="row">
        <button id="addTextSeg">+Text</button>
        <span class="hint">Weights are normalized to 1. Quant rounds to ${quantMode==='60th'?'1/60th':quantMode==='12th'?'1/12th':'off'}.</span>
      </div>
    `;
    inspectorEl.classList.add('open');
  }

  inspectorEl.addEventListener('input', (e)=>{
    const g = selected();
    if(e.target.id==='dur'){
      g.duration = parseFloat(e.target.value);
      g.r = secToRadius(g.duration); g.teeth = teethForR(g.r);
    }
    if(e.target.id==='ease'){ g.ease = e.target.value; }
    if(e.target.id==='routeChk'){ g.routed = e.target.checked; }
    if(e.target.id==='throttle'){ g.throttle = parseFloat(e.target.value); }
    if(e.target.id==='quantSel'){ g.quant = e.target.value; }
    const segEl = e.target.closest('.seg');
    if(segEl){
      const i = +segEl.dataset.i; const s = g.seq[i];
      if(e.target.classList.contains('w')) s.w = parseFloat(e.target.value);
      if(e.target.classList.contains('offset')) s.offset = parseFloat(e.target.value);
      if(e.target.classList.contains('stretch')) s.stretch = parseFloat(e.target.value);
      if(e.target.classList.contains('opacity')) s.opacity = parseFloat(e.target.value);
      if(e.target.classList.contains('gain')) s.gain = parseFloat(e.target.value);
      if(e.target.classList.contains('fin')) s.fin = parseFloat(e.target.value);
      if(e.target.classList.contains('fout')) s.fout = parseFloat(e.target.value);
      if(e.target.classList.contains('blend')) s.blend = e.target.value;
    }
  });
  inspectorEl.addEventListener('click',(e)=>{
    const g = selected();
    if(e.target.id==='addTextSeg'){
      const t = prompt('Text lines (
 separated)'); if(!t) return;
      const seg = {type:'text', label:'Text', lines:t.split(/
+/), w:.5, offset:0, stretch:1, opacity:1, gain:0, fin:.1, fout:.1, blend:'source-over'};
      g.seq.push(seg); renderInspector();
    }
    const segEl = e.target.closest('.seg'); if(!segEl) return;
    const i = +segEl.dataset.i;
    if(e.target.classList.contains('del')){ g.seq.splice(i,1); renderInspector(); }
    if(e.target.classList.contains('up')){ if(i>0){ [g.seq[i-1],g.seq[i]]=[g.seq[i],g.seq[i-1]]; renderInspector(); } }
    if(e.target.classList.contains('down')){ if(i<g.seq.length-1){ [g.seq[i+1],g.seq[i]]=[g.seq[i],g.seq[i+1]]; renderInspector(); } }
  });

  // Settings Panel (Center Ring / Haptics)
  function renderSettings(){
    settingsEl.innerHTML = `
      <h3>Center Ring — Haptics & Tempo</h3>
      <div class="row"><label>BPM (empty = Free)</label><input id="bpmInput" type="number" step="1" min="1" value="${haptics.bpm??''}"></div>
      <div class="row"><label>Minor vib (ms)</label><input id="vMinor" type="number" value="${haptics.minorMs}"></div>
      <div class="row"><label>Major vib (ms)</label><input id="vMajor" type="number" value="${haptics.majorMs}"></div>
      <div class="row"><label>Perfect pattern</label><input id="vPerfect" type="text" value="${haptics.perfectPattern.join(',')}"></div>
      <div class="row"><label>Vol minor</label><input id="volMinor" type="number" step="0.01" value="${haptics.volMinor}"></div>
      <div class="row"><label>Vol major</label><input id="volMajor" type="number" step="0.01" value="${haptics.volMajor}"></div>
      <div class="row"><label>Vol perfect</label><input id="volPerfect" type="number" step="0.01" value="${haptics.volPerfect}"></div>
      <p class="hint">ESC or click outside to close.</p>
    `;
    settingsEl.classList.add('open');
  }
  settingsEl.addEventListener('input',(e)=>{
    if(e.target.id==='bpmInput'){ const val=e.target.value.trim(); haptics.bpm = val===''?null:parseFloat(val)||null; }
    if(e.target.id==='vMinor') haptics.minorMs = parseInt(e.target.value)||8;
    if(e.target.id==='vMajor') haptics.majorMs = parseInt(e.target.value)||16;
    if(e.target.id==='vPerfect') haptics.perfectPattern = e.target.value.split(',').map(s=>parseInt(s)||0).filter(Boolean);
    if(e.target.id==='volMinor') haptics.volMinor = parseFloat(e.target.value)||0.08;
    if(e.target.id==='volMajor') haptics.volMajor = parseFloat(e.target.value)||0.12;
    if(e.target.id==='volPerfect') haptics.volPerfect = parseFloat(e.target.value)||0.2;
  });

  // ====== Toolbar/HUD interactions ======
  toolbar.bpmBadge.addEventListener('click', ()=>{
    const inp = prompt('BPM (empty for Free)', haptics.bpm??'');
    haptics.bpm = (inp===''||inp===null)?null:parseFloat(inp)||null;
    updateToolbar();
  });
  const quantModes = ['Off','60th','12th'];
  toolbar.quantBadge.addEventListener('click', ()=>{
    const i = (quantModes.indexOf(quantMode)+1)%quantModes.length; quantMode = quantModes[i]; updateToolbar();
  });
  const mixes = ['source-over','screen','multiply','overlay','lighten'];
  toolbar.mixBadge.addEventListener('click', ()=>{
    const i = (mixes.indexOf(stage.mix)+1)%mixes.length; stage.mix = mixes[i]; updateToolbar();
  });
  toolbar.outBadge.addEventListener('click', ()=>{
    outputMode = outputMode==='Normal'?'Canvas':'Normal'; updateToolbar();
  });
  toolbar.arcsBadge.addEventListener('click', ()=>{ showArcs=!showArcs; updateToolbar(); });

  hud.playPause.addEventListener('click', ()=>{ playing=!playing; hud.playPause.textContent = playing?'Pause':'Play'; });
  hud.hapticT.addEventListener('click', ()=>{ haptics.on=!haptics.on; hud.hapticT.classList.toggle('primary', haptics.on); });
  hud.route.addEventListener('click', ()=>{ const g=selected(); if(g){ g.routed=!g.routed; renderInspector(); }});
  hud.settingsBtn.addEventListener('click', renderSettings);

  // Recording
  hud.record.addEventListener('click', ()=>{
    if(rec.recorder){ stopRecording(); } else { startRecording(); }
  });

  function updateToolbar(){
    toolbar.drive.textContent = selected().label || 'MAIN';
    toolbar.bpmVal.textContent = haptics.bpm?String(haptics.bpm):'Free';
    toolbar.quantVal.textContent = quantMode;
    toolbar.mixVal.textContent = stage.mix;
    toolbar.outVal.textContent = outputMode;
    toolbar.arcsVal.textContent = showArcs?'on':'off';
  }
  updateToolbar();

  // ====== Pointer interactions (drag / rotate / snap) ======
  let pointer = {down:false, id:null, x:0,y:0, lastA:0, mode:null}; // mode: 'move'|'rotate'

  canvas.addEventListener('pointerdown', (e)=>{
    audioCtx.resume?.();
    const x = e.clientX, y = e.clientY; pointer.down=true; pointer.id=e.pointerId; pointer.x=x; pointer.y=y;
    // select nearest gear within radius
    const g = pickGear(x,y);
    if(g){ select(g.id); const dx=x-g.x, dy=y-g.y; const d=Math.hypot(dx,dy);
      pointer.mode = (d>g.r*0.7)?'rotate':'move';
      pointer.lastA = Math.atan2(dy,dx);
    } else { pointer.mode=null; selectedId = MAIN.id; }
  });
  window.addEventListener('pointermove', (e)=>{
    if(!pointer.down) return; const g = selected(); if(!g) return; const x=e.clientX, y=e.clientY; const dx=x-g.x, dy=y-g.y; const ang = Math.atan2(dy,dx);
    if(pointer.mode==='move'){
      g.x = x; g.y = y; // snap check
      const cx=canvas.width/(2*DPR), cy=canvas.height/(2*DPR);
      const d = dist(g.x,g.y,cx,cy);
      const ideal = MAIN.r + g.r;
      if(Math.abs(d-ideal) < 12){
        // snap to tangency
        const a = Math.atan2(g.y-cy, g.x-cx);
        g.x = cx + Math.cos(a)*ideal;
        g.y = cy + Math.sin(a)*ideal;
        if(!g.meshed){ perfectHaptic(); g.meshed=true; }
      } else { g.meshed=false; }
    } else if(pointer.mode==='rotate'){
      const delta = ang - pointer.lastA; g.angle += delta; pointer.lastA = ang;
    }
  });
  window.addEventListener('pointerup', ()=>{ pointer.down=false; pointer.mode=null; });

  function pickGear(x,y){
    let best=null, bestD=1e9; for(const g of gears){ const d = Math.hypot(x-g.x, y-g.y); if(d < g.r+20 && d<bestD){ best=g; bestD=d; } }
    return best;
  }

  function perfectHaptic(){ vibrate(haptics.perfectPattern); tone(220,50,haptics.volPerfect); tone(110,70,haptics.volPerfect*0.7); }

  // ====== Playback clock ======
  let lastT = now();
  function step(){
    const t = now();
    const dt = Math.min(50, t-lastT)/1000; // seconds
    lastT = t;

    // compute MAIN omega
    if(haptics.bpm){ MAIN.omega = TWO_PI / ((60/haptics.bpm)*4); } else { MAIN.omega = TWO_PI / MAIN.duration; }

    // advance angles
    for(let i=0;i<gears.length;i++){
      const g = gears[i];
      // coupling
      if(g===MAIN){ if(playing) g.angle += g.omega*dt; }
      else {
        if(g.meshed){ g.omega = -MAIN.omega * (MAIN.r / g.r) * g.throttle; if(playing) g.angle += g.omega*dt; }
        else { if(playing) g.angle += g.omega*dt*0.98; } // free
      }
      // wrap
      g.angle = mod(g.angle, TWO_PI);
      // haptics
      fireHaptics(g);
      // sync media (audio/video)
      syncMedia(g);
    }

    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function fireHaptics(g){
    // minor at 1/60th, major at 1/12th crossings
    const minorStep = Math.floor((g.angle/(TWO_PI)) * MINOR_DIV);
    const majorStep = Math.floor((g.angle/(TWO_PI)) * MAJOR_DIV);
    if(minorStep !== g.lastMinorStep){ g.lastMinorStep = minorStep; vibrate(haptics.minorMs); tone(880, 8, haptics.volMinor); }
    if(majorStep !== g.lastMajorStep){ g.lastMajorStep = majorStep; vibrate(haptics.majorMs); tone(440, 14, haptics.volMajor); }
  }

  // ====== Media sync & Stage resolve ======
  function seqWeights(g){
    let wsum = g.seq.reduce((a,s)=>a+(s.w||0),0); if(wsum<=0) wsum=1;
    // quantize if requested
    const qm = (g.quant!=='Off')?g.quant:quantMode;
    if(qm!=='Off'){
      const div = (qm==='60th')?60:12;
      // round each segment to nearest 1/div of full rotation
      const total = g.seq.length>0?g.seq.reduce((a,s)=>a+s.w,0):1;
      const scaled = g.seq.map(s=>s.w/total);
      let rounded = scaled.map(x=>Math.max(1/div, Math.round(x*div)/div));
      let sum = rounded.reduce((a,b)=>a+b,0);
      // normalize to 1
      rounded = rounded.map(x=>x/sum);
      return rounded;
    } else {
      return g.seq.map(s=> (s.w||0)/wsum );
    }
  }

  function currentSeg(g){
    const w = seqWeights(g);
    const p = g.angle/TWO_PI; // 0..1
    let acc=0;
    for(let i=0;i<g.seq.length;i++){
      const span = w[i];
      if(p >= acc && p < acc+span){
        const within = (p - acc)/span; // 0..1 within segment
        return {i, within, span};
      }
      acc += span;
    }
    // fallback last
    const i=g.seq.length-1; return {i, within:0, span:w[i]||1};
  }

  function syncMedia(g){
    const seg = currentSeg(g); const s = g.seq[seg.i];
    const gearDur = g.duration; const segDur = seg.span*gearDur; const localT = seg.within*segDur;
    const tMedia = (s.offset + localT*(s.stretch||1));
    if(s.type==='video' && s.media && s.media.readyState>=2){ try{ s.media.currentTime = tMedia % Math.max(0.001,(s.media.duration||1e6)); }catch(e){} }
    if(s.type==='audio' && s.media){ try{ s.media.currentTime = tMedia % Math.max(0.001,(s.media.duration||1e6)); s.media.volume = clamp(dbToGain(s.gain),0,1); if(playing && s.media.paused){ s.media.play().catch(()=>{}); } }catch(e){} }
  }

  function drawStage(){
    const sctx = stage.ctx; const {w,h} = stage.cv; sctx.save(); sctx.clearRect(0,0,w,h);
    const active = activeRoutedGear();
    if(active){
      const seg = currentSeg(active); const S = active.seq[seg.i];
      const gearDur=active.duration; const segDur=seg.span*gearDur; const localT = seg.within*segDur; const tMedia = (S.offset + localT*(S.stretch||1));
      const alphaEnv = (t)=>{ let a=1; if(S.fin>0) a*= clamp(t/S.fin,0,1); if(S.fout>0) a*= clamp((segDur - t)/S.fout,0,1); return a; };
      const alpha = clamp((S.opacity||1) * alphaEnv(localT), 0, 1);
      sctx.globalCompositeOperation = 'source-over';
      sctx.globalAlpha = alpha;
      sctx.fillStyle = '#000'; sctx.fillRect(0,0,w,h);

      if(S.type==='video' && S.media){ drawMediaCover(sctx,S.media,w,h); }
      else if(S.type==='img' && S.media){ drawMediaCover(sctx,S.media,w,h); }
      else if(S.type==='text' && S.lines){ drawTextBlock(sctx,S.lines,w,h); }
      else if(S.type==='audio'){ drawAudioPulse(sctx, tMedia, w,h); }

      // Per-segment blend could be applied if layering multiple, but here we render single active.
      sctx.globalAlpha = 1;
    } else {
      sctx.fillStyle = '#000'; sctx.fillRect(0,0,w,h);
    }
    sctx.restore();
  }

  function activeRoutedGear(){
    const routed = gears.filter(g=>g.routed);
    if(!routed.length) return MAIN;
    // choose smallest radius (fine control) as priority
    routed.sort((a,b)=>a.r-b.r);
    return routed[0];
  }

  function drawMediaCover(sctx, media, w, h){
    // draw image/video covering while preserving aspect
    const mw = media.videoWidth||media.naturalWidth||w; const mh = media.videoHeight||media.naturalHeight||h;
    if(!mw||!mh) return;
    const r = Math.max(w/mw, h/mh); const dw = Math.floor(mw*r), dh = Math.floor(mh*r);
    const dx = Math.floor((w - dw)/2), dy = Math.floor((h - dh)/2);
    sctx.drawImage(media, dx, dy, dw, dh);
  }
  function drawTextBlock(sctx, lines, w, h){
    sctx.fillStyle = '#0b0c10'; sctx.fillRect(0,0,w,h);
    sctx.fillStyle = '#eae7df'; sctx.textAlign='center'; sctx.textBaseline='middle';
    let size = Math.max(16, Math.floor(h*0.05)); sctx.font=`${size}px system-ui, sans-serif`;
    const y0 = h*0.35; const lh = size*1.2;
    lines.forEach((ln,i)=>{ sctx.fillText(ln, w/2, y0 + i*lh); });
  }
  function drawAudioPulse(sctx, t, w, h){
    sctx.fillStyle = '#0b0c10'; sctx.fillRect(0,0,w,h);
    const cx=w/2, cy=h/2; const R = Math.min(w,h)*0.3; const k = 0.5+0.5*Math.sin(t*6.283*0.5);
    sctx.beginPath(); sctx.arc(cx,cy, R*(0.8+k*0.2), 0, TWO_PI); sctx.fillStyle='#1aa7a1'; sctx.fill();
  }

  // ====== Draw main canvas ======
  function draw(){
    const W = canvas.width, H = canvas.height; ctx.save(); ctx.clearRect(0,0,W,H);

    // draw center stage first into offscreen, then composite
    drawStage();

    // background grid
    ctx.fillStyle = '#0b0c10'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#0f1319'; ctx.lineWidth = 1*DPR; for(let x=0;x<W;x+=32*DPR){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<H;y+=32*DPR){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

    // draw connection lines & gears
    const cx=W/2/DPR, cy=H/2/DPR;
    for(const g of gears){ if(g!==MAIN){
      const d = dist(g.x,g.y,cx,cy); const ideal = MAIN.r+g.r; const at = Math.abs(d-ideal)<0.5; // at tangency
      ctx.save(); ctx.translate(0,0);
      ctx.strokeStyle = at?'#19c37d':'#3a424e'; ctx.lineWidth = (at?2.5:1.5)*DPR; ctx.beginPath(); ctx.moveTo(cx*DPR,cy*DPR); ctx.lineTo(g.x*DPR,g.y*DPR); ctx.stroke(); ctx.restore();
    }}

    // draw gears
    for(const g of gears){ drawGear(g); }

    // draw Stage composited onto main
    ctx.save(); ctx.globalCompositeOperation = stage.mix; ctx.imageSmoothingEnabled = true;
    ctx.drawImage(stage.cv, stage.rect.x*DPR, stage.rect.y*DPR, stage.rect.w*DPR, stage.rect.h*DPR);
    ctx.restore();

    ctx.restore();
  }

  function drawGear(g){
    const X = g.x*DPR, Y = g.y*DPR; const r = g.r*DPR; ctx.save(); ctx.translate(X,Y); ctx.rotate(g.angle);

    // rim
    ctx.fillStyle = g===MAIN? '#0d141c' : '#0c1218';
    ctx.strokeStyle = '#1f2630'; ctx.lineWidth = 2*DPR; ctx.beginPath(); ctx.arc(0,0,r,0,TWO_PI); ctx.fill(); ctx.stroke();

    // teeth
    ctx.strokeStyle = '#2a323d'; ctx.lineWidth = 2*DPR; const teeth = g.teeth; const step = TWO_PI/teeth; for(let i=0;i<teeth;i++){
      ctx.beginPath(); ctx.moveTo(r,0); ctx.lineTo(r+8*DPR,0); ctx.stroke(); ctx.rotate(step);
    }

    // arcs (segments)
    if(showArcs){
      const w = seqWeights(g); let a0=0; for(let i=0;i<g.seq.length;i++){
        const a1 = a0 + w[i]*TWO_PI; ctx.beginPath(); ctx.strokeStyle = ['#00d0b4','#c8a552','#5aa9e6','#8a5cf6','#ff4d6d'][i%5];
        ctx.lineWidth = 8*DPR; ctx.arc(0,0,r-10*DPR, a0, a1); ctx.stroke(); a0=a1;
      }
    }

    // minor/major ticks
    ctx.save(); ctx.strokeStyle = '#2b313a'; for(let i=0;i<MAJOR_DIV;i++){
      ctx.beginPath(); ctx.moveTo(r-16*DPR,0); ctx.lineTo(r,0); ctx.stroke(); for(let j=1;j<MINOR_DIV/MAJOR_DIV;j++){
        ctx.rotate(TWO_PI/MINOR_DIV); ctx.beginPath(); ctx.moveTo(r-10*DPR,0); ctx.lineTo(r,0); ctx.stroke();
      } ctx.rotate(TWO_PI/MINOR_DIV); }
    ctx.restore();

    // label & selection
    ctx.rotate(-g.angle); ctx.fillStyle = '#cfd3d8'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${Math.max(12, Math.floor(12*DPR))}px system-ui`;
    ctx.fillText(g===MAIN? 'MAIN' : (g.label||'GEAR'), 0, 0);
    if(selectedId===g.id){ ctx.beginPath(); ctx.strokeStyle = '#19c37d'; ctx.lineWidth=2*DPR; ctx.arc(0,0,r+10*DPR,0,TWO_PI); ctx.stroke(); }

    ctx.restore();
  }

  // ====== Recording ======
  function startRecording(){
    try{
      const fps = 30; const target = (outputMode==='Canvas')?canvas:stage.cv; const stream = target.captureStream(fps);
      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')?'video/webm;codecs=vp9':'video/webm;codecs=vp8';
      const recoder = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 6_000_000});
      recoder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) rec.chunks.push(e.data); };
      recoder.onstop = ()=>{
        const blob = new Blob(rec.chunks, {type: mime});
        const url = URL.createObjectURL(blob);
        hud.dl.href = url; const ts = new Date().toISOString().replace(/[:.]/g,'-');
        hud.dl.download = `gear-film-${outputMode.toLowerCase()}-${ts}.webm`;
        hud.dl.style.display='inline-block';
        hud.record.textContent='● Record';
        rec.recorder=null; rec.chunks=[]; rec.stream=null;
      };
      rec.chunks=[]; rec.recorder=recoder; rec.stream=stream; recoder.start();
      hud.record.textContent='■ Stop'; hud.dl.style.display='none';
    }catch(err){ alert('MediaRecorder unsupported in this browser.'); }
  }
  function stopRecording(){ if(rec.recorder){ rec.recorder.stop(); rec.stream?.getTracks().forEach(t=>t.stop()); } }

  // ====== Keyboard ======
  window.addEventListener('keydown',(e)=>{
    if(e.key===' '){ e.preventDefault(); playing=!playing; hud.playPause.textContent = playing?'Pause':'Play'; }
    if(e.key==='['){ driveIndex = (driveIndex-1+gears.length)%gears.length; select(gears[driveIndex].id); }
    if(e.key===']'){ driveIndex = (driveIndex+1)%gears.length; select(gears[driveIndex].id); }
    if(e.key==='\'){ /* AutoShift placeholder */ }
    if(e.key==='O' || e.key==='o'){ outputMode = outputMode==='Normal'?'Canvas':'Normal'; updateToolbar(); }
    if(e.key==='P' || e.key==='p'){ if(!inspectorEl.classList.contains('open')) renderInspector(); else inspectorEl.classList.remove('open'); }
    if(e.key==='Escape'){ inspectorEl.classList.remove('open'); settingsEl.classList.remove('open'); }
  });

  // Close panels on outside click
  document.addEventListener('click',(e)=>{
    if(inspectorEl.classList.contains('open') && !inspectorEl.contains(e.target) && e.target!==canvas){ inspectorEl.classList.remove('open'); }
    if(settingsEl.classList.contains('open') && !settingsEl.contains(e.target) && e.target!==hud.settingsBtn){ settingsEl.classList.remove('open'); }
  });

  // ====== Init ======
  // Center MAIN gear
  MAIN.x = canvas.width/(2*DPR); MAIN.y = canvas.height/(2*DPR); MAIN.meshed=false;
  select(MAIN.id);
})();
</script>
</body>
</html>
