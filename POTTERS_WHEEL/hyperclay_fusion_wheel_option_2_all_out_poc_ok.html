<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Hyperclay — Zen Tube (Fixed Viewport • Linear/Spin • Audio • Clean)</title>
<style>
  :root{
    --bg:#000; --ink:#eae7df; --muted:#9aa0a6; --accent:#00d0b4; --panel:#0f1319f2; --btn:#11161e; --btnb:#2a313a; --ink2:#cfd3d8;
  }
  * { box-sizing: border-box; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--ink); height:100%; }
  #app { position:fixed; inset:0; overflow:hidden; }
  canvas { position:absolute; inset:0; width:100%; height:100%; touch-action:none; background:#000; }

  .hud, .topbar { font: 600 12px/1.2 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue"; }
  .topbar {
    position:fixed; top:0; left:0; right:0; display:flex; gap:.5rem; padding:.5rem .6rem; align-items:center;
    justify-content:space-between; background:linear-gradient(180deg, rgba(0,0,0,.35), transparent);
    pointer-events:none; z-index:5;
  }
  .topbar .group { pointer-events:auto; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  .badge { padding:.25rem .5rem; border:1px solid #2a313a; border-radius:12px; background:#0c1118; color:var(--ink2); }
  .note  { font-size:11px; color:var(--muted); }

  .hud {
    position: fixed; left: 0; right: 0; bottom: 0; z-index:6;
    display:flex; gap:.5rem; padding:.6rem; align-items:center; justify-content:center; flex-wrap:wrap;
    background: linear-gradient(180deg, transparent, rgba(0,0,0,.35)); backdrop-filter: blur(8px);
    transition: opacity .25s;
  }
  .hud.hidden{ opacity:0; pointer-events:none; }
  button, label.btn, a.btn { border:1px solid var(--btnb); border-radius:14px; padding:.6rem .8rem; background:var(--btn); color:var(--ink); display:inline-flex; align-items:center; gap:.35rem; cursor:pointer; user-select:none; text-decoration:none; }
  button:active, label.btn:active { transform: translateY(1px); }
  button.on { outline: 1px solid var(--accent); box-shadow: 0 0 0 2px #00d0b422 inset; }
  #file, #jsonfile { display:none; }

  .toast { position:fixed; left:50%; transform:translateX(-50%); bottom:80px; z-index:20; background:#0f141b; border:1px solid #2a313a; border-radius:12px; padding:.5rem .75rem; color:var(--ink2); opacity:0; transition:opacity .25s; }
  .toast.show { opacity:1; }

  /* Recording visible stop pill */
  .rec-stop{ position:fixed; right:12px; bottom:12px; z-index:50; padding:.6rem .9rem; border-radius:18px; border:1px solid #4a1f1f; background:#1a0e0e; color:#ffb3b3; display:none; }
  body.recording .rec-stop{ display:inline-flex; }
  /* Hide chrome in recording but keep stop pill alive */
  body.recording .topbar, body.recording .hud { display:none; }
</style>
</head>
<body>
<div id="app" data-mode="zen">
  <canvas id="c"></canvas>

  <div class="topbar">
    <div class="group">
      <span class="badge">Hyperclay — Zen Tube</span>
      <span class="note" id="phaseNote">phase 0.000</span>
      <span class="note" id="fpsNote">fps —</span>
    </div>
    <div class="group"><span class="badge">No marks • Fixed viewport • Tube • Linear • Audio</span></div>
  </div>

  <div class="hud">
    <label class="btn" for="file">Load Clips</label><input id="file" type="file" multiple accept="image/*,video/*" />
    <button id="modeSpin" class="on" title="SPIN: fling/drag to scrub time">SPIN</button>
    <button id="modeSculpt" title="SCULPT: drag near anchors (invisible)">SCULPT</button>
    <button id="playBtn" title="Play/Pause">Play</button>
    <button id="lockViewBtn" class="on" title="Lock viewport (fixed camera)">Lock View</button>
    <button id="tubeBtn" class="on" title="Concentric tube layout for stamps">Tube</button>
    <button id="linearBtn" title="Linear timeline (0→1)">Linear</button>
    <label class="btn" for="linDur" title="Linear duration (s)">Dur <input id="linDur" type="number" min="0.5" step="0.5" value="6" style="width:64px; margin-left:.35rem;"/></label>
    <button id="linearLoop" title="Loop linear">Loop</button>
    <button id="stampBtn" title="Stamp current composite as transparent">STAMP</button>
    <button id="captureBtn" title="Capture viewport to PNG">Capture</button>
    <button id="recBtn" title="Start/Stop recording">● Record</button>
    <a id="dl" class="btn" style="display:none" download="hyperclay.webm">Download</a>
    <label class="btn" for="audioSel">Audio</label>
    <select id="audioSel" title="Choose video as audio source"></select>
    <label class="btn">Gain <input id="gain" type="range" min="0" max="2" value="1" step="0.01" style="width:90px"></label>
  </div>

  <button id="stopRec" class="rec-stop">⏹ Stop</button>
  <div id="toast" class="toast">Saved</div>
</div>

<script>
(() => {
  // ==========================
  // Canvas & Resolution
  // ==========================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let RES_SCALE = 1.0; let DPR = 1;
  function computeDPR(){ DPR = Math.max(1, Math.min(2, (window.devicePixelRatio || 1) * RES_SCALE)); }
  function resize(){ computeDPR(); const {clientWidth:w, clientHeight:h} = canvas; canvas.width = Math.floor(w * DPR); canvas.height= Math.floor(h * DPR); if (state.view.locked){ state.view.cx = canvas.width/2; state.view.cy = canvas.height/2; } }

  // ==========================
  // App State (clean defaults: no feather, no fog)
  // ==========================
  const state = {
    cx: () => canvas.width  * 0.5,
    cy: () => canvas.height * 0.5,
    wheelScale: 1.0,
    baseWheelR: () => Math.min(canvas.width, canvas.height) * 0.28 * state.wheelScale,
    wheelAngle: 0, wheelVel: 0, friction: 0.985,
    mode: 'SPIN', clips: [], activeClipId: null, history: [],
    view: { zoom: 1.0, cx: canvas.width/2, cy: canvas.height/2, locked: true },
    playing: false, tube: true, busXfade: 0.5,
    linear: false, linearLoop:false, linearDur: 6, linearT: 0,
    audio: { ctx:null, gainNode:null, dest:null, current:null }
  };
  let nextId = 1;
  new ResizeObserver(() => requestAnimationFrame(resize)).observe(canvas); resize();

  // ==========================
  // UI Refs
  // ==========================
  const $ = (id)=>document.getElementById(id);
  const fileInput=$('file');
  const modeSpinBtn=$('modeSpin'), modeScptBtn=$('modeSculpt');
  const stampBtn=$('stampBtn'), captureBtn=$('captureBtn');
  const recBtn=$('recBtn'), dlLink=$('dl');
  const phaseNote=$('phaseNote'), fpsNote=$('fpsNote'), toastEl=$('toast');
  const playBtn=$('playBtn'), lockViewBtn=$('lockViewBtn'), tubeBtn=$('tubeBtn');
  const xfadeSlider=null; // (kept minimal in this zen build)
  const linearBtn=$('linearBtn'), linDur=$('linDur'), linearLoop=$('linearLoop');
  const audioSel=$('audioSel'), gainRange=$('gain'); const stopRecBtn=$('stopRec');

  function showToast(msg, ms=900){ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=> toastEl.classList.remove('show'), ms); }

  // Auto-hide HUD
  let hudTimer=null; const hud=document.querySelector('.hud'); function bumpHUD(){ hud.classList.remove('hidden'); clearTimeout(hudTimer); hudTimer=setTimeout(()=>hud.classList.add('hidden'), 1600); }
  window.addEventListener('mousemove', bumpHUD, {passive:true}); window.addEventListener('touchstart', bumpHUD, {passive:true}); bumpHUD();

  // History (minimal)
  function snapshot(){ const snap = state.clips.map(c => ({ id:c.id, type:c.type, angle:c.angle, radius:c.radius, scale:c.scale, edge:c.edge, fog:c.fog, blend:c.blend, timeOffset:c.timeOffset, duration:c.duration, label:c.label || null, ring:c.ring||0 })); state.history.push(snap); if (state.history.length > 40) state.history.shift(); }

  // Add Clips (defaults: edge=0, fog=0 for mark‑free frames)
  function defaultClipBase(){ return { id: nextId++, angle: 0, radius: 0, scale: 1.0, edge: 0, fog: 0.0, blend: 'source-over', timeOffset: 0, duration: 5, ring: 0 }; }
  function addImageClip(img){ state.clips.push({ ...defaultClipBase(), type:'image', el:img, kind:'img' }); snapshot(); refreshAudioList(); }
  function addStampClip(img){ const ring = Math.max(0, ...state.clips.map(c=>c.ring||0)) + 1; state.clips.push({ ...defaultClipBase(), type:'stamp', el:img, kind:'img', ring, scale:1.0 }); snapshot(); }
  function addVideoClip(video, duration=5){ video.muted = true; video.playsInline = true; state.clips.push({ ...defaultClipBase(), type:'video', el:video, kind:'video', duration: duration||5, scale:1.0 }); snapshot(); refreshAudioList(); }

  fileInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []);
    for (const f of files){
      if (f.type.startsWith('image/')){ const url = URL.createObjectURL(f); const img = new Image(); await new Promise(res => { img.onload = res; img.src = url; }); addImageClip(img); }
      else if (f.type.startsWith('video/')){ const url = URL.createObjectURL(f); const vid = document.createElement('video'); vid.src = url; vid.preload='auto'; vid.loop=true; vid.muted=true; vid.playsInline=true; await vid.play().catch(()=>{}); vid.pause(); const duration = isFinite(vid.duration) ? vid.duration : 5; addVideoClip(vid, duration); }
    }
    fileInput.value = '';
  });

  // Modes / Controls
  function setMode(m){ state.mode = m; modeSpinBtn.classList.toggle('on', m==='SPIN'); modeScptBtn.classList.toggle('on', m==='SCULPT'); }
  modeSpinBtn.addEventListener('click', () => setMode('SPIN'));
  modeScptBtn.addEventListener('click', () => setMode('SCULPT'));

  playBtn.addEventListener('click', ()=>{
    state.playing=!state.playing; playBtn.classList.toggle('on', state.playing); playBtn.textContent = state.playing? 'Pause':'Play';
    if (state.playing){ ensureAudio(); if (state.audio.ctx&&state.audio.ctx.state==='suspended') state.audio.ctx.resume(); const id = Number(audioSel.value||'0'); const clip = state.clips.find(c=>c.id===id && c.kind==='video'); if (clip){ clip.el.loop = true; clip.el.play().catch(()=>{}); } }
    else { for (const c of state.clips){ if (c.kind==='video') try{ c.el.pause(); }catch(_){} } }
  });
  lockViewBtn.addEventListener('click', ()=>{ state.view.locked=!state.view.locked; lockViewBtn.classList.toggle('on', state.view.locked); });
  tubeBtn.addEventListener('click', ()=>{ state.tube=!state.tube; tubeBtn.classList.toggle('on', state.tube); });
  linearBtn.addEventListener('click', ()=>{ state.linear=!state.linear; state.linearT=0; linearBtn.classList.toggle('on', state.linear); });
  linearLoop.addEventListener('click', ()=>{ state.linearLoop=!state.linearLoop; linearLoop.classList.toggle('on', state.linearLoop); });
  linDur.addEventListener('change', ()=>{ state.linearDur = Math.max(0.5, Number(linDur.value)||6); });

  // Capture viewport exactly
  captureBtn.addEventListener('click', ()=>{ const url = canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=`frame_${Date.now()}.png`; a.click(); showToast('Frame captured'); });

  // STAMP transparent (render layers only to offscreen)
  const stampBtnHandler = () => { const off = document.createElement('canvas'); off.width = canvas.width; off.height = canvas.height; const oc = off.getContext('2d'); const phase = timelinePhase(0); drawScene(oc, phase, true); const dataURL = off.toDataURL('image/png'); const img = new Image(); img.onload = () => addStampClip(img); img.src = dataURL; showToast('Stamped'); };
  stampBtn.addEventListener('click', stampBtnHandler);

  // ==========================
  // Audio (WebAudio graph + recording bus)
  // ==========================
  function ensureAudio(){ if (state.audio.ctx) return; const ctxA = new (window.AudioContext||window.webkitAudioContext)(); const gain = ctxA.createGain(); const dest = ctxA.createMediaStreamDestination(); gain.connect(ctxA.destination); gain.connect(dest); state.audio.ctx=ctxA; state.audio.gainNode=gain; state.audio.dest=dest; gainRange.addEventListener('input', ()=>{ gain.gain.value = Number(gainRange.value); }); refreshAudioList(); }

  function refreshAudioList(){ const vids = state.clips.filter(c=>c.kind==='video'); const sel = audioSel; const selected = sel.value; sel.innerHTML = '<option value="">(no audio)</option>'; for (const v of vids){ const opt=document.createElement('option'); opt.value=String(v.id); opt.textContent=`Video #${v.id}`; sel.appendChild(opt); } if ([...sel.options].some(o=>o.value===selected)) sel.value=selected; }

  audioSel.addEventListener('change', ()=>{ const id = Number(audioSel.value||'0'); if (!id){ disconnectAudio(); return; } ensureAudio(); const clip = state.clips.find(c=>c.id===id && c.kind==='video'); if (!clip) return; try{ disconnectAudio(); const src = state.audio.ctx.createMediaElementSource(clip.el); src.connect(state.audio.gainNode); state.audio.current = { id, node:src }; }catch(err){ console.warn('Audio source error', err); }
  });
  function disconnectAudio(){ if (state.audio.current && state.audio.current.node){ try{ state.audio.current.node.disconnect(); }catch(_){} } state.audio.current=null; }

  // ==========================
  // Recording (canvas + WebAudio mux)
  let mediaRecorder = null, recChunks = [], recording = false; let mixedStream=null;
  recBtn.addEventListener('click', toggleRecording); stopRecBtn.addEventListener('click', ()=> stopRecording());
  function toggleRecording(){ if (!recording) startRecording(); else stopRecording(); }
  function startRecording(){ if (recording) return; ensureAudio(); if (state.audio.ctx&&state.audio.ctx.state==='suspended') state.audio.ctx.resume(); const vStream = canvas.captureStream(24); mixedStream = new MediaStream(); vStream.getVideoTracks().forEach(t=>mixedStream.addTrack(t)); if (state.audio.dest && state.audio.dest.stream.getAudioTracks()[0]){ mixedStream.addTrack(state.audio.dest.stream.getAudioTracks()[0]); }
    if (!('MediaRecorder' in window)) { alert('MediaRecorder not supported.'); return; }
    let options = { mimeType: 'video/webm;codecs=vp9,opus' }; try{ mediaRecorder = new MediaRecorder(mixedStream, options); }catch(_){ mediaRecorder = new MediaRecorder(mixedStream); }
    recChunks = []; mediaRecorder.ondataavailable = e => { if (e.data.size) recChunks.push(e.data); };
    mediaRecorder.onstop = () => { const blob = new Blob(recChunks, { type:'video/webm' }); const url = URL.createObjectURL(blob); dlLink.href = url; dlLink.style.display=''; document.body.classList.remove('recording'); stopRecBtn.style.display='none'; };
    mediaRecorder.start(1000); recording = true; recBtn.classList.add('on'); dlLink.style.display='none'; document.body.classList.add('recording'); stopRecBtn.style.display='inline-flex'; showToast('Recording…'); }
  function stopRecording(silent=false){ if (!recording) return; try{ mediaRecorder.stop(); }catch(_){} recording=false; recBtn.classList.remove('on'); if(!silent) showToast('Recording complete — Download ready'); }

  // ==========================
  // Interaction (spin/sculpt, zoom/pan) — no visible anchors/marks
  let dragging=false, dragLastAngle=0; let draggingClip=null; let panning=false; let panLast=null;

  function pointAngle(x,y){ const dx=x-state.cx(), dy=y-state.cy(); return Math.atan2(dy,dx); }
  function pointerPos(e){ if (e.touches && e.touches[0]){ const r=canvas.getBoundingClientRect(); return { x:(e.touches[0].clientX-r.left)*DPR, y:(e.touches[0].clientY-r.top)*DPR }; } else { const r=canvas.getBoundingClientRect(); return { x:(e.clientX-r.left)*DPR, y:(e.clientY-r.top)*DPR }; } }
  function nearestClipHandle(px,py){ const R=state.baseWheelR(); const world=(a)=>a+state.wheelAngle; let best=null, bestD2=Infinity; for (const c of state.clips){ const angleLocal = state.tube? 0 : c.angle; const radiusLocal = state.tube? (c.ring||0)*tubeSpacing() : c.radius; const a=world(angleLocal), r=R+radiusLocal; const hx=state.cx()+r*Math.cos(a), hy=state.cy()+r*Math.sin(a); const dx=hx-px, dy=hy-py, d2=dx*dx+dy*dy; if (d2<bestD2){ bestD2=d2; best={clip:c,d2}; } } return best && best.d2 < (36*DPR)*(36*DPR) ? best.clip : null; }

  canvas.addEventListener('wheel', (e)=>{ if (state.view.locked) return; e.preventDefault(); const rect=canvas.getBoundingClientRect(); const sx=(e.clientX-rect.left)*DPR, sy=(e.clientY-rect.top)*DPR; const pre = screenToWorld(sx,sy); const k = Math.pow(1.0015, -e.deltaY); zoomAt(pre.x, pre.y, k); bumpHUD(); }, {passive:false});
  function zoomAt(wx, wy, k){ const vz=clamp(state.view.zoom*k, 0.05, 200); const nx = wx + (state.view.cx - wx) * (state.view.zoom/vz); const ny = wy + (state.view.cy - wy) * (state.view.zoom/vz); state.view.cx = nx; state.view.cy = ny; state.view.zoom = vz; }
  function screenToWorld(sx,sy){ const sw=canvas.width/state.view.zoom, sh=canvas.height/state.view.zoom; const sx0 = state.view.cx - sw/2; const sy0 = state.view.cy - sh/2; return { x: sx0 + sx/state.view.zoom, y: sy0 + sy/state.view.zoom }; }

  canvas.addEventListener('touchstart', onDown, {passive:false}); canvas.addEventListener('mousedown', onDown);
  function onDown(e){
    if (state.view.locked) { // still allow spin/sculpt
      e.preventDefault(); bumpHUD(); const {x,y} = pointerPos(e); dragLastAngle = pointAngle(x,y); dragging=true; draggingClip = (state.mode==='SCULPT') ? nearestClipHandle(x,y) : null; return;
    }
    e.preventDefault(); bumpHUD(); const {x,y} = pointerPos(e);
    if (!e.touches && (e.button===1 || e.altKey || e.metaKey || e.ctrlKey || e.shiftKey)) { panning=true; panLast={x,y}; return; }
    dragLastAngle = pointAngle(x,y); dragging=true; draggingClip = (state.mode==='SCULPT') ? nearestClipHandle(x,y) : null;
  }

  window.addEventListener('touchmove', onMove, {passive:false}); window.addEventListener('mousemove', onMove);
  function onMove(e){
    if (!state.view.locked && panning && panLast){ const {x,y}=pointerPos(e); const dx=(panLast.x-x)/state.view.zoom; const dy=(panLast.y-y)/state.view.zoom; state.view.cx += dx; state.view.cy += dy; panLast={x,y}; return; }
    if (!dragging) return; e.preventDefault(); const {x,y} = pointerPos(e); const a = pointAngle(x,y); const da = angDiff(a, dragLastAngle); dragLastAngle=a;
    if (state.mode==='SCULPT' && draggingClip){ const qStep = Math.PI/12; const R = state.baseWheelR(); const dist = Math.hypot(x-state.cx(), y-state.cy()); const angleRaw = normAngle((draggingClip.angle||0) + da); draggingClip.angle = state.tube ? 0 : Math.round(angleRaw/qStep)*qStep; const localR = clamp(dist - R, -R*0.25, R*0.6); draggingClip.radius = state.tube ? draggingClip.radius : localR; }
    else { state.wheelAngle = normAngle(state.wheelAngle + da); state.wheelVel = da; }
  }

  window.addEventListener('touchend', onUp); window.addEventListener('mouseup', onUp);
  function onUp(){ dragging=false; draggingClip=null; panning=false; panLast=null; }

  function angDiff(a,b){ let d=a-b; while(d>Math.PI) d-=Math.PI*2; while(d<-Math.PI) d+=Math.PI*2; return d; }
  function normAngle(a){ while(a>Math.PI) a-=Math.PI*2; while(a<=-Math.PI) a+=Math.PI*2; return a; }
  const clamp = (v,lo,hi)=> Math.max(lo,Math.min(hi,v));

  // Offscreens (for mask-free comp)
  const offA = document.createElement('canvas'); const offB = document.createElement('canvas');
  let octxA = offA.getContext('2d'); let octxB = offB.getContext('2d');
  function ensureOff(w,h){ if (offA.width!==w||offA.height!==h){ offA.width=w; offA.height=h; offB.width=w; offB.height=h; octxA=offA.getContext('2d'); octxB=offB.getContext('2d'); } }

  // Scene buffer for fixed viewport
  const scn = document.createElement('canvas'); const scx = scn.getContext('2d');
  function ensureScene(){ if (scn.width!==canvas.width || scn.height!==canvas.height){ scn.width=canvas.width; scn.height=canvas.height; } }
  function tubeSpacing(){ return Math.min(canvas.width, canvas.height) * 0.18; }

  function drawFeatherMask(ctxMask,w,h,edgePx){ ctxMask.clearRect(0,0,w,h); if (edgePx<=1){ ctxMask.fillStyle='#fff'; ctxMask.fillRect(0,0,w,h); return; } }

  function drawClipLayer(mainCtx, clip, phase){
    const cx=state.cx(), cy=state.cy(), R=state.baseWheelR();
    let srcW=clip.el?.videoWidth||clip.el?.naturalWidth||320; let srcH=clip.el?.videoHeight||clip.el?.naturalHeight||180;

    // time seek for videos (no overlay, no badges)
    if (clip.kind==='video' && isFinite(clip.duration)){
      const t = ((phase * clip.duration) + clip.timeOffset) % clip.duration;
      if (!Number.isNaN(t)) { try { clip.el.currentTime = t; } catch(_){} }
    }

    const targetW=Math.max(8, Math.floor(srcW*clip.scale));
    const targetH=Math.max(8, Math.floor(srcH*clip.scale));
    ensureOff(targetW,targetH);

    // draw source
    octxA.clearRect(0,0,targetW,targetH);
    try { octxA.drawImage(clip.el, 0, 0, targetW, targetH); } catch(_) {}

    // (no mask if edge==0 — default)
    if ((clip.edge|0) > 0){ octxB.clearRect(0,0,targetW,targetH); drawFeatherMask(octxB, targetW, targetH, Math.min(clip.edge * DPR, Math.floor(Math.min(targetW,targetH)/3)) ); octxA.globalCompositeOperation='destination-in'; octxA.drawImage(offB,0,0); octxA.globalCompositeOperation='source-over'; }

    // (no fog by default)

    const ringR = (clip.ring||0) * tubeSpacing();
    const localAngle = state.tube ? 0 : clip.angle;
    const localRadius = state.tube ? ringR : clip.radius;
    const aWorld=localAngle+state.wheelAngle; const rWorld=R+localRadius; const x = cx + rWorld*Math.cos(aWorld) - targetW/2; const y= cy + rWorld*Math.sin(aWorld) - targetH/2;

    mainCtx.save(); mainCtx.globalCompositeOperation = clip.blend || 'source-over'; mainCtx.globalAlpha = 1; mainCtx.drawImage(offA, Math.floor(x), Math.floor(y)); mainCtx.restore();
  }

  // Timeline phase (fixed & bug-free)
  let lastTick = performance.now();
  function timelinePhase(dtOverride){
    const now = performance.now();
    const dt = (typeof dtOverride==='number') ? dtOverride : (now - lastTick) / 1000; lastTick = now;

    // Drive from audio clip if linear + audio selected
    const selId = Number((audioSel && audioSel.value) || '0');
    if (state.playing && state.linear && selId){
      const clip = state.clips.find(c=>c.id===selId && c.kind==='video');
      if (clip && isFinite(clip.duration) && clip.duration>0){
        return ( (clip.el.currentTime % clip.duration) / clip.duration );
      }
    }

    if (state.playing && state.linear){
      state.linearT += dt; const t = state.linearT / state.linearDur;
      if (t>=1){ if (state.linearLoop){ state.linearT = 0; } else { state.playing=false; playBtn.classList.remove('on'); playBtn.textContent='Play'; } }
      return Math.min(1, (state.linearT / state.linearDur) || 0);
    }

    // spin mode phase from wheelAngle
    return ( (state.wheelAngle/(Math.PI*2)) % 1 + 1 ) % 1;
  }

  // Draw scene (layersOnly skips bg)
  function drawScene(context, phase, layersOnly=false){ if (!layersOnly){ context.clearRect(0,0,canvas.width,canvas.height); context.fillStyle='#000'; context.fillRect(0,0,canvas.width,canvas.height); } for (const c of state.clips) drawClipLayer(context, c, phase); }

  // Main Loop
  let lastT=performance.now(), fpsSm=60;
  function tick(now){
    const dt = now-lastT; lastT=now; const alpha = Math.max(0.25, Math.min(4, dt/16.6667));
    if (!state.playing && (!dragging || state.mode!=='SCULPT')){ state.wheelAngle = normAngle(state.wheelAngle + state.wheelVel*alpha); state.wheelVel *= Math.pow(state.friction, alpha); if (Math.abs(state.wheelVel)<1e-5) state.wheelVel=0; }

    const phase = timelinePhase();
    ensureScene(); scx.setTransform(1,0,0,1,0,0); scx.clearRect(0,0,scn.width,scn.height); scx.fillStyle='#000'; scx.fillRect(0,0,scn.width,scn.height);
    for (const c of state.clips) drawClipLayer(scx, c, phase);

    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
    const sw = canvas.width / state.view.zoom; const sh = canvas.height / state.view.zoom; const sx = Math.max(0, state.view.cx - sw/2); const sy = Math.max(0, state.view.cy - sh/2);
    ctx.drawImage(scn, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);

    phaseNote.textContent = `phase ${phase.toFixed(3)}`;
    fpsSm = fpsSm*0.9 + (1000/dt)*0.1; fpsNote.textContent = `fps ${Math.max(1, Math.round(fpsSm))}`;

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Keyboard (minimal)
  window.addEventListener('keydown', e => {
    if (e.key===' ') setMode(state.mode==='SPIN'?'SCULPT':'SPIN');
    if (e.key==='p') playBtn.click(); if (e.key==='l') lockViewBtn.click(); if (e.key==='t') tubeBtn.click();
    if (e.key==='s') stampBtn.click(); if (e.key==='r') recBtn.click();
  });

  // ==========================
  // Self-tests (sanity; no DOM leaks)
  // ==========================
  function runSelfTests(){
    const errs=[]; const ok=(name,cond)=>{ if(!cond){ errs.push(name); console.error('Test failed:', name); } };
    try { resize(); ok('resize-after-state', true); } catch(e){ ok('resize-after-state', false); }
    ok('state-exists', !!state && typeof state==='object');
    ok('phase-in-range', (()=>{ const p=((state.wheelAngle/(Math.PI*2))%1 + 1) % 1; return p>=0 && p<1; })());
    // transparent stamp when no clips
    const off=document.createElement('canvas'); off.width=2; off.height=2; const oc=off.getContext('2d'); drawScene(oc, 0.0, true); const px=oc.getImageData(0,0,1,1).data; ok('stamp-transparent', px[3]===0);
    ok('stop-pill-present', !!document.getElementById('stopRec'));
    console.log(errs.length? 'Self-tests failed:'+errs.join(', ') : '%cSelf-tests passed','color:#00d0b4');
  }
  setTimeout(runSelfTests, 0);
})();
</script>
</body>
</html>
