<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Main Gear Film Engine — Canvas (Zen Mobile)</title>
<style>
  :root{
    --bg:#0b0c10; --ink:#eae7df; --muted:#9aa0a6; --accent:#00d0b4; --good:#2ecc71; --warn:#e6b800; --bad:#ff4d4f;
    --panel:#0f1319f2; --glass:#0d1117cc; --chip:#141a22; --chipb:#1b232e; --line:#1d232c;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui, ui-sans-serif, Segoe UI, Roboto, Inter, sans-serif}
  #c{position:fixed;inset:0;display:block;touch-action:none}
  /* Hide heavy UI in zen mode */
  body.zen #toolbar, body.zen #hud, body.zen #inspector, body.zen #settings{display:none!important}
  /* Minimal micro HUD */
  #microHUD{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);display:flex;gap:10px;z-index:12}
  .mbtn{background:linear-gradient(180deg,#111822,#0c121a);border:1px solid #2a3342;color:var(--ink);padding:10px 12px;border-radius:999px;font-size:14px;box-shadow:0 8px 24px #0009}
  .mbtn:active{transform:translateY(1px)}
  #chipTop{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#0c1219cc;border:1px solid #1e2632;border-radius:999px;padding:6px 10px;font-size:12px;z-index:12}
  /* Quick gear bar (context) */
  #qbar{position:fixed;display:flex;gap:6px;z-index:13;pointer-events:auto}
  #qbar button{background:#0c121a;border:1px solid #283241;color:#dfe6ee;padding:6px 8px;border-radius:10px;font-size:12px}
  #qbar.hidden{display:none}
  /* Legacy toolbar/HUD kept for power users (toggled by two-finger tap) */
  #toolbar{position:fixed;top:8px;left:8px;right:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;z-index:10}
  .badge{background:linear-gradient(180deg,var(--chip),var(--chipb));border:1px solid #263041;color:var(--ink);padding:6px 10px;border-radius:999px;font-size:12px;display:flex;align-items:center;gap:6px;box-shadow:0 2px 6px #0007}
  #hud{position:fixed;left:0;right:0;bottom:0;padding:8px;display:flex;justify-content:center;z-index:10}
  .hudbar{display:flex;gap:8px;background:linear-gradient(180deg,var(--glass),#0a0e14ef);border:1px solid #1e2632;padding:8px 10px;border-radius:14px;backdrop-filter:blur(8px);box-shadow:0 8px 24px #0009}
  .segbtn{background:linear-gradient(180deg,#111822,#0c121a);border:1px solid #2a3342;color:var(--ink);padding:8px 12px;border-radius:12px;font-size:13px}
  input[type=file]{display:none}
  a#download{display:none}
  /* Panels */
  .panel{position:fixed;right:12px;top:60px;bottom:12px;width:min(420px,92vw);background:var(--panel);border:1px solid #283241;border-radius:14px;box-shadow:0 20px 60px #000d;padding:14px 14px 80px;overflow:auto;z-index:15}
  .panel.hidden{display:none}
  .row{display:flex;align-items:center;gap:10px;margin:8px 0}
  .row label{min-width:120px;color:#d0d7e3;font-size:13px}
  .row input[type=range]{flex:1}
  .row input[type=text], .row input[type=number], .row select{flex:1;background:#0c1117;border:1px solid #283241;border-radius:8px;padding:6px 8px;color:var(--ink)}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border-bottom:1px solid #22303f;padding:6px 4px;font-size:12px;text-align:left}
</style>
</head>
<body class="zen">
  <canvas id="c"></canvas>

  <!-- Minimal micro HUD (always available in zen) -->
  <div id="chipTop">Drive <span id="chipDrive">#main</span> • <span id="chipBPM">Free</span> • <span id="chipOut">Stage</span></div>
  <div id="microHUD">
    <button id="mPlay" class="mbtn">▶</button>
    <button id="mRec" class="mbtn">●</button>
    <button id="mOut" class="mbtn">Out</button>
  </div>
  <div id="qbar" class="hidden">
    <button id="qbRoute">Route</button>
    <button id="qbDur-">–Dur</button>
    <button id="qbDur+">+Dur</button>
    <button id="qbText">+Text</button>
    <button id="qbDel">Del</button>
  </div>

  <!-- Full UI (hidden in zen; two-finger tap to toggle) -->
  <div id="toolbar">
    <div class="badge" id="bDrive"><b>Drive:</b><span id="driveVal">#main</span></div>
    <div class="badge" id="bBPM" role="button"><b>BPM:</b><span id="bpmVal">Free</span></div>
    <div class="badge" id="bQuant" role="button"><b>Quant:</b><span id="quantVal">Off</span></div>
    <div class="badge" id="bMix" role="button"><b>Mix:</b><span id="mixVal">Screen</span></div>
    <div class="badge" id="bOutput" role="button"><b>Output:</b><span id="outVal">Normal</span></div>
    <div class="badge" id="bArcs" role="button"><b>ARCS</b><span class="dot on" id="arcsDot" style="width:8px;height:8px;border-radius:50%;background:#2ecc71"></span></div>
  </div>
  <div id="hud">
    <div class="hudbar">
      <label class="segbtn" for="fileVideo">Add Video</label><input id="fileVideo" type="file" accept="video/*" multiple>
      <label class="segbtn" for="fileImage">Add Image</label><input id="fileImage" type="file" accept="image/*" multiple>
      <label class="segbtn" for="fileAudio">Add Audio</label><input id="fileAudio" type="file" accept="audio/*" multiple>
      <button id="addText" class="segbtn">Add Text</button>
      <a id="download" class="segbtn" href="#" download>Download</a>
      <button id="settingsBtn" class="segbtn">Settings</button>
    </div>
  </div>

  <div id="inspector" class="panel hidden" aria-modal="true"></div>
  <div id="settings" class="panel hidden" aria-modal="true"></div>

<script>
(() => {
  // ====== (Reuse core engine from prior build, trimmed & with ZEN mode) ======
  const DPR = Math.max(1, window.devicePixelRatio||1);
  const TWO_PI = Math.PI*2, TOOTH_PITCH=10, K_RADIUS_PER_SEC=5, MINOR_DIV=60, MAJOR_DIV=12;
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x)), mod=(n,m)=>((n%m)+m)%m;
  const canvas=document.getElementById('c'), ctx=canvas.getContext('2d');
  const stage=document.createElement('canvas'), sctx=stage.getContext('2d');
  const view={w:0,h:0,cx:0,cy:0}; const stageRect={x:0,y:0,w:0,h:0};
  function resize(){ const w=innerWidth,h=innerHeight; canvas.width=w*DPR; canvas.height=h*DPR; canvas.style.width=w+'px'; canvas.style.height=h+'px'; ctx.setTransform(DPR,0,0,DPR,0,0); view.w=w; view.h=h; view.cx=w/2; view.cy=h/2; fitStage(); }
  function fitStage(){ const maxW=Math.floor(view.w*.62), maxH=Math.floor(view.h*.62); let w=maxW,h=Math.floor(w*9/16); if(h>maxH){h=maxH; w=Math.floor(h*16/9);} stage.width=w; stage.height=h; stageRect.w=w; stageRect.h=h; stageRect.x=Math.floor(view.cx-w/2); stageRect.y=Math.floor(view.cy-h/2); }
  resize(); new ResizeObserver(resize).observe(document.body);

  // ---- minimal audio+haptics
  let ACtx; try{ACtx = new (window.AudioContext||window.webkitAudioContext)();}catch(_){}
  const audioState={clicks:true, vol:.3};
  function beep(f=800,d=.02){ if(!ACtx||!audioState.clicks) return; const t=ACtx.currentTime, o=ACtx.createOscillator(), g=ACtx.createGain(); o.type='square'; o.frequency.value=f; g.gain.value=audioState.vol; g.gain.exponentialRampToValueAtTime(.0001, t+d); o.connect(g).connect(ACtx.destination); o.start(t); o.stop(t+d); }
  const haptics={enabled:true, minor:12, major:22, perfect:[14,60,14]};
  const vib=p=>{ if(haptics.enabled&&navigator.vibrate) navigator.vibrate(p); };
  const hapMinor=()=>{vib(haptics.minor); beep(1600,.01);};
  const hapMajor=()=>{vib(haptics.major); beep(700,.02);};
  const hapPerfect=()=>{vib(haptics.perfect); beep(240,.03); overlayPulse.t=260;};

  // ---- gears
  let gearId=1; function durationToRadius(s){return Math.max(30, s*K_RADIUS_PER_SEC);} function recomputeTeeth(g){g.teeth=Math.max(6, Math.round((TWO_PI*g.r)/TOOTH_PITCH));}
  function makeGear({label='GEAR',x=view.cx,y=view.cy,duration=24,kind='group'}={}){ const r=durationToRadius(duration); const g={id:'g'+(gearId++),x,y,r,teeth:0,angle:0,omega:0,duration,label,kind,routed:false,throttle:1,ease:'linear',seq:[{type:'placeholder',label:'slot',w:1,offset:0,stretch:1,opacity:1,gain:0,fin:0,fout:0,blend:'source-over'}],eligible:false,meshed:false,quant:'off'}; recomputeTeeth(g); return g; }
  const state={playing:false, outputMode:'Normal', quant:'off', mix:'screen', showArcs:true, lastT:performance.now(), bpm:null, selected:null, driveIndex:0, gears:[], main:null, recorder:null, recStream:null, recChunks:[], zen:true};
  const MAIN=makeGear({label:'MAIN',x:view.cx,y:view.cy,duration:48}); MAIN.routed=true; MAIN.id='main'; state.gears.push(MAIN); state.main=MAIN; state.selected=MAIN.id;

  // ---- micro HUD
  const $=(id)=>document.getElementById(id);
  const chipDrive=$('chipDrive'), chipBPM=$('chipBPM'), chipOut=$('chipOut');
  const mPlay=$('mPlay'), mRec=$('mRec'), mOut=$('mOut'), qbar=$('qbar');
  function syncChips(){ chipDrive.textContent = '#'+(state.selected||'main'); chipBPM.textContent = state.bpm? state.bpm+' BPM' : 'Free'; chipOut.textContent = state.outputMode==='Normal'?'Stage':'Canvas'; }
  mPlay.onclick=()=>{ state.playing=!state.playing; mPlay.textContent=state.playing?'❚❚':'▶'; if(ACtx&&ACtx.state==='suspended') ACtx.resume(); };
  mOut.onclick=()=>{ state.outputMode = state.outputMode==='Normal'?'Canvas':'Normal'; syncChips(); };
  mRec.onclick=()=>{ if(state.recorder){ stopRec(); return; } startRec(); };

  function startRec(){ const target = state.outputMode==='Normal'? stage : canvas; const stream=target.captureStream(30); state.recStream=stream; const rec=new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9'}); state.recChunks=[]; rec.ondataavailable=e=>{if(e.data&&e.data.size>0) state.recChunks.push(e.data)}; rec.onstop=()=>{ const blob=new Blob(state.recChunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.getElementById('download'); if(a){ a.href=url; a.download=`MainGear_${Date.now()}.webm`; a.style.display='inline-block'; } mRec.textContent='●'; }; state.recorder=rec; mRec.textContent='■'; rec.start(); }
  function stopRec(){ if(!state.recorder) return; state.recorder.stop(); if(state.recStream) state.recStream.getTracks().forEach(t=>t.stop()); state.recorder=null; }

  // ---- ingest (kept via hidden HUD when not in zen)
  $('fileVideo')?.addEventListener('change', e=> ingestFiles(e.target.files,'video'));
  $('fileImage')?.addEventListener('change', e=> ingestFiles(e.target.files,'img'));
  $('fileAudio')?.addEventListener('change', e=> ingestFiles(e.target.files,'audio'));
  $('addText')?.addEventListener('click', ()=>{ const txt=prompt('Enter text (
 separated):','Hello
World'); if(!txt) return; addGearFromMedia({type:'text', lines:txt.split(/
+/).map(s=>s.trim()).filter(Boolean), label:'Text'}); });

  function ingestFiles(files, kind){ for(const f of files){ const url=URL.createObjectURL(f); addGearFromMedia({type:kind,url,label:f.name}); } }
  function addGearFromMedia(info){ const g=makeGear({label:info.label||info.type, duration: info.type==='audio'?60:24, kind:info.type}); const ang=Math.random()*TWO_PI, d=MAIN.r+g.r+12; g.x=MAIN.x+Math.cos(ang)*d; g.y=MAIN.y+Math.sin(ang)*d; g.routed=true; let seg={type:info.type,label:info.label||info.type,w:1,offset:0,stretch:1,opacity:1,gain:0,fin:0,fout:0,blend:'source-over'}; if(info.type==='video'){ const v=document.createElement('video'); v.src=info.url; v.loop=true; v.muted=true; v.playsInline=true; v.crossOrigin='anonymous'; v.preload='metadata'; v.addEventListener('loadedmetadata',()=>{ if(Number.isFinite(v.duration)&&v.duration>1){ g.duration=Math.max(4,Math.min(240,v.duration)); g.r=durationToRadius(g.duration); recomputeTeeth(g);} }); seg.media=v; } else if(info.type==='img'){ const im=new Image(); im.src=info.url; im.crossOrigin='anonymous'; seg.media=im; g.duration=10; g.r=durationToRadius(g.duration); recomputeTeeth(g);} else if(info.type==='audio'){ const a=document.createElement('audio'); a.src=info.url; a.loop=true; a.crossOrigin='anonymous'; seg.media=a; g.duration=60; g.r=durationToRadius(g.duration); recomputeTeeth(g);} else if(info.type==='text'){ seg.lines=info.lines&&info.lines.length?info.lines:['Hello','World']; g.duration=Math.max(6, seg.lines.length*2); g.r=durationToRadius(g.duration); recomputeTeeth(g);} g.seq=[seg]; normalizeWeights(g); state.gears.push(g); state.selected=g.id; showQuickBar(g); syncChips(); }
  function normalizeWeights(g){ const s=g.seq; let sum=s.reduce((a,b)=>a+(b.w??1),0)||1; s.forEach(x=>x.w=(x.w??1)/sum); }

  // ---- interactions (move/rotate + long-press => quick bar)
  let pointer={down:false,id:-1,x:0,y:0,target:null,mode:'move',startA:0,holdTimer:0};
  function gearAt(x,y){ for(let i=state.gears.length-1;i>=0;i--){ const g=state.gears[i]; if(Math.hypot(x-g.x,y-g.y)<=g.r+18) return g; } return null; }

  // two-finger tap → toggle zen
  let activePointers=new Set(); let multiTapTimer=null; let multiTapCount=0;
  function toggleZen(){ state.zen=!state.zen; document.body.classList.toggle('zen', state.zen); syncChips(); }

  canvas.addEventListener('pointerdown', e=>{
    canvas.setPointerCapture(e.pointerId); activePointers.add(e.pointerId);
    const x=e.clientX,y=e.clientY; pointer.down=true; pointer.id=e.pointerId; pointer.x=x; pointer.y=y; const g=gearAt(x,y); pointer.target=g; if(g){ state.selected=g.id; const d=Math.hypot(x-g.x,y-g.y); pointer.mode = Math.abs(d-g.r)<14? 'rotate':'move'; pointer.startA = Math.atan2(y-g.y,x-g.x) - g.angle; pointer.holdTimer=setTimeout(()=>{ showQuickBar(g,x,y); }, 500); } else { hideQuickBar(); }
  });
  canvas.addEventListener('pointermove', e=>{ if(!pointer.down||!pointer.target) return; clearTimeout(pointer.holdTimer); const g=pointer.target; const x=e.clientX,y=e.clientY; if(pointer.mode==='move'){ g.x=x; g.y=y; // snap to tangency
      const dx=g.x-MAIN.x, dy=g.y-MAIN.y; const dist=Math.hypot(dx,dy); const desired=g.r+MAIN.r; if(Math.abs(dist-desired)<18){ const u=1/dist; g.x=MAIN.x+dx*u*desired; g.y=MAIN.y+dy*u*desired; if(!g.meshed){ g.meshed=true; hapPerfect(); } } else g.meshed=false; positionQuickBar(g); }
    else{ const ang = Math.atan2(y-g.y,x-g.x)-pointer.startA; const dAng=mod(ang-g.angle,TWO_PI); g.angle+=dAng; if(g!==MAIN && g.meshed){ MAIN.angle += -(g.r/MAIN.r)*dAng; } }
  });
  canvas.addEventListener('pointerup', e=>{ pointer.down=false; clearTimeout(pointer.holdTimer); activePointers.delete(e.pointerId); // detect two-finger quick tap
    if(activePointers.size===0 && e.width===1 && e.height===1){ if(e.pointerType==='touch'){ multiTapCount++; clearTimeout(multiTapTimer); multiTapTimer=setTimeout(()=>{ if(multiTapCount>=2) toggleZen(); multiTapCount=0; }, 220); } }
  });
  canvas.addEventListener('pointercancel', e=>{ pointer.down=false; clearTimeout(pointer.holdTimer); activePointers.delete(e.pointerId); });

  // ---- quick bar
  function showQuickBar(g, x=g.x, y=g.y){ positionQuickBar(g,x,y); qbar.classList.remove('hidden'); }
  function hideQuickBar(){ qbar.classList.add('hidden'); }
  function positionQuickBar(g,x=g.x,y=g.y){ const r= g.r+16; const px = clamp(x + 0, 10, innerWidth-10); const py= clamp(y - r - 10, 10, innerHeight-10); qbar.style.left=px+'px'; qbar.style.top=py+'px'; }
  $('qbRoute').onclick=()=>{ const g=selectedGear(); if(!g) return; g.routed=!g.routed; beep(500,.02); };
  $('qbDur-').onclick=()=>{ const g=selectedGear(); if(!g) return; g.duration=Math.max(2,g.duration-2); g.r=durationToRadius(g.duration); recomputeTeeth(g); positionQuickBar(g); };
  $('qbDur+').onclick=()=>{ const g=selectedGear(); if(!g) return; g.duration=Math.min(240,g.duration+2); g.r=durationToRadius(g.duration); recomputeTeeth(g); positionQuickBar(g); };
  $('qbText').onclick=()=>{ const g=selectedGear(); if(!g) return; g.seq.push({type:'text',label:'Text',lines:['Hello','World'],w:1,offset:0,stretch:1,opacity:1,gain:0,fin:0,fout:0,blend:'source-over'}); normalizeWeights(g); };
  $('qbDel').onclick=()=>{ const g=selectedGear(); if(!g||g===MAIN) return; state.gears = state.gears.filter(x=>x!==g); hideQuickBar(); };
  function selectedGear(){ return state.gears.find(g=>g.id===state.selected)||MAIN; }

  // ---- stage & draw
  const overlayPulse={t:0};
  function phaseFromAngle(a,quant){ let p=mod(a,TWO_PI)/TWO_PI; if(quant&&quant!=='off'){ const q=quant===60?60:quant===12?12:0; if(q){ p=Math.round(p*q)/q; } } return p; }
  function activeRouted(){ const routed=state.gears.filter(g=>g.routed); if(routed.length===0) return MAIN; const meshed=routed.filter(g=>g===MAIN||g.meshed); if(meshed.length===0) return routed[0]; meshed.sort((a,b)=>a.r-b.r); return meshed[0]; }
  function resolveSeg(g,phase){ const arr=g.seq; let acc=0; for(const s of arr){ const w=s.w??1; if(phase>=acc && phase<acc+w){ const local=(phase-acc)/w; return {seg:s,local}; } acc+=w; } return {seg:arr[arr.length-1], local:1}; }
  function drawCover(media){ const sw=stage.width, sh=stage.height; const mw=media.videoWidth||media.naturalWidth||sw, mh=media.videoHeight||media.naturalHeight||sh; const s=Math.max(sw/mw, sh/mh); const dw=Math.floor(mw*s), dh=Math.floor(mh*s); const dx=Math.floor((sw-dw)/2), dy=Math.floor((sh-dh)/2); sctx.drawImage(media,dx,dy,dw,dh); }
  function drawText(lines){ sctx.save(); sctx.fillStyle='#eae7df'; sctx.textAlign='center'; let fs=Math.floor(stage.height/16); sctx.font=`700 ${fs}px system-ui, sans-serif`; const maxW=Math.floor(stage.width*.84); while(lines.some(L=>sctx.measureText(L).width>maxW)&&fs>12){ fs-=2; sctx.font=`700 ${fs}px system-ui, sans-serif`; } let y=(stage.height-(lines.length*(fs*1.3)))/2+fs; for(const ln of lines){ sctx.fillText(ln, stage.width/2, y); y+=fs*1.3; } sctx.restore(); }
  function drawStage(){ sctx.clearRect(0,0,stage.width,stage.height); sctx.fillStyle='#000'; sctx.fillRect(0,0,stage.width,stage.height); const g=activeRouted(); const p=phaseFromAngle(g.angle, g.quant); const {seg:s,local}=resolveSeg(g,p); const dur=g.duration*(s.stretch||1); const t=((s.offset||0)+local*dur) % ((s.media&&s.media.duration)||dur||1000); sctx.globalCompositeOperation=s.blend||'source-over'; sctx.globalAlpha=(s.opacity??1); if(s.type==='video'&&s.media&&s.media.readyState>=2){ try{s.media.currentTime=t;}catch(_){} drawCover(s.media);} else if(s.type==='img'&&s.media&&s.media.complete){ drawCover(s.media);} else if(s.type==='text'){ drawText(s.lines||['Text']); } else if(s.type==='audio'&&s.media){ try{s.media.volume=clamp(Math.pow(10,(s.gain||0)/20),0,1); if(Math.abs((s.media.currentTime||0)-t)>0.1) s.media.currentTime=t;}catch(_){} }
    ctx.drawImage(stage, stageRect.x, stageRect.y, stageRect.w, stageRect.h);
  }
  function drawGear(g){ ctx.save(); ctx.translate(g.x,g.y); ctx.fillStyle='#0f141c'; ctx.strokeStyle='#223040'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,g.r,0,TWO_PI); ctx.fill(); ctx.stroke(); // ticks
    ctx.strokeStyle='#314357'; ctx.lineWidth=1; const step=TWO_PI/Math.max(12,g.teeth); for(let i=0;i<g.teeth;i++){ const a=i*step+g.angle; ctx.beginPath(); ctx.moveTo(Math.cos(a)*g.r,Math.sin(a)*g.r); ctx.lineTo(Math.cos(a)*(g.r+6),Math.sin(a)*(g.r+6)); ctx.stroke(); }
    ctx.fillStyle = (state.selected===g.id)?'#d8f3ff':'#cfd7e3'; ctx.font='600 12px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText(`${g.label}${g===MAIN?' (MAIN)':''}`,0,6); ctx.restore(); }
  function drawBG(){ ctx.fillStyle='#0b0c10'; ctx.fillRect(0,0,view.w,view.h); ctx.save(); ctx.strokeStyle='#121921'; ctx.lineWidth=1; for(let y=0;y<view.h;y+=32){ ctx.beginPath(); ctx.moveTo(0,y+.5); ctx.lineTo(view.w,y+.5); ctx.stroke(); } for(let x=0;x<view.w;x+=32){ ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,view.h); ctx.stroke(); } ctx.restore(); }

  function draw(){ drawBG(); // connections
    for(const g of state.gears){ if(g===MAIN) continue; if(g.meshed){ const v=Math.atan2(g.y-MAIN.y,g.x-MAIN.x); const mx=MAIN.x+Math.cos(v)*MAIN.r, my=MAIN.y+Math.sin(v)*MAIN.r; const gx=g.x-Math.cos(v)*g.r, gy=g.y-Math.sin(v)*g.r; ctx.strokeStyle='#2fd87f'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(gx,gy); ctx.stroke(); } }
    for(const g of state.gears){ drawGear(g); }
    drawStage(); if(overlayPulse.t>0){ overlayPulse.t-=16; ctx.save(); ctx.translate(view.cx,view.cy); ctx.strokeStyle=`hsla(180,80%,60%,${overlayPulse.t/260})`; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(0,0, MAIN.r+30, 0, TWO_PI); ctx.stroke(); ctx.restore(); }
  }

  function tick(){ const t=performance.now(); const dt=Math.min(.05, (t-state.lastT)/1000); state.lastT=t; const main=MAIN; const base= state.bpm? ((60/state.bpm)*4) : main.duration; main.omega = TWO_PI/base; const prev=main.angle; if(state.playing) main.angle=mod(main.angle+main.omega*dt, TWO_PI); if(Math.floor(prev/(TWO_PI/MINOR_DIV))!==Math.floor(main.angle/(TWO_PI/MINOR_DIV))) hapMinor(); if(Math.floor(prev/(TWO_PI/MAJOR_DIV))!==Math.floor(main.angle/(TWO_PI/MAJOR_DIV))) hapMajor(); for(const g of state.gears){ if(g===main) continue; if(g.meshed){ g.omega = - main.omega * (main.r / g.r) * g.throttle; if(state.playing) g.angle = mod(g.angle + g.omega*dt, TWO_PI); } }
    draw(); requestAnimationFrame(tick); }
  requestAnimationFrame(tick);

  // keyboard for fallback
  window.addEventListener('keydown', e=>{ if(e.key===' '){ e.preventDefault(); mPlay.click(); } else if(e.key==='z'||e.key==='Z'){ toggleZen(); } });

  // start in zen
  document.body.classList.toggle('zen', true); syncChips();
})();
</script>
</body>
</html>
