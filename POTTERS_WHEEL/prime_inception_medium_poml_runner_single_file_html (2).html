<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Prime Inception Medium — POML Runner</title>
<style>
  :root{
    --bg0:#05070b; --bg1:#0a0f15; --ink:#e8e6df; --muted:#94a3b8; --accent:#00d0b4;
  }
  *{box-sizing:border-box;}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% -10%, var(--bg1), var(--bg0));color:var(--ink);font:14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;}
  /* CENTER EXPERIENCE: one fullscreen canvas, minimal HUD */
  #c{display:block;width:100vw;height:100vh;touch-action:none;background:radial-gradient(60vmax 60vmax at 50% 50%, #0b1118 0%, #070b10 70%, #05070b 100%);}  
  .hud{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);display:flex;gap:.5rem;padding:.4rem .5rem;background:#0b1118cc;border:1px solid #13202b;border-radius:12px;backdrop-filter:blur(6px)}
  .btn{appearance:none;border:1px solid #1e2a36;background:#0e141c;color:var(--ink);padding:.45rem .7rem;border-radius:10px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .tiny{position:fixed;left:12px;top:10px;color:#b9c6d2;font-size:12px;opacity:.75}
  .toast{position:fixed;left:50%;top:10%;transform:translate(-50%, -50%);padding:.4rem .6rem;border-radius:8px;background:#0f1a24cc;border:1px solid #1a2a38;font-size:12px;color:#cfe3ff;pointer-events:none;opacity:0;transition:opacity .18s ease-out}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud" id="hud">
    <button class="btn" id="play">Play</button>
    <button class="btn" id="pause">Pause</button>
    <button class="btn" id="addArc">Add Arc</button>
    <button class="btn" id="clearArc">Clear Arcs</button>
    <button class="btn" id="record">Record</button>
  </div>
  <div class="tiny" id="hint">Drag = spin · Pinch = zoom · Double‑tap = toggle HUD</div>
  <div class="toast" id="toast">contact</div>
<script>
/* ===== CENTERED GEAR ENGINE (minimal, tactile) ===== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');
const toast = document.getElementById('toast');
const S = {
  playing:true,
  zoom:1,
  last:performance.now(),
  t:0,
  // gear model: main centered, outer meshed to the right
  main:{r:140, teeth:24, angle:0, arcs:[]},
  outer:{r:90, teeth:18, angle:0, ratio: 24/18, arcs:[]},
  // export
  rec:{active:false, mr:null, chunks:[]}
};

/* ===== Helpers ===== */
function fit(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = Math.max(10, canvas.clientWidth || innerWidth);
  const h = Math.max(10, canvas.clientHeight || innerHeight);
  canvas.width = w*dpr; canvas.height = h*dpr; ctx.setTransform(dpr,0,0,dpr,0,0);
}
function vibe(ms=18){ if(navigator.vibrate) navigator.vibrate(ms); }
function ping(freq=880, dur=0.04, type='square'){
  try{ S.ac||(S.ac=new (window.AudioContext||window.webkitAudioContext)());
       const ac=S.ac, o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=0.05; o.connect(g); g.connect(ac.destination); o.start(); setTimeout(()=>o.stop(), dur*1000);
  }catch(_){}
}
function flash(msg){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),120); }

/* ===== Draw ===== */
function draw(){
  fit();
  const W = canvas.width / (window.devicePixelRatio||1);
  const H = canvas.height / (window.devicePixelRatio||1);
  ctx.clearRect(0,0,W,H);
  const cx=W/2, cy=H/2; // CENTER EXPERIENCE

  // backdrop vignette rings
  for(let i=0;i<6;i++){ ctx.beginPath(); ctx.arc(cx,cy,(i+1)*80*S.zoom,0,Math.PI*2); ctx.strokeStyle=`rgba(0,208,180,${0.04-i*0.005})`; ctx.lineWidth=1; ctx.stroke(); }

  // positions
  const main = S.main; const outer = S.outer;
  const meshGap = 6; // small slack so teeth are visible
  const ox = cx + (main.r + outer.r - meshGap)*S.zoom; const oy = cy;

  drawGear(cx, cy, main.r*S.zoom, main.teeth, main.angle, '#2dd4bf');
  drawGear(ox, oy, outer.r*S.zoom, outer.teeth, outer.angle, '#5fb3ff');

  // arcs
  drawArcs(cx, cy, main.r*S.zoom, main.arcs, '#00d0b4');
  drawArcs(ox, oy, outer.r*S.zoom, outer.arcs, '#5fb3ff');

  // axle
  ctx.fillStyle='#0b1118'; ctx.strokeStyle:'#2a3a48';
  ctx.beginPath(); ctx.arc(cx,cy,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.arc(ox,oy,8,0,Math.PI*2); ctx.fill(); ctx.stroke();
}

function drawGear(cx, cy, r, teeth, angle, stroke){
  const root = r*0.82, tip = r, toothW = (Math.PI*2)/teeth;
  ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle);
  // body
  ctx.beginPath(); ctx.arc(0,0,root,0,Math.PI*2); ctx.fillStyle='#0d141c'; ctx.fill();
  // teeth
  ctx.beginPath();
  for(let i=0;i<teeth;i++){
    const a = i*toothW; const w = toothW*0.44;
    const a1 = a - w/2, a2 = a + w/2;
    ctx.moveTo(Math.cos(a1)*root, Math.sin(a1)*root);
    ctx.lineTo(Math.cos(a1)*tip,  Math.sin(a1)*tip);
    ctx.lineTo(Math.cos(a2)*tip,  Math.sin(a2)*tip);
    ctx.lineTo(Math.cos(a2)*root, Math.sin(a2)*root);
    ctx.closePath();
  }
  ctx.fillStyle='#13202b'; ctx.fill();
  ctx.strokeStyle=stroke; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,tip,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}
function drawArcs(cx, cy, r, arcs, color){
  ctx.save(); ctx.translate(cx,cy); ctx.lineWidth=6; ctx.lineCap='round'; ctx.strokeStyle=color;
  for(const a of arcs){ ctx.beginPath(); ctx.arc(0,0,r, a.start, a.end); ctx.stroke(); }
  ctx.restore();
}

/* ===== Sim & Contacts ===== */
function tick(now){
  const dt = Math.min(50, now - S.last); S.last = now; if(S.playing) S.t += dt;
  const base = 0.0015 * (S.playing?1:0);
  S.main.angle += base*dt; // clockwise
  S.outer.angle -= base*dt * (S.main.teeth/S.outer.teeth); // counter, meshed
  // contact when tooth indices align and both arcs active
  const mIdx = Math.round((S.main.angle%(2*Math.PI))/(2*Math.PI)*S.main.teeth);
  const oIdx = Math.round(((-S.outer.angle)%(2*Math.PI))/(2*Math.PI)*S.outer.teeth);
  if((mIdx%S.main.teeth)===(oIdx%S.outer.teeth) && angleInArcs(S.main.angle,S.main.arcs) && angleInArcs(-S.outer.angle,S.outer.arcs)){
    if(!S._lastContact || now - S._lastContact > 60){
      S._lastContact = now; vibe(10); ping(980,.03,'square'); flash('contact');
    }
  }
  draw(); requestAnimationFrame(tick);
}
function angleInArcs(angle, arcs){
  const a=((angle%(2*Math.PI))+2*Math.PI)%(2*Math.PI);
  for(const seg of arcs){
    const s=((seg.start%(2*Math.PI))+2*Math.PI)%(2*Math.PI);
    const e=((seg.end%(2*Math.PI))+2*Math.PI)%(2*Math.PI);
    if(s<=e){ if(a>=s && a<=e) return true; } else { if(a>=s || a<=e) return true; }
  } return false;
}

/* ===== Interaction ===== */
let pinchBase=null, dragging=false, lastX=0;
canvas.addEventListener('pointerdown', e=>{ canvas.setPointerCapture(e.pointerId); dragging=true; lastX=e.clientX; });
canvas.addEventListener('pointermove', e=>{ if(dragging){ const dx=e.clientX-lastX; lastX=e.clientX; S.main.angle += dx*0.01; /* direct spin */ }});
canvas.addEventListener('pointerup', ()=> dragging=false);
canvas.addEventListener('wheel', e=>{ e.preventDefault(); S.zoom = Math.max(0.5, Math.min(2.5, S.zoom + (e.deltaY<0?0.05:-0.05))); draw(); }, {passive:false});
canvas.addEventListener('dblclick', ()=> hud.style.display = (hud.style.display==='none'?'flex':'none'));

// simple touch pinch
const pts=new Map();
canvas.addEventListener('pointerdown', e=>{ pts.set(e.pointerId,{x:e.clientX,y:e.clientY}); });
canvas.addEventListener('pointermove', e=>{
  const p = pts.get(e.pointerId); if(!p) return; p.x=e.clientX; p.y=e.clientY;
  if(pts.size===2){ const a=[...pts.values()], d=Math.hypot(a[0].x-a[1].x,a[0].y-a[1].y); if(!pinchBase) pinchBase=d; const s = (d/pinchBase); S.zoom = Math.max(0.5, Math.min(2.5, s)); draw(); }
});
canvas.addEventListener('pointerup', e=>{ pts.delete(e.pointerId); if(pts.size<2) pinchBase=null; });

/* HUD actions */
document.getElementById('play').onclick=()=>{ S.playing=true; vibe(10); ping(660,.04,'square'); };
document.getElementById('pause').onclick=()=>{ S.playing=false; vibe(8); ping(440,.04,'square'); };
document.getElementById('addArc').onclick=()=>{
  const span=Math.PI/10; S.main.arcs.push({start:S.main.angle-span,end:S.main.angle+span}); S.outer.arcs.push({start:-S.outer.angle-span,end:-S.outer.angle+span}); vibe(12); ping(720,.04,'triangle');
};
document.getElementById('clearArc').onclick=()=>{ S.main.arcs.length=0; S.outer.arcs.length=0; vibe(8); ping(320,.04,'sine'); };

// Recording of canvas (clean)
const recBtn=document.getElementById('record');
recBtn.onclick=()=>{ if(S.rec.active){ S.rec.mr.stop(); } else { startRec(); } };
function startRec(){ try{
  const stream = canvas.captureStream(30); const mr = new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9'});
  S.rec={active:true,mr,chunks:[]}; mr.ondataavailable=e=>{ if(e.data.size>0) S.rec.chunks.push(e.data); };
  mr.onstop=()=>{ const blob=new Blob(S.rec.chunks,{type:'video/webm'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='center-gear.webm'; a.click(); S.rec.active=false; S.rec.chunks=[]; };
  mr.start(); vibe(12); ping(1040,.04,'square');
}catch(e){ flash('recording not supported'); }}

/* Seed arcs for immediate contacts */
(function seed(){ const span=Math.PI/8; S.main.arcs.push({start:0,end:span}); S.outer.arcs.push({start:0,end:span}); })();

/* Boot */
fit(); draw(); requestAnimationFrame(tick);
</script>
</body>
</html>
