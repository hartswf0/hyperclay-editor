<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Hyperclay — Wheel Core</title>
  <style>
    :root{ --bg:#07090d; --ink:#eae7df; --muted:#9aa0a6; --gold:#caa24a; --ring:#14202b; }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #root{position:fixed;inset:0}
    canvas{width:100%;height:100%;display:block;touch-action:none}
    /* Minimal center CTA */
    .centerCTA{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);background:#0b0f16bf;border:1px solid #1b2230;border-radius:999px;padding:1rem 1.1rem;font-weight:800;letter-spacing:.06em}
    .fab{position:absolute;bottom:14px;right:14px;background:#111824;border:1px solid #1b2230;border-radius:999px;padding:.7rem .9rem;font-weight:800}
    .fabL{left:14px;right:auto}
    input[type=file]{display:none}
  </style>
</head>
<body>
  <div id="root">
    <canvas id="c"></canvas>
    <button id="cta" class="centerCTA">TAP TO LOAD CLIPS</button>
    <button id="play" class="fab">▶︎</button>
    <button id="rec" class="fab fabL">●</button>
    <input id="pick" type="file" accept="video/*" multiple>
  </div>
  <div id="bucket" style="display:none"></div>

  <script>
  // ===== WHEEL CORE — everything centered =====
  const c=document.getElementById('c'), ctx=c.getContext('2d');
  const CTA=document.getElementById('cta');
  const PLAY=document.getElementById('play');
  const REC=document.getElementById('rec');
  const PICK=document.getElementById('pick');
  const bucket=document.getElementById('bucket');

  let W=0,H=0, DPR=Math.min(2, devicePixelRatio||1);
  function fit(){ const r=c.getBoundingClientRect(); W=r.width*DPR; H=r.height*DPR; c.width=W; c.height=H; drawWheel(); }
  addEventListener('resize', fit); fit();

  // Wheel state
  const wheel={ angle:0, omega:0, friction:0.985, radius:0.36, pressure:0.0, ticks:24 };

  // Touch state (centered)
  const touches=new Map(); let dragging=false, lastAngle=0, lastTime=0; let hapticTick=0;
  c.addEventListener('pointerdown',e=>{ c.setPointerCapture(e.pointerId); const p=pt(e); touches.set(e.pointerId,p); startGesture(p); if(navigator.vibrate) navigator.vibrate(8); });
  c.addEventListener('pointermove',e=>{ if(!touches.has(e.pointerId)) return; const p=pt(e); touches.set(e.pointerId,p); moveGesture(p); });
  c.addEventListener('pointerup',e=>{ touches.delete(e.pointerId); endGesture(); });
  c.addEventListener('pointercancel',e=>{ touches.delete(e.pointerId); endGesture(); });
  function pt(e){ const r=c.getBoundingClientRect(); return {x:(e.clientX-r.left)*DPR, y:(e.clientY-r.top)*DPR, pressure:e.pressure||0, t:performance.now()}; }

  function startGesture(p){ dragging=true; lastAngle=ang(p); lastTime=p.t; // build pressure if no hardware
    if(!p.pressure){ const start=p.t; const id=setInterval(()=>{ if(!dragging){ clearInterval(id); return;} const t=performance.now(); wheel.pressure=Math.min(1, (t-start)/800); }, 40); }
  }
  function moveGesture(p){ if(!dragging) return; const a=ang(p); let da=a-lastAngle; if(da>Math.PI) da-=2*Math.PI; if(da<-Math.PI) da+=2*Math.PI; const dt=(p.t-lastTime)/1000; wheel.omega += (da/dt)*0.06; lastAngle=a; lastTime=p.t; wheel.pressure=Math.max(wheel.pressure*0.95, p.pressure||0);
    // two-finger pinch adjusts radius directly from average distance
    if(touches.size>=2){ const [p1,p2]=[...touches.values()]; const cx=W/2, cy=H/2; const d1=Math.hypot(p1.x-cx,p1.y-cy), d2=Math.hypot(p2.x-cx,p2.y-cy); const avg=(d1+d2)/2; const target=Math.max(0.26, Math.min(0.48, avg/Math.min(W,H))); wheel.radius += (target-wheel.radius)*0.25; }
  }
  function endGesture(){ dragging=false; }
  function ang(p){ const cx=W/2, cy=H/2; return Math.atan2(p.y-cy, p.x-cx); }

  // Blobs
  const blobs=[]; // {video, theta, r, cx,cy, nodes, gain, enabled}
  function makeBlob(video){ const theta=Math.random()*Math.PI*2; const r=Math.min(W,H)*0.16; const n=20, nodes=[]; const cx=W/2 + Math.cos(theta)*Math.min(W,H)*wheel.radius; const cy=H/2 + Math.sin(theta)*Math.min(W,H)*wheel.radius; for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; nodes.push({x:cx+r*Math.cos(a), y:cy+r*Math.sin(a), vx:0,vy:0, ox:Math.cos(a), oy:Math.sin(a)}); } return {video, theta, r, cx, cy, nodes, gain:null, enabled:true}; }

  // Audio
  let AC=null, mix=null, mediaDest=null; let recording=false, recorder=null, chunks=[];
  async function ensureAudio(){ if(AC) return; const Ctx=window.AudioContext||window.webkitAudioContext; if(!Ctx) return; AC=new Ctx(); mix=AC.createGain(); mix.gain.value=0.9; mix.connect(AC.destination); mediaDest=AC.createMediaStreamDestination(); mix.connect(mediaDest); blobs.forEach(b=>{ try{const src=AC.createMediaElementSource(b.video); const g=AC.createGain(); g.gain.value=0; src.connect(g).connect(mix); b.gain=g;}catch{} }); }

  // Loader (centered)
  CTA.onclick = ()=> PICK.click();
  c.addEventListener('dblclick', ()=> PICK.click()); // fallback gesture to load
  PICK.addEventListener('change', async (e)=>{ const list=Array.from(e.target.files||[]); for(const f of list){ await addClip(f); } CTA.style.display='none'; if(blobs.length) PLAY.click(); });
  async function addClip(file){ const url=URL.createObjectURL(file); const v=document.createElement('video'); v.src=url; v.muted=true; v.playsInline=true; v.loop=true; v.preload='metadata'; v.crossOrigin='anonymous'; bucket.appendChild(v); await v.play().catch(()=>{}); v.pause(); const b=makeBlob(v); blobs.push(b); }

  // Transport buttons (tiny, corner)
  let running=false; PLAY.onclick=async ()=>{ await ensureAudio(); if(!running){ blobs.forEach(b=>b.video.play().catch(()=>{})); running=true; PLAY.textContent='⏸︎'; loop(); if(AC&&AC.state==='suspended') AC.resume(); } else { blobs.forEach(b=>b.video.pause()); running=false; PLAY.textContent='▶︎'; cancelAnimationFrame(_raf); draw(); } };
  REC.onclick=async ()=>{ if(!recording){ await ensureAudio(); const vstream=c.captureStream(30); let stream=vstream; if(mediaDest){ const a=mediaDest.stream.getAudioTracks()[0]; if(a) stream=new MediaStream([vstream.getVideoTracks()[0], a]); } chunks=[]; recorder=new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9'}); recorder.ondataavailable=e=>{ if(e.data&&e.data.size) chunks.push(e.data); }; recorder.onstop=()=>{ const blob=new Blob(chunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='hyperclay_core.webm'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),4000); }; recorder.start(120); recording=true; REC.textContent='■'; if(!running) PLAY.click(); } else { recording=false; REC.textContent='●'; recorder?.stop(); } };

  // Physics
  const VISC=0.965, STIFF=12, REPULSE=14000, TOUCH_FORCE=26000; const EDGE=0.84; let baseT=0;
  function step(dt){ wheel.angle += wheel.omega*dt; wheel.omega *= wheel.friction; baseT += wheel.omega*dt*0.25; // haptic ticks on markers
    const tick = Math.round((wheel.angle%(2*Math.PI))*(wheel.ticks/(2*Math.PI))); if(tick!==hapticTick){ if(navigator.vibrate) navigator.vibrate(2); hapticTick=tick; }
    const cx=W/2, cy=H/2, R=Math.min(W,H)*wheel.radius;
    for(const b of blobs){ if(!b.enabled) continue; // place on rim
      b.cx = cx + Math.cos(b.theta+wheel.angle)*R; b.cy = cy + Math.sin(b.theta+wheel.angle)*R; // ring springs
      const ns=b.nodes; const n=ns.length; const pr = 1 - 0.12*wheel.pressure; b.r = Math.max(60, Math.min(Math.min(W,H)*0.28, Math.min(W,H)*0.16*pr));
      for(let i=0;i<n;i++){ const p=ns[i]; const a=Math.atan2(p.oy,p.ox); const tx=b.cx + b.r*Math.cos(a), ty=b.cy + b.r*Math.sin(a); p.vx += (tx-p.x)*STIFF*dt; p.vy += (ty-p.y)*STIFF*dt; if(p.x<(1-EDGE)*W) p.vx += ((1-EDGE)*W-p.x)*40*dt; if(p.x>EDGE*W) p.vx += (EDGE*W-p.x)*40*dt; if(p.y<(1-EDGE)*H) p.vy += ((1-EDGE)*H-p.y)*40*dt; if(p.y>EDGE*H) p.vy += (EDGE*H-p.y)*40*dt; }
    }
    // Interactions
    const rep = REPULSE*(1+2*wheel.pressure); for(let i=0;i<blobs.length;i++) for(let j=i+1;j<blobs.length;j++){ const A=blobs[i], B=blobs[j]; if(!A.enabled||!B.enabled) continue; const dx=B.cx-A.cx, dy=B.cy-A.cy; const d=Math.hypot(dx,dy)+1e-3; const push=(rep/(d*d)); const fx=push*dx/d, fy=push*dy/d; for(const p of A.nodes){ p.vx -= fx*dt/A.nodes.length; p.vy -= fy*dt/A.nodes.length; } for(const p of B.nodes){ p.vx += fx*dt/B.nodes.length; p.vy += fy*dt/B.nodes.length; } }
    // Drag nearest lump by rim angle
    touches.forEach(t=>{ const a=ang(t); let best=null, bestDiff=1e9; for(const b of blobs){ const diff=angleDiff(a, b.theta+wheel.angle); if(diff<bestDiff){ bestDiff=diff; best=b; } } if(best && bestDiff<0.5){ best.theta += (a - (best.theta+wheel.angle))*0.25; } for(const b of blobs){ for(const p of b.nodes){ const dx=t.x-p.x, dy=t.y-p.y; const d2=dx*dx+dy*dy+1; const f=TOUCH_FORCE/d2; p.vx += f*dx*dt; p.vy += f*dy*dt; } });
    for(const b of blobs){ for(const p of b.nodes){ p.vx*=VISC; p.vy*=VISC; p.x+=p.vx*dt*60; p.y+=p.vy*dt*60; } }
    wheel.pressure *= 0.985;
  }
  function angleDiff(a,b){ let d=a-b; if(d>Math.PI) d-=2*Math.PI; if(d<-Math.PI) d+=2*Math.PI; return Math.abs(d); }

  // Edge fog + noise masks (fixed defaults)
  const noiseTex=document.createElement('canvas'); const nctx=noiseTex.getContext('2d');
  function makeNoise(size=256){ noiseTex.width=noiseTex.height=size; const img=nctx.createImageData(size,size); const d=img.data; for(let y=0;y<size;y++){ for(let x=0;x<size;x++){ const i=(y*size+x)*4; const v=(Math.random()*255)|0; d[i]=d[i+1]=d[i+2]=v; d[i+3]=255; } } nctx.putImageData(img,0,0); }
  makeNoise(256);
  const off=document.createElement('canvas'); const offctx=off.getContext('2d');
  const FOG=0.58, NOISE=0.55;
  function drawBlob(b, alpha){ const v=b.video; if(v.readyState<2) return; const vw=v.videoWidth||W, vh=v.videoHeight||H; const s=(2*b.r)/Math.min(vw,vh); const dw=vw*s, dh=vh*s; const bx=b.cx-dw/2, by=b.cy-dh/2; off.width=Math.ceil(dw); off.height=Math.ceil(dh); offctx.clearRect(0,0,off.width,off.height); offctx.drawImage(v,0,0,dw,dh); const g=offctx.createRadialGradient(dw/2,dh/2,Math.max(1,(1-FOG)*Math.min(dw,dh)/2),dw/2,dh/2,Math.min(dw,dh)/2); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)'); offctx.globalCompositeOperation='destination-in'; offctx.fillStyle=g; offctx.fillRect(0,0,dw,dh); offctx.globalCompositeOperation='destination-in'; offctx.globalAlpha=0.35*NOISE; const tile=noiseTex; const rx=Math.ceil(dw/tile.width)+1, ry=Math.ceil(dh/tile.height)+1; for(let y=0;y<ry;y++){ for(let x=0;x<rx;x++){ offctx.drawImage(tile,(x-0.5)*tile.width + (performance.now()*0.02%tile.width),(y-0.5)*tile.height,tile.width,tile.height); } } ctx.globalAlpha=alpha; ctx.drawImage(off,bx,by); }

  function drawWheel(){ ctx.clearRect(0,0,W,H); ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); const cx=W/2, cy=H/2, r=Math.min(W,H)*wheel.radius; ctx.save(); ctx.strokeStyle='rgba(202,162,74,.33)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); // hub
    ctx.fillStyle='rgba(202,162,74,.15)'; ctx.beginPath(); ctx.arc(cx,cy, r*0.25, 0, Math.PI*2); ctx.fill(); // ticks
    for(let i=0;i<wheel.ticks;i++){ const a=i*(Math.PI*2/wheel.ticks)+wheel.angle; const x1=cx+(r-10)*Math.cos(a), y1=cy+(r-10)*Math.sin(a); const x2=cx+(r+10)*Math.cos(a), y2=cy+(r+10)*Math.sin(a); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
    ctx.restore(); }

  function draw(){ ctx.clearRect(0,0,W,H); ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); drawWheel(); const alphas=blobs.map(_=>0.85); for(let i=0;i<blobs.length;i++) for(let j=i+1;j<blobs.length;j++){ const A=blobs[i], B=blobs[j]; if(!A.enabled||!B.enabled) continue; const d=Math.hypot(A.cx-B.cx, A.cy-B.cy); const overlap=Math.max(0,(A.r+B.r)-d); const boost=Math.min(0.6, overlap/Math.max(A.r,B.r)); alphas[i]+=boost*0.5; alphas[j]+=boost*0.5; } const order=blobs.map((b,i)=>({i,a:alphas[i]})).sort((A,B)=>A.a-B.a).map(o=>o.i); ctx.globalCompositeOperation='screen'; for(const idx of order){ const b=blobs[idx]; if(!b.enabled) continue; try{ const t0=(blobs[0]?.video.currentTime)||0; const target=Math.max(0, t0 + baseT); if(Math.abs(b.video.currentTime-target)>0.03) b.video.currentTime=target; }catch{} drawBlob(b, Math.max(0.18, Math.min(1.0, alphas[idx]))); }
  }

  let _raf=null, last=performance.now();
  function loop(){ _raf=requestAnimationFrame(loop); const t=performance.now(); let dt=(t-last)/1000; last=t; dt=Math.min(0.05,dt); step(dt); draw(); }

  // Draw the centered wheel immediately
  draw();
  </script>
</body>
</html>
