<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Hyperclay Fusion Wheel — Option 2 (All-Out POC) — Zen Tube</title>
<style>
  :root{
    --bg:#000; --ink:#eae7df; --muted:#9aa0a6; --accent:#00d0b4; --panel:#0f1319f2; --btn:#11161e; --btnb:#2a313a; --ink2:#cfd3d8;
  }
  * { box-sizing: border-box; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--ink); height:100%; }
  #app { position:fixed; inset:0; overflow:hidden; }
  canvas { position:absolute; inset:0; width:100%; height:100%; touch-action:none; background:#000; }

  .hud, .topbar { font: 600 12px/1.2 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue"; }
  .topbar {
    position:fixed; top:0; left:0; right:0; display:flex; gap:.5rem; padding:.5rem .6rem; align-items:center;
    justify-content:space-between; background:linear-gradient(180deg, rgba(0,0,0,.35), transparent);
    pointer-events:none; z-index:5;
  }
  .topbar .group { pointer-events:auto; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  .badge { padding:.25rem .5rem; border:1px solid #2a313a; border-radius:12px; background:#0c1118; color:var(--ink2); }
  .note  { font-size:11px; color:var(--muted); }
  .meter { display:inline-flex; align-items:center; gap:.35rem; }
  .bar { width:72px; height:8px; background:#0e131a; border:1px solid #24303a; border-radius:6px; overflow:hidden; }
  .bar > i { display:block; height:100%; width:0; background:linear-gradient(90deg, #2e9fff, #00d0b4); }

  .hud {
    position: fixed; left: 0; right: 0; bottom: 0; z-index:6;
    display:flex; gap:.5rem; padding:.6rem; align-items:center; justify-content:center; flex-wrap:wrap;
    background: linear-gradient(180deg, transparent, rgba(0,0,0,.35)); backdrop-filter: blur(8px);
    transition: opacity .25s;
  }
  .hud.hidden{ opacity:0; pointer-events:none; }
  button, label.btn, a.btn { border:1px solid var(--btnb); border-radius:14px; padding:.6rem .8rem; background:var(--btn); color:var(--ink); display:inline-flex; align-items:center; gap:.35rem; cursor:pointer; user-select:none; text-decoration:none; }
  button:active, label.btn:active { transform: translateY(1px); }
  button.on { outline: 1px solid var(--accent); box-shadow: 0 0 0 2px #00d0b422 inset; }
  #file, #jsonfile { display:none; }

  .toast { position:fixed; left:50%; transform:translateX(-50%); bottom:80px; z-index:20; background:#0f141b; border:1px solid #2a313a; border-radius:12px; padding:.5rem .75rem; color:var(--ink2); opacity:0; transition:opacity .25s; }
  .toast.show { opacity:1; }

  body.recording .topbar, body.recording .hud { display:none; }
</style>
</head>
<body>
<div id="app" data-mode="zen">
  <canvas id="c"></canvas>

  <div class="topbar">
    <div class="group">
      <span class="badge">Hyperclay — Zen Tube</span>
      <span class="note" id="phaseNote">phase 0.000</span>
      <span class="note" id="fpsNote">fps —</span>
      <div class="meter" title="Inertia">
        <span class="note">inertia</span>
        <span class="bar"><i id="inertiaFill" style="width:0%"></i></span>
      </div>
      <span class="badge" id="resBadge" title="Render scale">RES 1.0×</span>
      <span class="badge" id="wheelBadge" title="Wheel size factor">R 1.00×</span>
    </div>
    <div class="group"><span class="badge">No marks • Fixed viewport • Tube layout • 2‑video X‑fade</span></div>
  </div>

  <div class="hud">
    <label class="btn" for="file">Load Clips</label><input id="file" type="file" multiple accept="image/*,video/*" />
    <button id="modeSpin" class="on" title="SPIN: fling/drag to scrub time">SPIN</button>
    <button id="modeSculpt" title="SCULPT: drag near anchors (invisible)">SCULPT</button>
    <button id="playBtn" title="Play/Pause timeline">Play</button>
    <button id="lockViewBtn" class="on" title="Lock viewport (fixed camera)">Lock View</button>
    <button id="tubeBtn" class="on" title="Concentric tube layout for stamps">Tube</button>
    <button id="resBtn" title="Toggle render scale (for perf)">RES</button>
    <button id="stampBtn" title="Stamp current composite as transparent image">STAMP</button>
    <button id="undoBtn" title="Undo last change">Undo</button>
    <button id="recBtn" title="Start/Stop recording">● Record</button>
    <a id="dl" class="btn" style="display:none" download="hyperclay.webm">Download</a>
    <label class="btn" for="jsonfile" title="Import session JSON">Load JSON</label><input id="jsonfile" type="file" accept="application/json" />
    <button id="saveBtn" title="Export session JSON">Save JSON</button>
    <button id="clearBtn" title="Remove all clips">Clear</button>
    <span class="note" style="margin-left:.5rem">X‑Fade</span>
    <input id="xfade" type="range" min="0" max="1" step="0.01" value="0.50" style="width:120px" />
  </div>

  <div id="toast" class="toast">Saved</div>
</div>

<script>
(() => {
  // ==========================
  // Canvas & Resolution Control
  // ==========================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let RES_SCALE = 1.0; // cycles 1.0 → 0.8 → 0.6
  let DPR = 1;

  function computeDPR(){ DPR = Math.max(1, Math.min(2, (window.devicePixelRatio || 1) * RES_SCALE)); }
  function resize(){
    computeDPR();
    const {clientWidth:w, clientHeight:h} = canvas;
    canvas.width = Math.floor(w * DPR);
    canvas.height= Math.floor(h * DPR);
    // state is defined below; we only reference it after initialization
    if (state) { state.view.cx = canvas.width/2; state.view.cy = canvas.height/2; }
  }

  // ==========================
  // App State (define BEFORE using resize)
  // ==========================
  const state = {
    cx: () => canvas.width  * 0.5,
    cy: () => canvas.height * 0.5,
    wheelScale: 1.0,
    baseWheelR: () => Math.min(canvas.width, canvas.height) * 0.28 * state.wheelScale,
    wheelAngle: 0,
    wheelVel: 0,
    friction: 0.985,
    mode: 'SPIN',
    clips: [],
    activeClipId: null,
    history: [],
    view: { zoom: 1.0, cx: canvas.width/2, cy: canvas.height/2, locked: true },
    playing: false,
    tube: true,
    busXfade: 0.5
  };
  let nextId = 1;

  // Now that state exists, wire resize observer & perform initial resize
  new ResizeObserver(() => requestAnimationFrame(resize)).observe(canvas);
  resize();

  // ==========================
  // UI Refs
  // ==========================
  const fileInput   = document.getElementById('file');
  const jsonInput   = document.getElementById('jsonfile');
  const modeSpinBtn = document.getElementById('modeSpin');
  const modeScptBtn = document.getElementById('modeSculpt');
  const resBtn      = document.getElementById('resBtn');
  const resBadge    = document.getElementById('resBadge');
  const wheelBadge  = document.getElementById('wheelBadge');
  const stampBtn    = document.getElementById('stampBtn');
  const undoBtn     = document.getElementById('undoBtn');
  const recBtn      = document.getElementById('recBtn');
  const dlLink      = document.getElementById('dl');
  const saveBtn     = document.getElementById('saveBtn');
  const clearBtn    = document.getElementById('clearBtn');
  const phaseNote   = document.getElementById('phaseNote');
  const fpsNote     = document.getElementById('fpsNote');
  const inertiaFill = document.getElementById('inertiaFill');
  const toastEl     = document.getElementById('toast');
  const playBtn     = document.getElementById('playBtn');
  const lockViewBtn = document.getElementById('lockViewBtn');
  const tubeBtn     = document.getElementById('tubeBtn');
  const xfadeSlider = document.getElementById('xfade');
  const hud         = document.querySelector('.hud');
  const body        = document.body;

  function showToast(msg, ms=900){ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=> toastEl.classList.remove('show'), ms); }

  // Auto-hide HUD
  let hudTimer=null; function bumpHUD(){ hud.classList.remove('hidden'); clearTimeout(hudTimer); hudTimer=setTimeout(()=>hud.classList.add('hidden'), 1600); }
  window.addEventListener('mousemove', bumpHUD, {passive:true}); window.addEventListener('touchstart', bumpHUD, {passive:true}); bumpHUD();

  // History
  function snapshot(){ const snap = state.clips.map(c => ({ id:c.id, type:c.type, angle:c.angle, radius:c.radius, scale:c.scale, edge:c.edge, fog:c.fog, blend:c.blend, timeOffset:c.timeOffset, duration:c.duration, label:c.label || null, ring:c.ring||0 })); state.history.push(snap); if (state.history.length > 40) state.history.shift(); }
  function restoreSnapshot(snap){ for (const s of snap){ const c = state.clips.find(k => k.id === s.id); if (c) Object.assign(c, s); } }
  undoBtn.addEventListener('click', () => { const last = state.history.pop(); if (last){ restoreSnapshot(last); showToast('Undid'); } });

  // Add Clips
  function defaultClipBase(){ return { id: nextId++, angle: Math.random()*Math.PI*2, radius: 0, scale: 0.5, edge: 24, fog: 0.0, blend: 'source-over', timeOffset: 0, duration: 5, ring: 0 }; }
  function addImageClip(img){ state.clips.push({ ...defaultClipBase(), type:'image', el:img, kind:'img' }); snapshot(); }
  function addStampClip(img){ const ring = Math.max(0, ...state.clips.map(c=>c.ring||0)) + 1; state.clips.push({ ...defaultClipBase(), type:'stamp', el:img, kind:'img', ring }); snapshot(); }
  function addVideoClip(video, duration=5){ state.clips.push({ ...defaultClipBase(), type:'video', el:video, kind:'video', duration: duration||5 }); snapshot(); }
  function addPlaceholder(label){ state.clips.push({ ...defaultClipBase(), type:'placeholder', label, kind:'placeholder', duration:5, scale:0.6 }); }

  fileInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []);
    for (const f of files){
      if (f.type.startsWith('image/')){ const url = URL.createObjectURL(f); const img = new Image(); await new Promise(res => { img.onload = res; img.src = url; }); addImageClip(img); }
      else if (f.type.startsWith('video/')){ const url = URL.createObjectURL(f); const vid = document.createElement('video'); vid.src = url; vid.preload='auto'; vid.loop=true; vid.muted=true; vid.playsInline=true; await vid.play().catch(()=>{}); vid.pause(); const duration = isFinite(vid.duration) ? vid.duration : 5; addVideoClip(vid, duration); }
    }
    fileInput.value = '';
  });

  // Modes / Controls
  function setMode(m){ state.mode = m; modeSpinBtn.classList.toggle('on', m==='SPIN'); modeScptBtn.classList.toggle('on', m==='SCULPT'); }
  modeSpinBtn.addEventListener('click', () => setMode('SPIN'));
  modeScptBtn.addEventListener('click', () => setMode('SCULPT'));

  playBtn.addEventListener('click', ()=>{ state.playing=!state.playing; playBtn.classList.toggle('on', state.playing); playBtn.textContent = state.playing? 'Pause':'Play'; });
  lockViewBtn.addEventListener('click', ()=>{ state.view.locked=!state.view.locked; lockViewBtn.classList.toggle('on', state.view.locked); });
  tubeBtn.addEventListener('click', ()=>{ state.tube=!state.tube; tubeBtn.classList.toggle('on', state.tube); });
  xfadeSlider.addEventListener('input', ()=>{ state.busXfade = Number(xfadeSlider.value); });

  // Resolution
  resBtn.addEventListener('click', () => { RES_SCALE = (RES_SCALE === 1.0) ? 0.8 : (RES_SCALE === 0.8 ? 0.6 : 1.0); resBadge.textContent = `RES ${RES_SCALE.toFixed(1)}×`; resize(); });

  // STAMP transparent
  const stampBtnHandler = () => {
    const off = document.createElement('canvas'); off.width = canvas.width; off.height = canvas.height; const oc = off.getContext('2d');
    const phase = timelinePhase(); drawScene(oc, phase, true); const dataURL = off.toDataURL('image/png'); const img = new Image(); img.onload = () => addStampClip(img); img.src = dataURL; showToast('Stamped');
  };
  stampBtn.addEventListener('click', stampBtnHandler);

  clearBtn.addEventListener('click', () => { stopRecording(true); state.clips = []; state.history = []; state.activeClipId=null; });

  // Recording
  let mediaRecorder = null, recChunks = [], recording = false;
  recBtn.addEventListener('click', () => { if (!recording) startRecording(); else stopRecording(); });
  function startRecording(){ if (recording) return; body.classList.add('recording'); const stream = canvas.captureStream(30); if (!('MediaRecorder' in window)) { alert('MediaRecorder not supported.'); return; } mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); recChunks = []; mediaRecorder.ondataavailable = e => { if (e.data.size) recChunks.push(e.data); }; mediaRecorder.onstop = () => { const blob = new Blob(recChunks, { type:'video/webm' }); const url = URL.createObjectURL(blob); dlLink.href = url; dlLink.style.display=''; body.classList.remove('recording'); }; mediaRecorder.start(); recording = true; recBtn.classList.add('on'); dlLink.style.display='none'; showToast('Recording…'); }
  function stopRecording(silent=false){ if (!recording) return; mediaRecorder.stop(); recording=false; recBtn.classList.remove('on'); if(!silent) showToast('Recording complete — Download ready'); }

  // Save/Load
  const saveBtnEl = saveBtn; saveBtnEl.addEventListener('click', () => { const payload = { version:2, wheelScale: state.wheelScale, view: state.view, tube: state.tube, busXfade: state.busXfade, clips: state.clips.map(c => ({ id:c.id, type:c.type, angle:c.angle, radius:c.radius, scale:c.scale, edge:c.edge, fog:c.fog, blend:c.blend, timeOffset:c.timeOffset, duration:c.duration, label:c.label||null, ring:c.ring||0, data: (c.type==='image'||c.type==='stamp') ? tryImageToDataURL(c.el) : null })) }; const blob = new Blob([JSON.stringify(payload)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='hyperclay_session.json'; a.click(); showToast('Session saved'); });
  function tryImageToDataURL(img){ try{ const off = document.createElement('canvas'); off.width = img.naturalWidth||img.width; off.height = img.naturalHeight||img.height; const octx = off.getContext('2d'); octx.drawImage(img,0,0); return off.toDataURL('image/png'); }catch(_){ return null; } }
  jsonInput.addEventListener('change', async (e) => { const f = e.target.files && e.target.files[0]; if(!f) return; try{ const obj = JSON.parse(await f.text()); state.wheelScale = obj.wheelScale || 1.0; wheelBadge.textContent = `R ${state.wheelScale.toFixed(2)}×`; Object.assign(state.view, obj.view || {}); state.tube = !!obj.tube; state.busXfade = obj.busXfade ?? 0.5; xfadeSlider.value = String(state.busXfade); const rebuilt = []; for (const c of obj.clips||[]) { if ((c.type==='image'||c.type==='stamp') && c.data){ const img = new Image(); await new Promise(res => { img.onload=res; img.src=c.data; }); rebuilt.push({ ...defaultClipBase(), id:c.id, type:c.type, el:img, kind:'img', angle:c.angle, radius:c.radius, scale:c.scale, edge:c.edge, fog:c.fog, blend:c.blend, timeOffset:c.timeOffset, duration:c.duration, ring:c.ring||0 }); } else if (c.type==='video') { rebuilt.push({ ...defaultClipBase(), id:c.id, type:'placeholder', kind:'placeholder', label:'Video (relink)', angle:c.angle, radius:c.radius, scale:c.scale, edge:c.edge, fog:c.fog, blend:c.blend, timeOffset:c.timeOffset, duration:c.duration, ring:c.ring||0 }); } else { rebuilt.push({ ...defaultClipBase(), id:c.id, type:c.type||'placeholder', kind:c.kind||'placeholder', label:c.label||'Clip', angle:c.angle, radius:c.radius, scale:c.scale, edge:c.edge, fog:c.fog, blend:c.blend, timeOffset:c.timeOffset, duration:c.duration, ring:c.ring||0 }); } } state.clips = rebuilt; state.history=[]; showToast('Session loaded'); }catch(err){ alert('Invalid JSON'); } jsonInput.value=''; });

  // Interaction: SPIN/SCULPT + Zoom/Pan
  let dragging=false, dragLastAngle=0; let draggingClip=null; let movedSinceDown=false;
  let pinchStartDist=0, pinchStartZoom=1.0; let pinchStartMid=null; let activeTouches = new Map();
  let panning=false; let panLast=null;

  function pointAngle(x,y){ const dx=x-state.cx(), dy=y-state.cy(); return Math.atan2(dy,dx); }
  function pointerPos(e){ if (e.touches && e.touches[0]){ const r=canvas.getBoundingClientRect(); return { x:(e.touches[0].clientX-r.left)*DPR, y:(e.touches[0].clientY-r.top)*DPR }; } else { const r=canvas.getBoundingClientRect(); return { x:(e.clientX-r.left)*DPR, y:(e.clientY-r.top)*DPR }; } }
  function nearestClipHandle(px,py){ const R=state.baseWheelR(); const world=(a)=>a+state.wheelAngle; let best=null, bestD2=Infinity; for (const c of state.clips){ const angleLocal = state.tube? 0 : c.angle; const radiusLocal = state.tube? (c.ring||0)*tubeSpacing() : c.radius; const a=world(angleLocal), r=R+radiusLocal; const hx=state.cx()+r*Math.cos(a), hy=state.cy()+r*Math.sin(a); const dx=hx-px, dy=hy-py, d2=dx*dx+dy*dy; if (d2<bestD2){ bestD2=d2; best={clip:c,hx,hy,d2}; } } return best && best.d2 < (36*DPR)*(36*DPR) ? best.clip : null; }

  function updateActiveTouches(e){ activeTouches.clear(); if (!e.touches) return; const r=canvas.getBoundingClientRect(); for (let i=0;i<e.touches.length;i++){ const t=e.touches[i]; activeTouches.set(t.identifier, { x:(t.clientX-r.left)*DPR, y:(t.clientY-r.top)*DPR }); } }
  function distanceBetweenTouches(){ if (activeTouches.size<2) return 0; const arr=[...activeTouches.values()]; const dx=arr[0].x-arr[1].x, dy=arr[0].y-arr[1].y; return Math.hypot(dx,dy); }
  function midpointTouches(){ const arr=[...activeTouches.values()]; return { x:(arr[0].x+arr[1].x)/2, y:(arr[0].y+arr[1].y)/2 }; }

  canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); const rect=canvas.getBoundingClientRect(); const sx=(e.clientX-rect.left)*DPR, sy=(e.clientY-rect.top)*DPR; const pre = screenToWorld(sx,sy); const k = Math.pow(1.0015, -e.deltaY); zoomAt(pre.x, pre.y, k); bumpHUD(); }, {passive:false});
  function zoomAt(wx, wy, k){ const vz=clamp(state.view.zoom*k, 0.1, 50); const nx = wx + (state.view.cx - wx) * (state.view.zoom/vz); const ny = wy + (state.view.cy - wy) * (state.view.zoom/vz); state.view.cx = nx; state.view.cy = ny; state.view.zoom = vz; }
  function screenToWorld(sx,sy){ const sw=canvas.width/state.view.zoom, sh=canvas.height/state.view.zoom; const sx0 = state.view.cx - sw/2; const sy0 = state.view.cy - sh/2; return { x: sx0 + sx/state.view.zoom, y: sy0 + sy/state.view.zoom }; }

  canvas.addEventListener('touchstart', onDown, {passive:false}); canvas.addEventListener('mousedown', onDown);
  function onDown(e){ e.preventDefault(); bumpHUD(); if (e.touches && e.touches.length>=2){ updateActiveTouches(e); pinchStartDist = distanceBetweenTouches(); pinchStartZoom = state.view.zoom; pinchStartMid = midpointTouches(); dragging=false; return; }
    const {x,y} = pointerPos(e);
    if (!e.touches && (e.button===1 || e.altKey || e.metaKey || e.ctrlKey || e.shiftKey)) { panning=true; panLast={x,y}; return; }
    dragLastAngle = pointAngle(x,y); dragging=true; state.activeClipId=null; draggingClip=null; if (state.mode==='SCULPT'){ draggingClip = nearestClipHandle(x,y); }
  }

  window.addEventListener('touchmove', onMove, {passive:false}); window.addEventListener('mousemove', onMove);
  function onMove(e){ if (e.touches && e.touches.length>=2){ updateActiveTouches(e); const dist = distanceBetweenTouches(); if (pinchStartDist>0){ const k = dist/pinchStartDist; state.view.zoom = clamp(pinchStartZoom*k, 0.1, 50); const mid = midpointTouches(); const dx = (pinchStartMid.x - mid.x) / state.view.zoom; const dy = (pinchStartMid.y - mid.y) / state.view.zoom; state.view.cx += dx*canvas.width/state.view.zoom; state.view.cy += dy*canvas.height/state.view.zoom; } return; }
    if (panning && panLast){ const {x,y}=pointerPos(e); const dx=(panLast.x-x)/state.view.zoom; const dy=(panLast.y-y)/state.view.zoom; state.view.cx += dx; state.view.cy += dy; panLast={x,y}; return; }
    if (!dragging) return; e.preventDefault(); const {x,y} = pointerPos(e); const a = pointAngle(x,y); const da = angDiff(a, dragLastAngle); dragLastAngle=a; if (state.mode==='SCULPT' && draggingClip){ const qStep = Math.PI/12; const R = state.baseWheelR(); const dist = Math.hypot(x-state.cx(), y-state.cy()); const angleRaw = normAngle((draggingClip.angle||0) + da); draggingClip.angle = state.tube ? 0 : Math.round(angleRaw/qStep)*qStep; const localR = clamp(dist - R, -R*0.25, R*0.6); draggingClip.radius = state.tube ? draggingClip.radius : localR; } else { state.wheelAngle = normAngle(state.wheelAngle + da); state.wheelVel = da; } }

  window.addEventListener('touchend', onUp); window.addEventListener('mouseup', onUp);
  function onUp(){ dragging=false; draggingClip=null; panning=false; panLast=null; }

  function angDiff(a,b){ let d=a-b; while(d>Math.PI) d-=Math.PI*2; while(d<-Math.PI) d+=Math.PI*2; return d; }
  function normAngle(a){ while(a>Math.PI) a-=Math.PI*2; while(a<=-Math.PI) a+=Math.PI*2; return a; }
  const clamp = (v,lo,hi)=> Math.max(lo,Math.min(hi,v));

  // Offscreens
  const offA = document.createElement('canvas'); const offB = document.createElement('canvas');
  let octxA = offA.getContext('2d'); let octxB = offB.getContext('2d');
  function ensureOff(w,h){ if (offA.width!==w||offA.height!==h){ offA.width=w; offA.height=h; offB.width=w; offB.height=h; octxA=offA.getContext('2d'); octxB=offB.getContext('2d'); } }

  // Scene buffer for fixed viewport
  const scn = document.createElement('canvas'); const scx = scn.getContext('2d');
  function ensureScene(){ if (scn.width!==canvas.width || scn.height!==canvas.height){ scn.width=canvas.width; scn.height=canvas.height; } }
  function tubeSpacing(){ return Math.min(canvas.width, canvas.height) * 0.18; }

  function drawFeatherMask(ctxMask,w,h,edgePx){ ctxMask.clearRect(0,0,w,h); if (edgePx<=1){ ctxMask.fillStyle='#fff'; ctxMask.fillRect(0,0,w,h); return; } ctxMask.fillStyle='#fff'; ctxMask.fillRect(edgePx,edgePx,w-2*edgePx,h-2*edgePx); const L=ctxMask.createLinearGradient(0,0,edgePx,0); L.addColorStop(0,'rgba(255,255,255,0)'); L.addColorStop(1,'#fff'); ctxMask.fillStyle=L; ctxMask.fillRect(0,edgePx,edgePx,h-2*edgePx); const Rg=ctxMask.createLinearGradient(w-edgePx,0,w,0); Rg.addColorStop(0,'#fff'); Rg.addColorStop(1,'rgba(255,255,255,0)'); ctxMask.fillStyle=Rg; ctxMask.fillRect(w-edgePx,edgePx,edgePx,h-2*edgePx); const T=ctxMask.createLinearGradient(0,0,0,edgePx); T.addColorStop(0,'rgba(255,255,255,0)'); T.addColorStop(1,'#fff'); ctxMask.fillStyle=T; ctxMask.fillRect(edgePx,0,w-2*edgePx,edgePx); const B=ctxMask.createLinearGradient(0,h-edgePx,0,h); B.addColorStop(0,'#fff'); B.addColorStop(1,'rgba(255,255,255,0)'); ctxMask.fillStyle=B; ctxMask.fillRect(edgePx,h-edgePx,w-2*edgePx,edgePx); function corner(xc,yc){ const rg=ctxMask.createRadialGradient(xc,yc,0, xc,yc,edgePx); rg.addColorStop(0,'#fff'); rg.addColorStop(1,'rgba(255,255,255,0)'); ctxMask.fillStyle=rg; ctxMask.beginPath(); ctxMask.arc(xc,yc,edgePx,0,Math.PI*2); ctxMask.fill(); } corner(edgePx,edgePx); corner(w-edgePx,edgePx); corner(edgePx,h-edgePx); corner(w-edgePx,h-edgePx); }

  function drawClipLayer(mainCtx, clip, phase){
    const cx=state.cx(), cy=state.cy(), R=state.baseWheelR();
    let srcW=320, srcH=180;
    if (clip.kind==='video'){ srcW=clip.el.videoWidth||320; srcH=clip.el.videoHeight||180; }
    else if (clip.kind==='img'){ srcW=clip.el.naturalWidth||clip.el.width||320; srcH=clip.el.naturalHeight||clip.el.height||180; }
    else if (clip.kind==='placeholder'){ srcW=320; srcH=180; }

    const targetW=Math.max(8, Math.floor(srcW*clip.scale));
    const targetH=Math.max(8, Math.floor(srcH*clip.scale));
    ensureOff(targetW,targetH);

    if (clip.kind==='video'){ const t = ((phase * clip.duration) + clip.timeOffset) % clip.duration; if (!Number.isNaN(t) && isFinite(t)) { try { clip.el.currentTime = t; } catch(_){} } }

    octxA.clearRect(0,0,targetW,targetH); if (clip.kind==='placeholder'){ octxA.fillStyle='#0c1118'; octxA.fillRect(0,0,targetW,targetH); octxA.strokeStyle='#2a313a'; octxA.strokeRect(1,1,targetW-2,targetH-2); octxA.fillStyle='#9aa0a6'; octxA.font='12px ui-sans-serif'; octxA.fillText(clip.label||'Video placeholder', 8, 18); } else { try { octxA.drawImage(clip.el, 0, 0, targetW, targetH); } catch(_) {} }

    octxB.clearRect(0,0,targetW,targetH); drawFeatherMask(octxB, targetW, targetH, Math.min(clip.edge * DPR, Math.floor(Math.min(targetW,targetH)/3)) ); octxA.globalCompositeOperation='destination-in'; octxA.drawImage(offB,0,0); octxA.globalCompositeOperation='source-over';

    if (clip.fog>0.001){ octxA.save(); octxA.globalAlpha=clip.fog; octxA.fillStyle='#fff'; octxA.fillRect(0,0,targetW,targetH); octxA.restore(); }

    const ringR = (clip.ring||0) * tubeSpacing();
    const localAngle = state.tube ? 0 : clip.angle;
    const localRadius = state.tube ? ringR : clip.radius;
    const aWorld=localAngle+state.wheelAngle; const rWorld=R+localRadius; const x = cx + rWorld*Math.cos(aWorld) - targetW/2; const y= cy + rWorld*Math.sin(aWorld) - targetH/2;

    let alpha = 1; const vids = state.clips.filter(k=>k.kind==='video'); if (clip.kind==='video' && vids.length===2){ alpha = (clip.id===vids[0].id) ? (1-state.busXfade) : state.busXfade; }
    mainCtx.save(); mainCtx.globalCompositeOperation = clip.blend; mainCtx.globalAlpha = alpha; mainCtx.drawImage(offA, Math.floor(x), Math.floor(y)); mainCtx.restore();
  }

  // Timeline phase
  let playT = 0; function timelinePhase(){ if (state.playing){ playT += 1/60; return playT % 1; } return ((state.wheelAngle/(Math.PI*2))%1 + 1) % 1; }

  // Draw scene into context (layers only if layersOnly)
  function drawScene(context, phase, layersOnly=false){ if (!layersOnly){ context.fillStyle='#000'; context.fillRect(0,0,canvas.width,canvas.height); } for (const c of state.clips) drawClipLayer(context, c, phase); }

  // Main Loop
  let lastT=performance.now(), fpsSm=60;
  function tick(now){ const dt = now-lastT; lastT=now; const alpha = Math.max(0.25, Math.min(4, dt/16.6667)); if (!state.playing && (!dragging || state.mode!=='SCULPT')){ state.wheelAngle = normAngle(state.wheelAngle + state.wheelVel*alpha); state.wheelVel *= Math.pow(state.friction, alpha); if (Math.abs(state.wheelVel)<1e-5) state.wheelVel=0; }
    const phase = timelinePhase(); ensureScene(); scx.setTransform(1,0,0,1,0,0); scx.clearRect(0,0,scn.width,scn.height); scx.fillStyle='#000'; scx.fillRect(0,0,scn.width,scn.height); for (const c of state.clips) drawClipLayer(scx, c, phase); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); const sw = canvas.width / state.view.zoom; const sh = canvas.height / state.view.zoom; const sx = clamp(state.view.cx - sw/2, 0, Math.max(0, scn.width - sw)); const sy = clamp(state.view.cy - sh/2, 0, Math.max(0, scn.height - sh)); ctx.drawImage(scn, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height); phaseNote.textContent = `phase ${phase.toFixed(3)}`; fpsSm = fpsSm*0.9 + (1000/dt)*0.1; fpsNote.textContent = `fps ${Math.max(1, Math.round(fpsSm))}`; const inertia = Math.min(1, Math.abs(state.wheelVel)*24); inertiaFill.style.width = `${Math.floor(inertia*100)}%`; requestAnimationFrame(tick); }
  requestAnimationFrame(tick);

  // Keyboard
  window.addEventListener('keydown', e => { if (e.key===' ') setMode(state.mode==='SPIN'?'SCULPT':'SPIN'); if (e.key==='p') playBtn.click(); if (e.key==='l') lockViewBtn.click(); if (e.key==='t') tubeBtn.click(); if (e.key==='s') stampBtn.click(); if (e.key==='r') recBtn.click(); if (e.key==='u') undoBtn.click(); if (e.key==='['){ state.busXfade = Math.max(0, state.busXfade-0.02); xfadeSlider.value=String(state.busXfade); } if (e.key===']'){ state.busXfade = Math.min(1, state.busXfade+0.02); xfadeSlider.value=String(state.busXfade); } });

  // Auto-save
  setInterval(()=>{ try{ const payload={ wheelScale: state.wheelScale, view: state.view, tube: state.tube, busXfade: state.busXfade, clips: state.clips.map(c=>({id:c.id,type:c.type,angle:c.angle,radius:c.radius,scale:c.scale,edge:c.edge,fog:c.fog,blend:c.blend,timeOffset:c.timeOffset,duration:c.duration,label:c.label||null,ring:c.ring||0,data:(c.type==='image'||c.type==='stamp')?tryImageToDataURL(c.el):null})) }; sessionStorage.setItem('hyperclay_auto', JSON.stringify(payload)); }catch(_){ } }, 2000);

  dlLink.addEventListener('click', ()=> showToast('Downloaded'));

  // ==========================
  // Self-tests (basic runtime assertions)
  // ==========================
  function runSelfTests(){
    const errs=[]; const ok=(name,cond)=>{ if(!cond){ errs.push(name); console.error('Test failed:', name); } };
    // TDZ/resize ordering
    try { resize(); ok('resize-after-state', true); } catch(e){ ok('resize-after-state', false); }
    ok('state-exists', !!state && typeof state==='object');
    ok('phase-in-range', (()=>{ const p=((state.wheelAngle/(Math.PI*2))%1 + 1) % 1; return p>=0 && p<1; })());
    ok('clamp', ((()=> clamp(-1,0,1)===0 && clamp(2,0,1)===1)()));
    ok('normAngle', ((()=> { const a=normAngle(Math.PI*3); return a>-Math.PI && a<=Math.PI; })()));
    // Transparent stamp drawScene when layersOnly=true (no clips => transparent)
    const off=document.createElement('canvas'); off.width=2; off.height=2; const oc=off.getContext('2d'); drawScene(oc, 0.0, true); const px=oc.getImageData(0,0,1,1).data; ok('stamp-transparent', px[3]===0);
    if (errs.length===0){ console.log('%cSelf-tests passed','color:#00d0b4'); } else { console.warn('Self-tests failed:', errs); }
  }
  setTimeout(runSelfTests, 0);

})();
</script>
</body>
</html>
