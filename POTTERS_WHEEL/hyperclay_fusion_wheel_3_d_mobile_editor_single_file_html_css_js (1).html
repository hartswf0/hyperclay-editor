<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Hyperclay Fusion Wheel — 3D Mobile Editor (Z‑physics)</title>
<style>
  :root{
    --bg:#07080c; --ink:#ecf0f1; --muted:#a8b0bd; --accent:#62e0d0; --hot:#ff6a3d; --gold:#e3c46b;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"}
  canvas{position:fixed;inset:0;touch-action:none;}
  .hud{position:fixed;left:0;right:0;bottom:0;display:flex;gap:.45rem;align-items:center;justify-content:space-between;padding:.55rem .75rem;background:linear-gradient(180deg, transparent, rgba(6,7,10,.78));backdrop-filter: blur(8px);}
  .btnrow{display:flex;gap:.45rem;align-items:center;}
  .btn{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--ink);padding:.5rem .65rem;border-radius:14px;font-size:18px;line-height:1;min-width:2.25rem;text-align:center;box-shadow:0 2px 0 rgba(0,0,0,.35);}
  .btn:active{transform:translateY(1px);} .btn.active{outline:2px solid rgba(98,224,208,.6); box-shadow:0 0 0 3px rgba(98,224,208,.25);}
  input[type=file]{display:none}
  .brand{font-weight:800; letter-spacing:.02em; font-size:.9rem; color:var(--muted)}
  .tooltip{position:fixed;left:50%;transform:translateX(-50%);bottom:64px;color:#d7f6f0;font-size:.8rem;opacity:.95;background:rgba(0,0,0,.45);padding:.35rem .6rem;border-radius:10px;border:1px solid rgba(255,255,255,.12)}
  .panel{position:fixed;left:50%;transform:translateX(-50%);bottom:3.6rem;width:min(780px,96%);background:rgba(10,12,16,.92);border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:.55rem .75rem;display:none;color:#dbe6f1}
  .grid{display:grid;grid-template-columns:1fr 120px;gap:.35rem .6rem; align-items:center}
  .grid label{opacity:.9}
  .grid input[type=range]{width:100%}
  .unlock{position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;background:rgba(5,7,11,.85);backdrop-filter:blur(6px);z-index:5}
  .unlock button{margin-top:12px}
  .meter{position:fixed;top:.5rem;left:.5rem;color:#cfe3ff;font-size:.78rem;opacity:.85;background:rgba(0,0,0,.35);padding:.3rem .5rem;border-radius:10px;border:1px solid rgba(255,255,255,.12)}
</style>
</head>
<body>
<canvas id="view"></canvas>
<input id="file" type="file" accept="video/*" multiple />
<div class="hud">
  <div class="brand">HYPERCLAY FUSION WHEEL</div>
  <div class="btnrow">
    <button class="btn" id="load" title="Load clips">⧉</button>
    <button class="btn" id="tests" title="Load test patterns">✚</button>
    <button class="btn" id="blend" title="Toggle blend mode">✸</button>
    <button class="btn" id="tuner" title="Open tuner">⚙</button>
    <button class="btn" id="gyro" title="Tilt camera">◎</button>
    <button class="btn" id="export" title="Record core">⬤</button>
    <button class="btn" id="help" title="Help">?</button>
  </div>
</div>
<div class="tooltip" id="tip"></div>
<div class="meter" id="meter">ω: 0.00 · clips: 0</div>

<!-- Media unlock overlay (for mobile autoplay policies) -->
<div class="unlock" id="unlock">
  <div>Tap to enable media & audio</div>
  <button class="btn" id="unlockBtn">▶ Start</button>
  <div style="font-size:.75rem;opacity:.8;margin-top:6px">If nothing appears, tap ✚ for test clips or ⧉ to load videos.</div>
</div>

<!-- TUNER PANEL -->
<div class="panel" id="tunerPanel">
  <div class="grid">
    <label>Wheel Radius</label> <input id="rngWheelR" type="range" min="80" max="420" step="2" value="240" />
    <label>Core Radius</label>  <input id="rngCoreR"  type="range" min="80" max="360" step="2" value="200" />
    <label>Friction</label>     <input id="rngFric"   type="range" min="0.90" max="0.995" step="0.001" value="0.970" />
    <label>Fog Density</label>  <input id="rngMist"   type="range" min="0.02" max="0.22" step="0.01" value="0.08" />
    <label>Fog Feather</label>  <input id="rngFeath"  type="range" min="0.15" max="0.85" step="0.01" value="0.45" />
    <label>Depth Bias</label>   <input id="rngDepth"  type="range" min="0.00" max="0.80" step="0.01" value="0.25" />
    <label>Parallax</label>     <input id="rngPara"   type="range" min="0.0" max="1.0" step="0.05" value="0.4" />
    <label>Z Spring</label>     <input id="rngZk"     type="range" min="0.02" max="0.35" step="0.01" value="0.14" />
    <label>Z Damping</label>    <input id="rngZc"     type="range" min="0.75" max="0.99" step="0.01" value="0.92" />
    <label>Z Gravity</label>    <input id="rngZg"     type="range" min="-0.02" max="0.04" step="0.002" value="0.012" />
    <label>Arc Threshold</label><input id="rngArc"    type="range" min="0.6" max="2.6" step="0.05" value="1.4" />
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', {alpha:false});
  const dpr = Math.min(2, window.devicePixelRatio||1);
  let W=0,H=0, t=0; function resize(){ W=Math.floor(innerWidth*dpr); H=Math.floor(innerHeight*dpr); canvas.width=W; canvas.height=H; canvas.style.width=(W/dpr)+'px'; canvas.style.height=(H/dpr)+'px'; } window.addEventListener('resize', resize, {passive:true}); resize();

  const tip = document.getElementById('tip');
  const meter = document.getElementById('meter');
  const unlock = document.getElementById('unlock');
  const unlockBtn = document.getElementById('unlockBtn');
  const fileInput = document.getElementById('file');
  const btn = id=>document.getElementById(id);
  const loadBtn=btn('load'), testsBtn=btn('tests'), tunerBtn=btn('tuner'), blendBtn=btn('blend'), exportBtn=btn('export'), helpBtn=btn('help'), gyroBtn=btn('gyro');
  const panel=document.getElementById('tunerPanel');
  const rng = id=>document.getElementById(id);
  const rngWheelR=rng('rngWheelR'), rngCoreR=rng('rngCoreR'), rngFric=rng('rngFric'), rngMist=rng('rngMist'), rngFeath=rng('rngFeath'), rngDepth=rng('rngDepth'), rngPara=rng('rngPara');
  const rngZk=rng('rngZk'), rngZc=rng('rngZc'), rngZg=rng('rngZg'), rngArc=rng('rngArc');

  function setTip(txt){ tip.textContent=txt; tip.style.opacity=1; clearTimeout(setTip._t); setTip._t=setTimeout(()=> tip.style.opacity=0, 1700); }
  function vibrate(p){ if(navigator.vibrate) try{ navigator.vibrate(p);}catch(e){} }

  // Web Audio — wheel motor, impacts, air
  let audioCtx=null, master=null, motor=null, motorGain=null, noise=null, noiseGain=null, clickBuf=null;
  function initAudio(){ if(audioCtx) return; audioCtx=new (window.AudioContext||window.webkitAudioContext)(); master=audioCtx.createGain(); master.gain.value=.28; master.connect(audioCtx.destination);
    motor=audioCtx.createOscillator(); motor.type='sawtooth'; const lpf=audioCtx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=400; motorGain=audioCtx.createGain(); motorGain.gain.value=.0; motor.connect(lpf); lpf.connect(motorGain); motorGain.connect(master); motor.start();
    noise=audioCtx.createBufferSource(); const buf=audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate); const d=buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.25; noise.buffer=buf; noise.loop=true; const bpf=audioCtx.createBiquadFilter(); bpf.type='bandpass'; bpf.frequency.value=900; noiseGain=audioCtx.createGain(); noiseGain.gain.value=.02; noise.connect(bpf); bpf.connect(noiseGain); noiseGain.connect(master); noise.start();
    // click for impacts
    clickBuf = audioCtx.createBuffer(1, 200, audioCtx.sampleRate); const cd=clickBuf.getChannelData(0); for(let i=0;i<cd.length;i++){ cd[i]= (Math.random()*2-1) * Math.exp(-i/40); }
  }
  function motorSet(omega){ if(!audioCtx) return; const s=Math.min(1, Math.abs(omega)*0.12); motor.frequency.value = 40 + 160*s; motorGain.gain.linearRampToValueAtTime(0.06 + 0.25*s, audioCtx.currentTime+0.05); noiseGain.gain.linearRampToValueAtTime(0.01 + 0.07*s, audioCtx.currentTime+0.05); }
  function click(){ if(!audioCtx) return; const src=audioCtx.createBufferSource(); src.buffer=clickBuf; const g=audioCtx.createGain(); g.gain.value=0.25; src.connect(g); g.connect(master); src.start(); }

  // Config / State
  const center=()=>({x:W/2, y:H/2});
  const state={
    wheelR: parseFloat(rngWheelR.value)*dpr,
    coreR : parseFloat(rngCoreR.value)*dpr,
    friction: parseFloat(rngFric.value),
    fog:{ density: parseFloat(rngMist.value), feather: parseFloat(rngFeath.value) },
    depthBias: parseFloat(rngDepth.value),
    parallax: parseFloat(rngPara.value),
    wheelTheta: 0, wheelOmega: 0,
    blendModes: ['lighter','screen','multiply','hard-light','overlay'],
    blendIdx:0,
    camera:{tx:0,ty:0},
    recording:false,
    zk: parseFloat(rngZk.value), zc: parseFloat(rngZc.value), zg: parseFloat(rngZg.value), arcThresh: parseFloat(rngArc.value)
  };
  const syncCfg=()=>{ state.wheelR=parseFloat(rngWheelR.value)*dpr; state.coreR=parseFloat(rngCoreR.value)*dpr; state.friction=parseFloat(rngFric.value); state.fog.density=parseFloat(rngMist.value); state.fog.feather=parseFloat(rngFeath.value); state.depthBias=parseFloat(rngDepth.value); state.parallax=parseFloat(rngPara.value); state.zk=parseFloat(rngZk.value); state.zc=parseFloat(rngZc.value); state.zg=parseFloat(rngZg.value); state.arcThresh=parseFloat(rngArc.value); updateMasks(); };
  [rngWheelR,rngCoreR,rngFric,rngMist,rngFeath,rngDepth,rngPara,rngZk,rngZc,rngZg,rngArc].forEach(el=> el.addEventListener('input', syncCfg));

  // Touch & gestures
  const touches=new Map();
  let draggingWheel=false; let wheelGrabAngle=0; let wheelStartTheta=0; let lastWheelTime=0;

  function screenToWorld(x,y){ const cx=W/2 + state.camera.tx*state.parallax, cy=H/2 + state.camera.ty*state.parallax; return {x: x*dpr, y: y*dpr, cx, cy}; }

  function onPointerDown(e){ initAudio(); if(audioCtx?.state==='suspended') audioCtx.resume(); const w=screenToWorld(e.clientX,e.clientY); const id=e.pointerId||('m'+Math.random()); touches.set(id,{id,x:w.x,y:w.y, t:performance.now(), path:[{x:w.x,y:w.y}], onClip:null});
    const R=state.wheelR, dist=Math.hypot(w.x-w.cx, w.y-w.cy); const rimHit=Math.abs(dist-R)<24*dpr; if(rimHit){ draggingWheel=true; wheelGrabAngle = Math.atan2(w.y-w.cy, w.x-w.cx); wheelStartTheta=state.wheelTheta; lastWheelTime=performance.now(); vibrate(8); setTip('Spin the wheel'); }
    const c=pickClip(w.x,w.y); if(c){ const tp=touches.get(id); tp.onClip=c; c.selected=true; c.locked=false; vibrate([8,20,8]); }
  }
  function onPointerMove(e){ const id=e.pointerId||[...touches.keys()][0]; if(!touches.has(id)) return; const w=screenToWorld(e.clientX,e.clientY); const tp=touches.get(id); tp.x=w.x; tp.y=w.y; tp.path.push({x:w.x,y:w.y}); if(tp.path.length>10) tp.path.shift();
    if(draggingWheel){ const ang=Math.atan2(w.y-w.cy, w.x-w.cx); const dAng=ang-wheelGrabAngle; const now=performance.now(); const dt=(now-lastWheelTime)/1000; state.wheelTheta = wheelStartTheta + dAng; state.wheelOmega = dAng/dt; lastWheelTime=now; motorSet(state.wheelOmega); }
    if(tp.onClip){ const c=tp.onClip; if(touches.size===1){ c.x = w.x; c.y = w.y; // free move
      // update theta so neighbor order stays meaningful
      const cen=center(); c.theta = Math.atan2(c.y-cen.y, c.x-cen.x);
    }
      if(touches.size===2){ const ids=[...touches.values()]; const d=dist(ids[0],ids[1]); c.scale = clamp((d/(180*dpr)), 0.5, 3.0); c.feather = clamp(state.fog.feather + (d/(600*dpr)-0.3), 0.1, 0.9); c.maskDirty=true; }
      if(touches.size>=3){ const centroidPt=centroid([...touches.values()]); c.vz += ((centroidPt.y - (c._zRefY||centroidPt.y)))/(400*dpr); c._zRefY=centroidPt.y; vibrate(4); }
    }
  }
  function onPointerUp(e){ const id=e.pointerId||[...touches.keys()][0]; const tp=touches.get(id); if(!tp) return; if(tp.onClip){ tp.onClip.selected=false; delete tp.onClip._zRefY; } touches.delete(id); if([...touches.values()].every(t=>!t.onClip)) draggingWheel=false; }
  canvas.addEventListener('pointerdown', onPointerDown); canvas.addEventListener('pointermove', onPointerMove); canvas.addEventListener('pointerup', onPointerUp); canvas.addEventListener('pointercancel', onPointerUp);

  // Gyro for parallax
  let gyroOn=false; gyroBtn.addEventListener('click', async ()=>{ if(!gyroOn){ if(typeof DeviceOrientationEvent!== 'undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ try{ const p=await DeviceOrientationEvent.requestPermission(); if(p!=='granted') return; }catch(e){} } window.addEventListener('deviceorientation', onOri); gyroOn=true; gyroBtn.classList.add('active'); setTip('Tilt camera on'); } else { window.removeEventListener('deviceorientation', onOri); gyroOn=false; gyroBtn.classList.remove('active'); setTip('Tilt camera off'); } });
  function onOri(e){ state.camera.tx = (e.gamma||0)*8*dpr; state.camera.ty=(e.beta||0)*6*dpr; }

  // Loaders & unlock
  loadBtn.addEventListener('click', ()=> fileInput.click()); fileInput.addEventListener('change', ev=>{ const files=[...ev.target.files].filter(f=>f.type.startsWith('video/')).slice(0,8); if(!files.length) return setTip('No videos selected'); files.forEach(f=> addVideoClip(f)); unlock.style.display='flex'; });
  testsBtn.addEventListener('click', ()=>{ addProcClip('plasma'); addProcClip('rings'); addProcClip('stripes'); setTip('Loaded test patterns'); });
  unlock.style.display='flex'; unlockBtn.addEventListener('click', ()=>{ initAudio(); if(audioCtx?.state==='suspended') audioCtx.resume(); startAllVideos(); unlock.style.display='none'; setTip('Media enabled'); });

  tunerBtn.addEventListener('click', ()=>{ const vis=panel.style.display==='block'; panel.style.display= vis?'none':'block'; tunerBtn.classList.toggle('active', !vis); });
  blendBtn.addEventListener('click', ()=>{ state.blendIdx=(state.blendIdx+1)%state.blendModes.length; setTip('Blend: '+state.blendModes[state.blendIdx]); vibrate([8,40,8]); });

  // Export core (WebM)
  let recorder=null; let recordChunks=[]; exportBtn.addEventListener('click', ()=>{ if(state.recording){ recorder.stop(); state.recording=false; exportBtn.classList.remove('active'); setTip('Stopped. Saving…'); } else { const stream = coreCV.captureStream? coreCV.captureStream(30): canvas.captureStream(30); recorder=new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'}); recordChunks=[]; recorder.ondataavailable=e=>{ if(e.data.size>0) recordChunks.push(e.data); }; recorder.onstop=()=>{ const blob=new Blob(recordChunks,{type:'video/webm'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='hyperclay_core.webm'; a.click(); setTip('Saved core as WebM'); }; recorder.start(); state.recording=true; exportBtn.classList.add('active'); setTip('Recording core…'); }
  });

  helpBtn.addEventListener('click', ()=>{
    alert('Hyperclay basics:

• Spin the rim to scrub (wheel inertia + motor sound).
• Drag a tile to move; pinch on it to scale/feather.
• 3‑finger push/pull adds Z; clips balance via arc physics and may fall.
• Core shows a fog‑blended composite; ✸ toggles blend.
• ⚙ tuner adjusts wheel, fog, depth, springs, gravity.
• ✚ test patterns, ⧉ load videos (tap ▶ Start if blocked).
• ⬤ record the core to WebM.');
  });

  // Clips
  const clips=[]; let nextId=1;
  function addVideoClip(file){ const url=URL.createObjectURL(file); const v=document.createElement('video'); v.src=url; v.loop=true; v.muted=true; v.playsInline=true; v.crossOrigin='anonymous'; v.preload='auto'; v.addEventListener('loadeddata', ()=>{ createClip({draw:ctx=>ctx.drawImage(v,0,0), w:()=>v.videoWidth||320, h:()=>v.videoHeight||180, type:'video', media:v}); }); }
  function startAllVideos(){ for(const c of clips){ if(c.renderable.media){ c.renderable.media.play().catch(()=>{}); } } }

  function addProcClip(kind){ const off=document.createElement('canvas'); off.width=320; off.height=180; const cx=off.getContext('2d'); let seed=Math.random()*1000; function render(T){ const w=off.width,h=off.height; const img=cx.createImageData(w,h); const data=img.data; for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ const i=(y*w+x)*4; const nx=x/w-.5, ny=y/h-.5; const r=Math.hypot(nx,ny); let v=0; if(kind==='plasma'){ v=0.5+0.5*(Math.sin(6*nx+T*1.4)+Math.sin(7*ny-T*1.1)); v*=0.5+0.5*Math.sin(4*(nx+ny)+T*0.7+seed); } else if(kind==='rings'){ v=0.5+0.5*Math.sin(16*r - T*1.8 + seed); } else { v = 0.5+0.5*Math.sin(10*nx+seed)*Math.cos(10*ny+T*1.2); } const R=120+120*v, G=120+120*Math.sin(v*3.14+1), B=120+120*Math.cos(v*3.14+2); data[i]=R; data[i+1]=G; data[i+2]=B; data[i+3]=255; }} cx.putImageData(img,0,0); return off; }
    createClip({draw:(ctx)=>ctx.drawImage(render(t*0.05),0,0), w:()=>off.width, h:()=>off.height, type:'proc'});
  }

  function createClip(renderable){ const c=center(); const theta=(clips.length/6)*Math.PI*2; const clip={ id:nextId++, x:c.x + state.wheelR*Math.cos(theta), y:c.y + state.wheelR*Math.sin(theta), theta, z: (Math.random()*2-1)*0.2, vz:0, scale:1, feather:state.fog.feather, selected:false, locked:true, renderable };
    clip.mask = buildMask(256, clip.feather);
    clips.push(clip);
  }

  // Fog mask
  function buildMask(size, feather){ const cv=document.createElement('canvas'); cv.width=cv.height=size; const cx=cv.getContext('2d'); const g=cx.createRadialGradient(size/2,size/2,size*0.05, size/2,size/2,size*0.5); g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(feather, 'rgba(255,255,255,0.7)'); g.addColorStop(1, 'rgba(255,255,255,0)'); cx.fillStyle=g; cx.fillRect(0,0,size,size); return cv; }
  function updateMasks(){ for(const c of clips){ if(c.maskDirty){ c.mask = buildMask(256, c.feather); c.maskDirty=false; } } }

  function pickClip(sx,sy){ let best=null, bestD=1e9, bestZ=-1e9; for(const c of clips){ const d=Math.hypot(sx-c.x, sy-c.y); const zOrder=c.z; if(d< (90*dpr*c.scale) ){ if(zOrder>bestZ || (zOrder===bestZ && d<bestD)){ best=c; bestD=d; bestZ=zOrder; } } } return best; }

  function centroid(pts){ let x=0,y=0; for(const p of pts){ x+=p.x;y+=p.y;} return {x:x/pts.length, y:y/pts.length}; }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  const sgn = v=> (v<0?-1:1);

  // Offscreen core
  const coreCV=document.createElement('canvas'); coreCV.width=coreCV.height= Math.min(512, Math.floor(Math.min(W,H)/dpr)*dpr ); const coreCtx=coreCV.getContext('2d');

  function stepPhysics(dt){
    // sort by theta for neighbor arcs
    const cen=center();
    for(const c of clips){ if(c.locked){ c.theta += state.wheelOmega*dt; c.x = cen.x + state.wheelR*Math.cos(c.theta + state.wheelTheta); c.y = cen.y + state.wheelR*Math.sin(c.theta + state.wheelTheta); } }
    const byTheta=[...clips].sort((a,b)=> a.theta-b.theta);
    // compute arc spans and spring z-links
    for(let i=0;i<byTheta.length;i++){
      const A=byTheta[(i-1+byTheta.length)%byTheta.length];
      const B=byTheta[i];
      const C=byTheta[(i+1)%byTheta.length];
      const span = Math.abs(C.theta - A.theta); // rough span in radians
      const support = Math.max(0, 1 - (span/state.arcThresh));
      // neighbor springs: pull toward neighbor average (arc shaping)
      const zAvg = (A.z + C.z)/2;
      const spring = (zAvg - B.z) * state.zk;
      // gravity reduced by support; if support low, they "fall"
      const gravity = state.zg * (1 - support);
      B.vz += (spring + gravity) * dt * 60;
      B.vz *= state.zc;
      B.z += B.vz;
      // impact haptics + click when hitting near plane
      if(Math.abs(B.vz)>0.08 && Math.abs(B.z)<0.02){ click(); vibrate(6); }
    }
  }

  function draw(){ const dt=1/60; t+=dt; updateMasks();
    // physics & motor
    if(Math.abs(state.wheelOmega)>0.001){ motorSet(state.wheelOmega); } else { motorSet(0); }
    state.wheelOmega *= state.friction; if(Math.abs(state.wheelOmega)<1e-3) state.wheelOmega=0;
    stepPhysics(dt);

    // camera bg
    ctx.fillStyle= '#07080c'; ctx.fillRect(0,0,W,H);
    const g=42*dpr; ctx.globalAlpha=.16; ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.beginPath(); for(let y=(((-state.camera.ty)%g)+g)%g; y<H; y+=g){ ctx.moveTo(0,y); ctx.lineTo(W,y);} for(let x=(((-state.camera.tx)%g)+g)%g; x<W; x+=g){ ctx.moveTo(x,0); ctx.lineTo(x,H);} ctx.stroke(); ctx.globalAlpha=1;

    // CORE: misting fusion
    coreCtx.save(); coreCtx.globalCompositeOperation='source-over'; coreCtx.fillStyle=`rgba(0,0,0,${state.fog.density})`; coreCtx.fillRect(0,0,coreCV.width,coreCV.height); coreCtx.translate(coreCV.width/2, coreCV.height/2); coreCtx.rotate(0.0035); coreCtx.scale(1.008,1.008); coreCtx.globalAlpha=0.95; coreCtx.drawImage(coreCV, -coreCV.width/2, -coreCV.height/2); coreCtx.restore();
    coreCtx.globalCompositeOperation = state.blendModes[state.blendIdx];
    const c=center();
    for(const clip of clips){
      const wx=(clip.x-c.x)/(state.coreR); const wy=(clip.y-c.y)/(state.coreR); const dz = clamp(1 - (clip.z*state.depthBias+0), 0.4, 1.4); const d=Math.hypot(wx,wy); if(d<1.2){ const alpha = clamp(1 - d, 0, 1) * dz; drawClipInto(coreCtx, clip, alpha*0.85); }
    }

    // core circle
    ctx.save(); ctx.translate(c.x + state.camera.tx*state.parallax, c.y + state.camera.ty*state.parallax); const R=state.coreR; ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.strokeStyle='rgba(98,224,208,.9)'; ctx.lineWidth=2*dpr; ctx.shadowColor='rgba(98,224,208,.6)'; ctx.shadowBlur=18; ctx.stroke(); ctx.shadowBlur=0; ctx.save(); ctx.beginPath(); ctx.arc(0,0,R-3*dpr,0,Math.PI*2); ctx.clip(); const dw=R*2, dh=R*2; ctx.globalAlpha=0.98; ctx.drawImage(coreCV, -dw/2, -dh/2, dw, dh); ctx.globalCompositeOperation='screen'; ctx.globalAlpha=0.18; ctx.filter='blur(6px)'; ctx.drawImage(coreCV, -dw/2, -dh/2, dw, dh); ctx.filter='none'; ctx.restore(); ctx.restore();

    // wheel rim
    ctx.save(); ctx.translate(c.x + state.camera.tx*state.parallax, c.y + state.camera.ty*state.parallax); ctx.beginPath(); ctx.arc(0,0,state.wheelR,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,.16)'; ctx.lineWidth=2*dpr; ctx.stroke(); ctx.restore();

    // clips (depth sorted)
    for(const clip of [...clips].sort((a,b)=> a.z-b.z)) drawClip(ctx, clip);

    meter.textContent = `ω: ${state.wheelOmega.toFixed(2)} · clips: ${clips.length}`;

    requestAnimationFrame(draw);
  }

  function drawClipInto(targetCtx, clip, alpha){ const w=clip.renderable.w(), h=clip.renderable.h(); if(!w||!h) return; const tmp = getTempCanvas(w,h); const tctx=tmp.getContext('2d'); tctx.clearRect(0,0,w,h); clip.renderable.draw(tctx); tctx.globalCompositeOperation='destination-in'; const ms=clip.mask; tctx.drawImage(ms, 0,0,w,h); targetCtx.save(); targetCtx.globalAlpha = alpha; const S=coreCV.width*0.9; const sc=Math.max(S/w, S/h) * clip.scale * (1 + clip.z*0.12); targetCtx.drawImage(tmp, -w*sc/2, -h*sc/2, w*sc, h*sc); targetCtx.restore(); }

  function drawClip(targetCtx, clip){ const w=clip.renderable.w(), h=clip.renderable.h(); if(!w||!h) return; const tmp=getTempCanvas(w,h); const tctx=tmp.getContext('2d'); tctx.clearRect(0,0,w,h); clip.renderable.draw(tctx); tctx.globalCompositeOperation='destination-in'; tctx.drawImage(clip.mask,0,0,w,h); const depthScale = 1 + clip.z*0.14; const sc = 0.45 * clip.scale * depthScale * dpr; const dw=w*sc, dh=h*sc; targetCtx.save(); targetCtx.translate(clip.x + state.camera.tx*state.parallax, clip.y + state.camera.ty*state.parallax); targetCtx.globalAlpha = clamp(0.85 - Math.max(0,clip.z)*0.15, 0.45, 0.95); targetCtx.drawImage(tmp, -dw/2, -dh/2, dw, dh); targetCtx.lineWidth=1.5*dpr; targetCtx.strokeStyle = clip.selected? 'rgba(255,255,255,.9)' : 'rgba(255,255,255,.25)'; targetCtx.beginPath(); targetCtx.arc(0,0, Math.max(dw,dh)/2 + 4*dpr, 0, Math.PI*2); targetCtx.stroke(); // z meter
    targetCtx.fillStyle='rgba(255,255,255,.35)'; targetCtx.fillRect(-2*dpr, -dw*.6, 4*dpr, dw*1.2); targetCtx.fillStyle='rgba(98,224,208,.9)'; const hbar = clamp((clip.z+1.5)/3, 0,1)*dw*1.2; targetCtx.fillRect(-2*dpr, dw*.6-hbar, 4*dpr, hbar); targetCtx.restore(); }

  const pool=[]; function getTempCanvas(w,h){ let cv=pool.find(c=>c.width===w && c.height===h); if(!cv){ cv=document.createElement('canvas'); cv.width=w; cv.height=h; pool.push(cv);} return cv; }

  // Auto-load some procedural clips so something is visible
  addProcClip('plasma'); addProcClip('rings');

  setTip('Spin rim · 3‑finger Z to lift · clips can fall if unsupported · ✚ test · ⧉ clips · ✸ blend · ⚙ tuner');
  draw();
})();
</script>
</body>
</html>
