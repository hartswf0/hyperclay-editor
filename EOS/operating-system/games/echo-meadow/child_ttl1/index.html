<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Echo Meadow — Child ttl=1</title>
  <style>
    :root { color-scheme: dark; font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    body { margin: 0; background: #071d19; color: #f1f5f9; min-height: 100vh; overflow: hidden; display: flex; align-items: center; justify-content: center; }
    canvas, #fallbackCanvas { width: 100vw; height: 100vh; display: block; }
    .start-overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(7, 29, 25, 0.9); color: #bbf7d0; font-size: clamp(1rem, 3.2vw, 1.9rem); letter-spacing: 0.08em; text-transform: uppercase; backdrop-filter: blur(4px); cursor: pointer; transition: opacity 0.3s ease; z-index: 20; }
    .start-overlay.hidden { opacity: 0; pointer-events: none; }
    .inline-meta { position: fixed; bottom: 1rem; left: 1rem; font-size: 0.66rem; letter-spacing: 0.08em; text-transform: uppercase; opacity: 0.6; pointer-events: none; }
    @media (prefers-reduced-motion: reduce) { .start-overlay { transition: none; } }
  </style>
</head>
<body>
  <div id="overlay" class="start-overlay" role="button" tabindex="0" aria-label="Start Echo Meadow child">
    Tap to send soft pulses.
  </div>
  <div class="inline-meta">Echo Meadow · ttl=1 · child</div>
  <canvas id="fallbackCanvas" hidden aria-hidden="true"></canvas>

  <script id="config" type="application/json">
  {
    "id": "echo-meadow-child-ttl1",
    "title": "Echo Meadow — Child",
    "ttl": 1,
    "offline_mode": false,
    "loop_duration_sec": 58,
    "joy": 0.78,
    "flow": 0.79,
    "accessibility": 0.86,
    "elegance": 0.79,
    "surprise": 0.47,
    "dpr_cap": 2,
    "fps_cap": 60,
    "max_flash_hz": 2,
    "min_linger_ms": 190,
    "visual_palette": {
      "background": "#071d19",
      "orbs": ["#4ade80", "#a855f7"],
      "rings": "#86efac",
      "reduced_motion": "#112722"
    },
    "meadow_profile": {
      "orb_count": 20,
      "orb_size": 0.42,
      "ring_expansion_speed": 0.28,
      "gesture_echo_strength": 0.9,
      "ambient_swirl": 0.12
    },
    "motifs": [
      "tap chords ripple softly"
    ],
    "interaction_model": {
      "primary": "tap",
      "secondary": "drag_optional",
      "fallback": "auto_pulse",
      "reduced_motion_adjustment": "pulses fade"
    },
    "audio": {
      "gesture_gate_required": true,
      "synth": "Tone.Synth",
      "envelope": {"attack": 0.18, "decay": 0.25, "sustain": 0.45, "release": 1.4},
      "scale": ["E4", "G4", "B4"],
      "tempo_bpm": 68
    },
    "audio_layers": {
      "pad_notes": ["E4"],
      "echo_notes": ["G4", "B4"],
      "echo_interval_sec": 5.4
    }
  }
  </script>

  <script id="engine" type="application/poml">
  <poml>
    <engine id="echo-meadow-child-ttl1" ttl="1" offline_mode="false">
      <render pipeline="three.js" fallback="2d-canvas" fps_cap="60" dpr_cap="2" shading="meadow-soft" />
      <audio engine="tone.js" gesture_gate="true" mood="soft-chorus" />
      <safety max_flash_hz="2" min_linger_ms="190" reduced_motion_policy="soft-pulse" />
      <loop duration_sec="58" structure="echo-mini" child_decay="1" />
      <inputs primary="pointer-tap" gestures="drag-optional" fallback_mode="auto-pulse" />
      <surprise band="0.4-0.7" trigger="soft-alignment" />
    </engine>
  </poml>
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js" integrity="sha512-7JFa3wYxVa0hjvZkEvPlIRGKo1PZhelR9yrZjcFIrqYk/fxu6ip1CKhmTFq9sSSrDgV5xtBHXFDgPJ8TyufSEDw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.35/Tone.min.js" integrity="sha512-Td7diaOEsZBWBcy/scMvAEmVdPWxKkrJkeLQzA5Nv1YXhI5RXefxWWEXUOYaL6VLdystD5nq2WEYLRh1SeDsWw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    (() => {
      const config = JSON.parse(document.getElementById('config').textContent);
      const overlay = document.getElementById('overlay');
      const fallbackCanvas = document.getElementById('fallbackCanvas');
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const fpsInterval = 1000 / (config.fps_cap || 60);
      let then = performance.now();

      let renderer, scene, camera, clock;
      const orbs = [];
      const ripples = [];
      const pointer = { x: 0, y: 0 };
      let synth;
      let audioStarted = false;
      let rippleGroup;
      let rippleMaterial;

      document.body.style.background = reduceMotion ? config.visual_palette.reduced_motion : config.visual_palette.background;

      overlay.addEventListener('pointerdown', startExperience);
      overlay.addEventListener('keydown', (event) => { if (event.key === 'Enter' || event.key === ' ') startExperience(); });

      window.addEventListener('resize', () => {
        if (renderer && camera) {
          const width = window.innerWidth;
          const height = window.innerHeight;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        } else {
          resizeFallback();
        }
      });

      function startExperience() {
        if (overlay.classList.contains('hidden')) return;
        overlay.classList.add('hidden');
        setTimeout(() => overlay.remove(), 360);
        startAudio();
        try { initScene(); } catch (error) { console.warn('Meadow child fallback', error); enableFallback(); }
      }

      async function startAudio() {
        if (audioStarted) return;
        try {
          await Tone.start();
          Tone.Transport.bpm.value = config.audio.tempo_bpm || 68;
          Tone.Destination.volume.value = -13;
          synth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: config.audio.envelope, volume: -9 }).toDestination();
          Tone.Transport.start();
          audioStarted = true;
        } catch (err) {
          console.warn('Audio muted', err);
        }
      }

      function initScene() {
        if (!window.THREE) throw new Error('Three.js missing');
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, config.dpr_cap || 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(new THREE.Color(config.visual_palette.background), 1);
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        clock = new THREE.Clock();
        camera = new THREE.PerspectiveCamera(46, window.innerWidth / window.innerHeight, 0.1, 60);
        camera.position.set(0, 3, 8);
        camera.lookAt(0, 0, 0);

        const ambient = new THREE.AmbientLight(0xffffff, reduceMotion ? 0.24 : 0.36);
        scene.add(ambient);

        const ground = new THREE.Mesh(new THREE.CircleGeometry(5.4, 48), new THREE.MeshBasicMaterial({ color: 0x0c2a23, transparent: true, opacity: 0.75 }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        rippleGroup = new THREE.Group();
        rippleGroup.rotation.x = -Math.PI / 2;
        scene.add(rippleGroup);
        rippleMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(config.visual_palette.rings), transparent: true, opacity: reduceMotion ? 0.18 : 0.3, side: THREE.DoubleSide });

        const orbGeometry = new THREE.SphereGeometry(config.meadow_profile.orb_size, 24, 24);
        const orbMaterials = config.visual_palette.orbs.map((color) => new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: reduceMotion ? 0.5 : 0.9, roughness: 0.35, metalness: 0.08 }));

        for (let i = 0; i < config.meadow_profile.orb_count; i++) {
          const mesh = new THREE.Mesh(orbGeometry, orbMaterials[i % orbMaterials.length]);
          const angle = (i / config.meadow_profile.orb_count) * Math.PI * 2;
          const radius = 1 + Math.random() * 3.2;
          mesh.position.set(Math.cos(angle) * radius, 0.45 + Math.random() * 0.3, Math.sin(angle) * radius);
          mesh.userData.phase = Math.random() * Math.PI * 2;
          mesh.userData.radius = radius;
          orbs.push(mesh);
          scene.add(mesh);
        }

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerdown', triggerEcho);

        requestAnimationFrame(loop);
      }

      function onPointerMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      function triggerEcho() {
        const ripple = { radius: 0.1, strength: reduceMotion ? 0.5 : config.meadow_profile.gesture_echo_strength, x: pointer.x * 2.5, z: pointer.y * 2.5 };
        if (rippleGroup && rippleMaterial) {
          const ringGeo = new THREE.RingGeometry(0.08, 0.18, 48);
          const mesh = new THREE.Mesh(ringGeo, rippleMaterial.clone());
          mesh.position.set(ripple.x, 0.02, ripple.z);
          ripple.mesh = mesh;
          rippleGroup.add(mesh);
        }
        ripples.push(ripple);
        if (ripples.length > 6) ripples.shift();
        if (audioStarted && synth) {
          const note = config.audio.scale[Math.floor(Math.random() * config.audio.scale.length)];
          synth.triggerAttackRelease(note, '16n', undefined, 0.4);
        }
      }

      function loop(now) {
        requestAnimationFrame(loop);
        const delta = now - then;
        if (delta < fpsInterval) return;
        then = now - (delta % fpsInterval);
        if (!renderer) return;
        const time = clock.getElapsedTime();
        updateMeadow(time);
        renderer.render(scene, camera);
      }

      function updateMeadow(time) {
        const swirl = config.meadow_profile.ambient_swirl * (reduceMotion ? 0.4 : 1);
        orbs.forEach((orb, idx) => {
          orb.userData.phase += swirl * 0.018;
          const baseRadius = orb.userData.radius;
          orb.position.x = Math.cos(orb.userData.phase) * baseRadius;
          orb.position.z = Math.sin(orb.userData.phase) * baseRadius;
          orb.position.y = 0.5 + Math.sin(time * 0.9 + idx) * 0.12;
          const influence = ripples.reduce((acc, ripple) => {
            const dx = orb.position.x - ripple.x;
            const dz = orb.position.z - ripple.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            return acc + Math.exp(-dist * 0.7) * ripple.strength * Math.max(0, 1 - ripple.radius / 5);
          }, 0);
          orb.scale.setScalar(1 + influence * 0.18);
        });

        for (let i = ripples.length - 1; i >= 0; i--) {
          const ripple = ripples[i];
          ripple.radius += config.meadow_profile.ring_expansion_speed * 0.18;
          ripple.strength *= 0.94;
          if (ripple.mesh) {
            ripple.mesh.geometry.dispose();
            ripple.mesh.geometry = new THREE.RingGeometry(Math.max(0.04, ripple.radius * 0.8), Math.max(0.08, ripple.radius), 48);
            ripple.mesh.material.opacity = Math.max(0.05, (reduceMotion ? 0.16 : 0.28) * ripple.strength);
          }
          if (ripple.strength < 0.05) {
            if (ripple.mesh && ripple.mesh.parent) {
              ripple.mesh.parent.remove(ripple.mesh);
              ripple.mesh.geometry.dispose();
              ripple.mesh.material.dispose();
            }
            ripples.splice(i, 1);
          }
        }
      }

      function enableFallback() {
        fallbackCanvas.hidden = false;
        const ctx = fallbackCanvas.getContext('2d');
        resizeFallback();
        let last = performance.now();
        const orbits = new Array(config.meadow_profile.orb_count).fill(null).map((_, i) => ({ angle: (i / config.meadow_profile.orb_count) * Math.PI * 2, radius: 55 + Math.random() * 70 }));
        let rippleRadius = 0;
        function drawFallback(now) {
          requestAnimationFrame(drawFallback);
          const delta = now - last;
          if (delta < fpsInterval) return;
          last = now - (delta % fpsInterval);
          ctx.fillStyle = reduceMotion ? config.visual_palette.reduced_motion : config.visual_palette.background;
          ctx.fillRect(0, 0, fallbackCanvas.width, fallbackCanvas.height);
          const centerX = fallbackCanvas.width / 2;
          const centerY = fallbackCanvas.height * 0.65;
          orbits.forEach((orbit, idx) => {
            orbit.angle += (config.meadow_profile.ambient_swirl || 0.1) * 0.012;
            const x = centerX + Math.cos(orbit.angle) * orbit.radius;
            const y = centerY + Math.sin(orbit.angle) * 30;
            ctx.fillStyle = `${config.visual_palette.orbs[idx % config.visual_palette.orbs.length]}aa`;
            ctx.beginPath();
            ctx.arc(x, y, 7, 0, Math.PI * 2);
            ctx.fill();
          });
          rippleRadius += config.meadow_profile.ring_expansion_speed * 2.4;
          if (rippleRadius > Math.max(fallbackCanvas.width, fallbackCanvas.height)) rippleRadius = 0;
          ctx.strokeStyle = `${config.visual_palette.rings}55`;
          ctx.lineWidth = 1.6;
          ctx.beginPath();
          ctx.arc(centerX, centerY, rippleRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
        requestAnimationFrame(drawFallback);
      }

      function resizeFallback() {
        fallbackCanvas.width = window.innerWidth;
        fallbackCanvas.height = window.innerHeight;
      }

      window.addEventListener('visibilitychange', () => {
        if (!Tone || !Tone.Transport) return;
        if (document.hidden && Tone.Transport.state === 'started') Tone.Transport.pause();
        else if (!document.hidden && audioStarted && Tone.Transport.state !== 'started') Tone.Transport.start();
      });
    })();
  </script>
</body>
</html>
