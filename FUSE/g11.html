<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FORMA OS: Post-File Operating System</title>
    <style>
        /* ðŸŽ¨ FORMAL DESIGN (Non-Pixel, Non-File) */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ccc;
            font-family: 'SF Mono', 'Courier New', Courier, monospace;
            cursor: none;
        }
        #webgl-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #os-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #a0a0a0;
        }
        #intro-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            max-width: 700px;
            animation: fade-out-slow 15s forwards 3s;
        }
        #intro-screen h1 {
            font-size: 2.5em;
            font-weight: normal;
            color: #fff;
            letter-spacing: 0.1em;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
        }
        #intro-screen p {
            font-size: 1.1em;
            line-height: 1.7;
            color: #999;
        }

        /* ðŸ§° Modular Utilities (UI Forms) */
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            border-radius: 5px;
            max-width: 350px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #hud h2 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
            color: #fff;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 5px;
        }
        #hud p { margin: 4px 0; }
        #hud .key { color: #fff; background: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 3px;}

        #pulse-map-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            border-radius: 50%;
            overflow: hidden;
        }
        #pulse-map {
            width: 100%;
            height: 100%;
        }

        #cursor-presence {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 60%);
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out, background 0.3s;
        }
        
        @keyframes fade-out-slow {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="webgl-container"></div>
    
    <div id="os-overlay">
        <div id="intro-screen">
            <h1>FORMA OS</h1>
            <p>You are not a user. You are a presence stream. <br> This is not a desktop. It is a live memory field. <br> Do not open, save, or close. <br> Tune in, modulate, and let go. <br><br> Hold Shift to tether. Hold Ctrl to fuse.</p>
        </div>

        <div id="hud"></div>

        <div id="pulse-map-container">
            <canvas id="pulse-map"></canvas>
        </div>
    </div>
    <div id="cursor-presence"></div>

    <!-- ðŸ”Œ Tech Scaffold: Three.js for WebGL rendering -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // ðŸ§ ðŸ§ŠðŸ§¬ FORMA OS: A sensory-semantic OS where information is felt, not filed.
        // Presence, movement, and memory replace file paths, windows, and apps.

        class FormaOS {
            constructor() {
                this.initEngine();
                this.initEnvironment();
                this.initInteraction();
                this.initOSModules();
                
                this.populateInitialMemory();
                this.animate();
            }

            // --- 1. ENGINE INITIALIZATION ---
            initEngine() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.camera.position.z = 100;

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                document.getElementById('webgl-container').appendChild(this.renderer.domElement);

                // Post-processing for bloom and presence trails
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.5, 0.8);
                this.composer.addPass(this.bloomPass);
            }

            // --- 2. ENVIRONMENT SETUP ---
            initEnvironment() {
                // Background gradient field
                const backgroundGeometry = new THREE.SphereGeometry(1000, 32, 32);
                const backgroundMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color1: { value: new THREE.Color(0x020011) },
                        color2: { value: new THREE.Color(0x11031a) },
                    },
                    vertexShader: `varying vec3 vUv; void main() { vUv = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
                    fragmentShader: `uniform vec3 color1; uniform vec3 color2; varying vec3 vUv; void main() { gl_FragColor = vec4(mix(color1, color2, smoothstep(-500.0, 500.0, vUv.y)), 1.0); }`,
                    side: THREE.BackSide,
                });
                this.scene.add(new THREE.Mesh(backgroundGeometry, backgroundMaterial));
                
                // Ambient light for form definition
                this.scene.add(new THREE.AmbientLight(0x404040, 2));
                this.pointLight = new THREE.PointLight(0xffffff, 500, 300);
                this.scene.add(this.pointLight);
            }

            // --- 3. INTERACTION & PRESENCE ---
            initInteraction() {
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.mouse3D = new THREE.Vector3(); // Mouse position in 3D space
                this.plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

                this.activeUnit = null;
                this.tethering = { active: false, source: null };
                this.fusing = { active: false, source: null };
                
                this.mouseState = { down: false, hold: false, lastDownTime: 0 };
                this.holdTimeout = null;

                // ðŸ§¬ 4. IDENTITY AS TRACE
                this.presenceTrail = this.createPresenceTrail();
                this.scene.add(this.presenceTrail);

                this.cursorPresence = document.getElementById('cursor-presence');

                window.addEventListener('mousemove', this.onMouseMove.bind(this));
                window.addEventListener('mousedown', this.onMouseDown.bind(this));
                window.addEventListener('mouseup', this.onMouseUp.bind(this));
                window.addEventListener('keydown', (e) => this.updateModifierKeys(e, true));
                window.addEventListener('keyup', (e) => this.updateModifierKeys(e, false));
                window.addEventListener('resize', this.onResize.bind(this));
            }
            
            updateModifierKeys(e, isDown) {
                if (e.key === 'Shift') this.tethering.active = isDown;
                if (e.key === 'Control' || e.key === 'Meta') this.fusing.active = isDown;
                this.updateCursorStyle();
            }

            // --- 4. OS MODULES & DATA ---
            initOSModules() {
                this.memoryUnits = [];
                this.bridges = [];

                // ðŸ§° PulseMap
                this.pulseMap = {
                    canvas: document.getElementById('pulse-map'),
                    ctx: document.getElementById('pulse-map').getContext('2d'),
                    size: 200,
                    range: 150, // 3D units to map to the canvas
                };

                // ðŸ§° HUD
                this.hud = document.getElementById('hud');
            }

            populateInitialMemory() {
                const initialMemory = [
                    { type: 'text', content: 'Ontological Heuristics', state: 'Solid' },
                    { type: 'sound', content: 'Ambient Drone A', state: 'Fluid' },
                    { type: 'video', content: 'Field of flickering light', state: 'Fluid' },
                    { type: 'code', content: 'class FormaOS { ... }', state: 'Solid' },
                    { type: 'link', content: 'https://en.wikipedia.org/wiki/Emergence', state: 'Fluid' },
                    { type: 'text', content: 'An ephemeral thought...', state: 'Gas' },
                    { type: 'sound', content: 'Sharp transient', state: 'Gas' },
                ];
                initialMemory.forEach(mem => this.addMemoryUnit(mem));
            }

            // --- CORE OS LOGIC ---
            
            // ðŸŒ€ 1. MEMORY AS FIELD: Add a new presence to the field
            addMemoryUnit(mem) {
                const unit = new MemoryUnit(mem, this);
                this.memoryUnits.push(unit);
                this.scene.add(unit.mesh);
            }
            
            // ðŸ§¬ 4. IDENTITY AS TRACE
            createPresenceTrail() {
                const trailPoints = 50;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(trailPoints * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xffffff, 
                    linewidth: 2, 
                    transparent: true,
                    opacity: 0.25 
                });
                
                const trail = new THREE.Line(geometry, material);
                trail.frustumCulled = false;
                trail.userData.trailIndex = 0;
                return trail;
            }

            updatePresenceTrail() {
                const positions = this.presenceTrail.geometry.attributes.position.array;
                const index = this.presenceTrail.userData.trailIndex;

                positions[index * 3] = this.mouse3D.x;
                positions[index * 3 + 1] = this.mouse3D.y;
                positions[index * 3 + 2] = this.mouse3D.z;

                // Make the trail "snake"
                if (index > 0) {
                    positions[(index - 1) * 3] = this.mouse3D.x;
                    positions[(index - 1) * 3 + 1] = this.mouse3D.y;
                    positions[(index - 1) * 3 + 2] = this.mouse3D.z;
                }

                this.presenceTrail.userData.trailIndex = (index + 1) % positions.length / 3;
                this.presenceTrail.geometry.attributes.position.needsUpdate = true;
            }


            // --- EVENT HANDLERS ---
            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                this.raycaster.ray.intersectPlane(this.plane, this.mouse3D);
                
                this.cursorPresence.style.left = `${event.clientX}px`;
                this.cursorPresence.style.top = `${event.clientY}px`;

                // ðŸ› ï¸ DriftEdit: Modify content via ambient drag
                if (this.mouseState.hold && this.activeUnit) {
                    this.activeUnit.driftEdit(this.mouse3D);
                }
            }

            onMouseDown(event) {
                this.mouseState.down = true;
                this.mouseState.lastDownTime = Date.now();
                
                const intersects = this.raycaster.intersectObjects(this.memoryUnits.map(u => u.mesh));
                
                if (intersects.length > 0) {
                    const intersectedUnit = intersects[0].object.userData.unit;
                    this.setActiveUnit(intersectedUnit);

                    // ðŸ› ï¸ INTERACTION AS MODULATION: Hold = stabilize and study
                    this.holdTimeout = setTimeout(() => {
                        this.mouseState.hold = true;
                        this.activeUnit.stabilize(true);
                        this.updateCursorStyle();
                    }, 300);

                } else {
                    this.setActiveUnit(null);
                }
            }
            
            onMouseUp(event) {
                clearTimeout(this.holdTimeout);
                
                if (this.activeUnit) {
                    this.activeUnit.stabilize(false);
                    
                    const intersects = this.raycaster.intersectObjects(this.memoryUnits.map(u => u.mesh));
                    if (intersects.length > 0) {
                        const targetUnit = intersects[0].object.userData.unit;
                        
                        // ðŸ› ï¸ Tether or Fuse on mouse up over a target
                        if (this.tethering.active && this.tethering.source && targetUnit !== this.tethering.source) {
                            this.createBridge(this.tethering.source, targetUnit);
                        }
                        if (this.fusing.active && this.fusing.source && targetUnit !== this.fusing.source) {
                            this.fuseUnits(this.fusing.source, targetUnit);
                        }
                    }
                }
                
                this.mouseState.down = false;
                this.mouseState.hold = false;
                this.updateCursorStyle();
            }

            // --- OS ACTIONS ---
            setActiveUnit(unit) {
                if (this.activeUnit === unit) return;
                
                if (this.activeUnit) {
                    this.activeUnit.setActive(false);
                }
                this.activeUnit = unit;
                if (this.activeUnit) {
                    this.activeUnit.setActive(true);
                    this.tethering.source = unit;
                    this.fusing.source = unit;
                } else {
                    this.tethering.source = null;
                    this.fusing.source = null;
                }
                this.updateHUD();
            }

            // ðŸ› ï¸ Bridge: Link zones/presences temporally
            createBridge(unitA, unitB) {
                const bridge = new Bridge(unitA, unitB);
                this.bridges.push(bridge);
                this.scene.add(bridge.mesh);
            }

            // ðŸ› ï¸ Stack = fuse multiple items
            fuseUnits(unitA, unitB) {
                const newContent = `${unitA.media.content} + ${unitB.media.content}`;
                const newType = unitA.media.type; // Simple fusion logic
                const newState = 'Solid'; // Fused objects become solid
                const newPosition = unitA.mesh.position.clone().lerp(unitB.mesh.position, 0.5);

                const newMem = { type: newType, content: newContent, state: newState };
                const newUnit = new MemoryUnit(newMem, this);
                newUnit.mesh.position.copy(newPosition);
                newUnit.mesh.scale.setScalar(unitA.baseScale + unitB.baseScale); // Become larger
                
                this.memoryUnits.push(newUnit);
                this.scene.add(newUnit.mesh);
                
                unitA.destroy();
                unitB.destroy();
                
                // Remove from main array
                this.memoryUnits = this.memoryUnits.filter(u => u !== unitA && u !== unitB);
                
                this.setActiveUnit(newUnit);
            }

            // --- UI & RENDER LOOP ---
            updateHUD() {
                if (this.activeUnit) {
                    this.hud.style.opacity = '1';
                    this.hud.innerHTML = `
                        <h2>PRESENCE: ${this.activeUnit.media.type}</h2>
                        <p><strong>Content:</strong> ${this.activeUnit.media.content}</p>
                        <p><strong>State:</strong> ${this.activeUnit.media.state}</p>
                        <p><strong>Zone:</strong> ${this.activeUnit.zone}</p>
                        <p><span class="key">Hold</span> to Stabilize/Edit</p>
                        <p><span class="key">Shift</span> to Tether</p>
                        <p><span class="key">Ctrl</span> to Fuse</p>
                    `;
                } else {
                    this.hud.style.opacity = '0';
                }
            }

            updateCursorStyle() {
                let style = '';
                if(this.mouseState.hold) {
                    style = 'radial-gradient(circle, rgba(100,255,100,0.5) 0%, rgba(255,255,255,0) 60%)';
                } else if(this.tethering.active) {
                    style = 'radial-gradient(circle, rgba(100,100,255,0.5) 0%, rgba(255,255,255,0) 60%)';
                } else if(this.fusing.active) {
                    style = 'radial-gradient(circle, rgba(255,100,100,0.5) 0%, rgba(255,255,255,0) 60%)';
                } else {
                     style = 'radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 60%)';
                }
                this.cursorPresence.style.background = style;
            }
            
            // ðŸ§° PulseMap Renderer
            drawPulseMap() {
                const ctx = this.pulseMap.ctx;
                const size = this.pulseMap.size;
                const range = this.pulseMap.range;
                ctx.clearRect(0, 0, size, size);

                // Draw self presence (center)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, 3, 0, Math.PI * 2);
                ctx.fill();

                this.memoryUnits.forEach(unit => {
                    const x = (unit.mesh.position.x / range) * (size / 2) + (size / 2);
                    const z = (unit.mesh.position.z / range) * (size / 2) + (size / 2);
                    
                    if (x > 0 && x < size && z > 0 && z < size) {
                        ctx.fillStyle = unit.isActive ? '#ffffff' : unit.color.getStyle();
                        const radius = unit.isActive ? 5 : 2;
                        ctx.beginPath();
                        ctx.arc(x, z, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                // Update camera to drift towards mouse
                const targetCamX = -this.mouse.x * 20;
                const targetCamY = this.mouse.y * 20;
                this.camera.position.x += (targetCamX - this.camera.position.x) * 0.02;
                this.camera.position.y += (targetCamY - this.camera.position.y) * 0.02;
                this.camera.lookAt(this.scene.position);

                // Update point light to follow cursor
                this.pointLight.position.copy(this.mouse3D);

                // Update all OS components
                this.memoryUnits.forEach(unit => unit.update());
                this.bridges.forEach(bridge => bridge.update());
                this.updatePresenceTrail();
                this.drawPulseMap();

                this.composer.render();
            }
        }
        
        // --- MEMORY UNIT CLASS ---
        // The core "object" of FORMA OS, representing a piece of data.
        class MemoryUnit {
            constructor(media, os) {
                this.os = os; // Reference to the main OS
                this.media = media;
                this.color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6);
                this.baseScale = 5 + Math.random() * 5;
                this.isActive = false;
                this.isStable = false;
                
                this.mesh = this.createMesh();
                this.mesh.userData.unit = this; // Link back
                
                this.velocity = new THREE.Vector3().randomDirection().multiplyScalar(0.05);
                this.zone = 'Flow';
            }

            createMesh() {
                let geometry, material;
                const size = this.baseScale;
                
                // ðŸŒ€ 1. MEMORY AS FIELD: Forms are determined by media type
                switch (this.media.type) {
                    case 'text': // Density
                        geometry = new THREE.IcosahedronGeometry(size, 2);
                        material = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.8 });
                        break;
                    case 'sound': // Tone blob
                        geometry = new THREE.SphereGeometry(size, 32, 32);
                        material = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.1, metalness: 0.2 });
                        break;
                    case 'video': // Motion
                        geometry = new THREE.BoxGeometry(size * 1.6, size, size * 0.2);
                        material = new THREE.MeshStandardMaterial({ color: this.color });
                        break;
                    case 'link': // Radiant flux
                        geometry = new THREE.TorusKnotGeometry(size * 0.8, size * 0.2, 100, 16);
                        material = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.3, metalness: 0.7, emissive: this.color, emissiveIntensity: 0.1 });
                        break;
                    case 'code': // Structure
                        geometry = new THREE.BoxGeometry(size, size, size);
                        material = new THREE.MeshBasicMaterial({ color: this.color, wireframe: true });
                        break;
                }

                // ðŸ§± 5. STRUCTURE AS VISCOSITY
                if (this.media.state === 'Gas') {
                    material.transparent = true;
                    material.opacity = 0.3;
                }

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 150,
                    (Math.random() - 0.5) * 150,
                    (Math.random() - 0.5) * 150
                );
                return mesh;
            }

            update() {
                if (this.isStable) return;

                // ðŸ§­ 2. NAVIGATION AS GRAVITY/ZONES
                this.applyZonePhysics();

                // Apply velocity
                this.mesh.position.add(this.velocity);
                this.mesh.rotation.x += this.velocity.length() * 0.01;
                this.mesh.rotation.y += this.velocity.length() * 0.02;

                // ðŸ§± 5. STRUCTURE AS VISCOSITY behavior
                if (this.media.state === 'Fluid' && this.mesh.geometry.attributes.position) {
                    // Jiggle fluid forms
                    const time = Date.now() * 0.002;
                    const positions = this.mesh.geometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const p = new THREE.Vector3().fromBufferAttribute(positions, i);
                        p.normalize().multiplyScalar(this.baseScale + Math.sin(p.x * 2 + time) * 0.5);
                        positions.setXYZ(i, p.x, p.y, p.z);
                    }
                    this.mesh.geometry.attributes.position.needsUpdate = true;
                }
            }
            
            applyZonePhysics() {
                const pos = this.mesh.position;
                const stillnessZoneRadius = 40;
                
                if (this.isActive && this.os.activeUnit === this) {
                    // ðŸ§­ Resonance Zone: active objects pull similar types closer
                    this.zone = 'Resonance';
                    this.os.memoryUnits.forEach(other => {
                        if (other !== this && other.media.type === this.media.type) {
                            const direction = pos.clone().sub(other.mesh.position).normalize();
                            other.velocity.add(direction.multiplyScalar(0.005));
                        }
                    });
                    this.velocity.multiplyScalar(0.95); // Damping when active
                } else if (pos.length() < stillnessZoneRadius) {
                    // ðŸ§­ Stillness Zone
                    this.zone = 'Stillness';
                    this.velocity.multiplyScalar(0.9); // Heavy damping
                } else {
                    // ðŸ§­ Flow Zone
                    this.zone = 'Flow';
                    // Gravitational pull towards center
                    this.velocity.add(pos.clone().multiplyScalar(-0.0001));
                    // Basic viscosity
                    this.velocity.multiplyScalar(this.media.state === 'Gas' ? 0.995 : 0.99); 
                }
                
                // Repulsion from other objects
                this.os.memoryUnits.forEach(other => {
                    if (other === this) return;
                    const distance = pos.distanceTo(other.mesh.position);
                    if (distance < this.baseScale + other.baseScale + 10) {
                        const repulsion = pos.clone().sub(other.mesh.position).normalize();
                        this.velocity.add(repulsion.multiplyScalar(0.05));
                    }
                });
            }

            // ðŸ› ï¸ 3. INTERACTION AS MODULATION
            setActive(isActive) {
                this.isActive = isActive;
                const emissiveIntensity = isActive ? 0.8 : (this.media.type === 'link' ? 0.1 : 0);
                if (this.mesh.material.emissive) {
                    this.mesh.material.emissive.set(this.color);
                    this.mesh.material.emissiveIntensity = emissiveIntensity;
                }
                this.os.bloomPass.strength = isActive ? 1.5 : 0.8;
            }

            stabilize(isStable) {
                this.isStable = isStable;
            }
            
            // ðŸ› ï¸ DriftEdit simulation
            driftEdit(mousePos) {
                if (this.media.type === 'sound' || this.media.type === 'text') {
                    // Clay-like manipulation by pulling the object
                    const pullForce = mousePos.clone().sub(this.mesh.position).multiplyScalar(0.01);
                    this.mesh.position.add(pullForce);
                }
            }

            destroy() {
                this.os.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // --- BRIDGE CLASS ---
        // ðŸ› ï¸ Bridge: Represents a tether between two MemoryUnits
        class Bridge {
            constructor(unitA, unitB) {
                this.unitA = unitA;
                this.unitB = unitB;
                
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5,
                    linewidth: 1,
                });
                const geometry = new THREE.BufferGeometry().setFromPoints([unitA.mesh.position, unitB.mesh.position]);
                this.mesh = new THREE.Line(geometry, material);
            }

            update() {
                const positions = this.mesh.geometry.attributes.position;
                positions.setXYZ(0, this.unitA.mesh.position.x, this.unitA.mesh.position.y, this.unitA.mesh.position.z);
                positions.setXYZ(1, this.unitB.mesh.position.x, this.unitB.mesh.position.y, this.unitB.mesh.position.z);
                positions.needsUpdate = true;
            }
        }

        // --- INITIALIZE THE OS ---
        new FormaOS();

    </script>
</body>
</html>