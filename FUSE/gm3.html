<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß¨ GENOMIRE SCOPE</title>
    <style>
        :root {
            --phosphor-green: #4cff4c;
            --phosphor-green-dim: #2a7d2a;
            --bg-black: #020402;
            --glow: 0 0 5px var(--phosphor-green-dim);
            --font-console: 'Menlo', 'Monaco', 'Courier New', monospace;
            --font-ui: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        /* --- Global & Tufte Principles --- */
        * { box-sizing: border-box; }

        html, body {
            background-color: var(--bg-black);
            color: var(--phosphor-green);
            font-family: var(--font-console);
            font-size: 15px;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        /* --- üåä MIRE Field (Pixel Resonance Terrain) --- */
        #mire-field-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .mire-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0.5;
        }

        /* --- Main Layout --- */
        #genomire-scope {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: row;
        }

        /* --- üß¨ Electrophoresis Genome Columns --- */
        #genome-columns {
            width: 280px;
            height: 100%;
            padding: 20px 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: row;
            gap: 15px;
            flex-shrink: 0;
            scrollbar-width: thin;
            scrollbar-color: var(--phosphor-green-dim) var(--bg-black);
            background: linear-gradient(to right, rgba(0,0,0,0.5), rgba(0,0,0,0));
        }

        .strand {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            width: 25px; /* Fixed width for each strand's lane */
            flex-shrink: 0;
        }
        
        .strand-id {
            font-family: var(--font-ui);
            font-size: 12px;
            color: var(--phosphor-green-dim);
            margin-bottom: 10px;
            transition: color 0.3s;
        }

        .strand:hover .strand-id {
            color: var(--phosphor-green);
            text-shadow: var(--glow);
        }

        .electrophoresis-gel {
            width: 100%;
            background: rgba(10, 20, 10, 0.2);
            padding: 5px 2px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .codon-band {
            width: 100%;
            height: 4px; /* All bands have a base height */
            transition: opacity 0.5s ease, box-shadow 0.5s ease, background-color 0.5s ease;
            animation: flicker 5s infinite ease-in-out;
        }

        .codon-band.intron {
            filter: saturate(0.5);
        }

        /* Real color-coded electrophoresis */
        .codon-band[data-type="TXT"] { background-color: #33a0ff; animation-delay: 0.1s; }
        .codon-band[data-type="IMG"] { background-color: #ff33a0; animation-delay: 0.2s; }
        .codon-band[data-type="AUC"] { background-color: #a0ff33; animation-delay: 0.3s; }
        .codon-band[data-type="VID"] { background-color: #ff8c33; animation-delay: 0.4s; }
        .codon-band[data-type="SRC"] { background-color: #be33ff; animation-delay: 0.5s; }
        .codon-band[data-type="LNK"] { background-color: #ffff33; animation-delay: 0.6s; }
        .codon-band[data-type="FRG"] { background-color: #7f7f7f; animation-delay: 0.7s; }
        .codon-band[data-type="CMD"] { background-color: #ff4d4d; animation-delay: 0.8s; }

        @keyframes flicker {
            0%, 100% { transform: scaleX(1); }
            50% { transform: scaleX(0.95); }
        }

        /* --- üñ•Ô∏è Phenotype Console --- */
        #console-wrapper {
            flex-grow: 1;
            height: 100%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            cursor: text;
        }
        
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            scrollbar-width: thin;
            scrollbar-color: var(--phosphor-green-dim) var(--bg-black);
        }

        #input-line { display: flex; }
        #prompt { white-space: nowrap; }
        #input {
            flex-grow: 1;
            background: transparent;
            border: none;
            outline: none;
            color: var(--phosphor-green);
            font-family: inherit;
            font-size: inherit;
            padding: 0;
            margin: 0;
        }
        #caret {
            display: inline-block;
            width: 10px;
            height: 1.2em;
            background: var(--phosphor-green);
            animation: blink 1s step-end infinite;
            vertical-align: bottom;
        }
        @keyframes blink { 50% { opacity: 0; } }

        /* Expression Output Styles (Tufte-inspired) */
        .output-block {
            margin: 1.5em 0;
            padding-top: 1em;
            border-top: 1px solid var(--phosphor-green-dim);
        }
        .output-title {
            color: var(--phosphor-green-dim);
            font-family: var(--font-ui);
            font-size: 0.9em;
            margin-bottom: 0.5em;
        }
        .output-text {
            font-family: 'Georgia', serif;
            max-width: 70ch;
            line-height: 1.7;
            color: #d0ffd0;
        }
        .output-image {
            filter: grayscale(1) contrast(1.2);
            max-width: 150px;
            max-height: 150px;
            display: block;
            image-rendering: pixelated;
            border: 1px solid var(--phosphor-green-dim);
            padding: 2px;
            background: var(--bg-black);
        }
        .output-code {
            background: rgba(76, 255, 76, 0.05);
            padding: 1em;
        }
        .output-sparkline {
            color: var(--phosphor-green-dim);
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #genomire-scope { flex-direction: column; }
            #genome-columns {
                width: 100%;
                height: 180px; /* Fixed height for horizontal scroll */
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 10px;
                background: linear-gradient(to bottom, rgba(0,0,0,0.5), rgba(0,0,0,0));
            }
            #console-wrapper {
                height: calc(100% - 180px);
                padding: 10px;
            }
        }
    </style>
</head>
<body>

    <div id="genomire-scope">
        <!-- üåä MIRE Field -->
        <div id="mire-field-container">
            <canvas class="mire-canvas" id="mire-canvas-far"></canvas>
            <canvas class="mire-canvas" id="mire-canvas-mid"></canvas>
            <canvas class="mire-canvas" id="mire-canvas-near"></canvas>
        </div>

        <!-- üß¨ Electrophoresis Genome Columns -->
        <div id="genome-columns"></div>

        <!-- üñ•Ô∏è Phenotype Console -->
        <div id="console-wrapper" onclick="document.getElementById('input').focus()">
            <div id="output"></div>
            <div id="input-line">
                <span id="prompt">> </span>
                <input type="text" id="input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                <span id="caret"></span>
            </div>
        </div>
    </div>

    <script>
    const GENOMIRE_SCOPE = {
        // --- System Composition ---
        genome: [],
        console: {
            output: null, input: null, history: [], historyIndex: -1
        },
        mire: {
            canvases: {}, ctx: {}, particles: {}, hotspots: [], mouse: { x: 0, y: 0 }
        },
        codons: {
            "TXT": { glyph: "‚ñö", color: "#33a0ff", desc: "Textual Data" },
            "IMG": { glyph: "‚ñû", color: "#ff33a0", desc: "Image Data" },
            "AUC": { glyph: "‚ô™", color: "#a0ff33", desc: "Audio Data" },
            "VID": { glyph: "‚ñ∫", color: "#ff8c33", desc: "Video Data" },
            "SRC": { glyph: "‚åò", color: "#be33ff", desc: "Source Code" },
            "LNK": { glyph: "Œ∂", color: "#ffff33", desc: "Link to Strand" },
            "FRG": { glyph: "Œ£", color: "#7f7f7f", desc: "Data Fragment" },
            "CMD": { glyph: "‚ö°", color: "#ff4d4d", desc: "Executable Command" },
        },
        
        // --- Initial Data Schema ---
        generateInitialGenome: function() {
            this.genome = [
                {
                    genome_id: "scope-Œ±32",
                    codons: ["TXT", "IMG", "FRG", "AUC", "CMD"],
                    exons: [0, 1],
                    phenotype_type: "multimodal",
                    mutation_rate: 0.08,
                    last_expressed: new Date(Date.now() - 1000 * 60 * 5).toISOString(),
                    resonance_coords: [0.25, 0.4, 0.5],
                    data: {
                        TXT: "This is a composite entity, expressing both visual and textual data. Its origin traces back to an early system fork. The fragment 'FRG' is inactive but contains checksums for data integrity.",
                        IMG: "https://picsum.photos/seed/scope-a32/200/200",
                    }
                },
                {
                    genome_id: "archive-Œ∂9",
                    codons: ["LNK", "FRG", "FRG", "TXT"],
                    exons: [0, 3],
                    phenotype_type: "archival-link",
                    mutation_rate: 0.01,
                    last_expressed: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(),
                    resonance_coords: [0.8, 0.8, 0.2],
                    data: {
                        LNK: "scope-Œ±32",
                        TXT: "A deep archive pointer. The link is stable but the reference data shows significant temporal decay."
                    }
                },
                {
                    genome_id: "kernel-patch",
                    codons: ["SRC", "CMD", "FRG"],
                    exons: [0, 1],
                    phenotype_type: "executable",
                    mutation_rate: 0.02,
                    last_expressed: new Date(Date.now() - 1000 * 60 * 30).toISOString(),
                    resonance_coords: [0.5, 0.2, 0.8],
                    data: {
                        SRC: `const patchSystem = (kernel) => {\n  if (kernel.version < 2.0) {\n    kernel.memory.reallocate(0.2);\n    return { status: 'patched' };\n  }\n  return { status: 'incompatible' };\n};`,
                        CMD: "run(patchSystem)"
                    }
                },
                {
                    genome_id: "audio-log-7",
                    codons: ["FRG", "AUC", "FRG"],
                    exons: [1],
                    phenotype_type: "auditory",
                    mutation_rate: 0.05,
                    last_expressed: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(),
                    resonance_coords: [0.1, 0.9, 0.6],
                    data: {
                        AUC: "Signal Log: Carrier wave at 1.2GHz detected. Modulated with low-frequency harmonic sequence. Possible non-human origin. Data packet corrupt at tail end."
                    }
                },
            ];
        },
        
        // --- System Initialization ---
        init: function() {
            // Console
            this.console.output = document.getElementById('output');
            this.console.input = document.getElementById('input');
            this.console.input.addEventListener('keydown', this.handleInput.bind(this));

            // MIRE Field
            this.mire.canvases = {
                near: document.getElementById('mire-canvas-near'),
                mid: document.getElementById('mire-canvas-mid'),
                far: document.getElementById('mire-canvas-far'),
            };
            this.mire.ctx = {
                near: this.mire.canvases.near.getContext('2d'),
                mid: this.mire.canvases.mid.getContext('2d'),
                far: this.mire.canvases.far.getContext('2d'),
            };
            window.addEventListener('resize', this.resizeMire.bind(this));
            window.addEventListener('mousemove', e => {
                this.mire.mouse.x = e.clientX / window.innerWidth;
                this.mire.mouse.y = e.clientY / window.innerHeight;
            });
            this.setupMireParticles();
            
            // Core Logic
            this.generateInitialGenome();
            this.renderGenome();

            // Welcome
            this.logOutput(`GENOMIRE SCOPE :: Codified Multilayer Media Expression Engine\nSystem nominal. Type 'help' for commands.`);
            
            this.animate();
        },

        // --- üñ•Ô∏è Console Logic ---
        handleInput: function(e) { /* (Same as previous version, omitted for brevity) */ 
             if (e.key === 'Enter') {
                e.preventDefault();
                const command = this.console.input.value.trim();
                if (command) {
                    this.logOutput(`> ${command}`);
                    this.console.history.push(command);
                    this.console.historyIndex = this.console.history.length;
                    this.processCommand(command);
                }
                this.console.input.value = '';
                this.console.output.scrollTop = this.console.output.scrollHeight;
            } else if (e.key === 'ArrowUp') {
                if (this.console.historyIndex > 0) {
                    this.console.historyIndex--;
                    this.console.input.value = this.console.history[this.console.historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                 if (this.console.historyIndex < this.console.history.length - 1) {
                    this.console.historyIndex++;
                    this.console.input.value = this.console.history[this.console.historyIndex];
                } else {
                    this.console.historyIndex = this.console.history.length;
                    this.console.input.value = '';
                }
            }
        },

        processCommand: function(command) {
            const [cmd, ...args] = command.toLowerCase().split(/\s+/);
            
            switch(cmd) {
                case 'help':
                    this.logOutput(`Available commands:
  express <id>          - Renders the phenotype from a strand's exons.
  trace <id>            - Displays metadata and codon sequence of a strand.
  fuse <id1>+<id2>        - Splices two strands to create a new one.
  mutate <id> [rate=n]  - Induces random mutation in a strand.
  echo <message>        - Prints a message to the console.
  clear                 - Clears the console output.`);
                    break;
                case 'express': this.commandExpress(args[0]); break;
                case 'trace': this.commandTrace(args[0]); break;
                case 'fuse': this.commandFuse(args[0]); break;
                case 'mutate': this.commandMutate(args); break;
                case 'echo': this.logOutput(command.substring(5)); break;
                case 'clear': this.console.output.innerHTML = ''; break;
                default: this.logOutput(`Error: Command not recognized: '${cmd}'`);
            }
        },

        // --- Command Implementations ---
        findStrand: function(id_or_index) {
            const index = parseInt(id_or_index);
            if (!isNaN(index) && this.genome[index]) return {strand: this.genome[index], index: index};
            const foundIndex = this.genome.findIndex(s => s.genome_id.toLowerCase() === id_or_index.toLowerCase());
            if (foundIndex > -1) return {strand: this.genome[foundIndex], index: foundIndex};
            return {strand: null, index: -1};
        },

        commandExpress: function(targetId) {
            if (!targetId) { this.logOutput("Error: 'express' requires a strand ID or index."); return; }
            const { strand } = this.findStrand(targetId);
            if (!strand) { this.logOutput(`Error: Strand '${targetId}' not found.`); return; }

            let output = `<div class="output-block"><div class="output-title">EXPRESSION :: ${strand.genome_id} :: ${strand.phenotype_type}</div>`;
            let expressedCount = 0;
            strand.exons.forEach(exonIndex => {
                const codonType = strand.codons[exonIndex];
                if (codonType) {
                    output += this.getExpressionHTML(strand, codonType);
                    expressedCount++;
                }
            });

            if(expressedCount === 0) {
                output += `<div>Strand ${strand.genome_id} contains no expressible exons.</div>`;
            }
            output += `</div>`;
            this.logOutput(output, true);

            strand.last_expressed = new Date().toISOString();
            this.mire.hotspots.push({
                coords: strand.resonance_coords,
                intensity: 1.0,
                color: this.codons[strand.codons[strand.exons[0]] || 'FRG'].color
            });
            this.renderGenome(); // Re-render to show updated relevance
        },
        
        commandTrace: function(targetId) {
            if (!targetId) { this.logOutput("Error: 'trace' requires a strand ID or index."); return; }
            const { strand } = this.findStrand(targetId);
            if (!strand) { this.logOutput(`Error: Strand '${targetId}' not found.`); return; }
            
            let output = `[TRACING STRAND ${strand.genome_id}]\n`;
            output += `  Phenotype: ${strand.phenotype_type}\n`;
            output += `  Mutation Rate: ${strand.mutation_rate}\n`;
            output += `  Last Expressed: ${new Date(strand.last_expressed).toLocaleString()}\n`;
            output += `  Resonance Coords: [${strand.resonance_coords.map(c => c.toFixed(2)).join(', ')}]\n`;
            output += `  Codon Sequence:\n`;
            strand.codons.forEach((c, i) => {
                const isExon = strand.exons.includes(i);
                const status = isExon ? 'EXON' : 'intron';
                const glyph = this.codons[c].glyph;
                output += `    ${i}: [${glyph} ${c}] - ${status}\n`;
            });
            this.logOutput(output);
        },
        
        commandMutate: function(args) {
            const targetId = args[0];
            if (!targetId) { this.logOutput("Error: 'mutate' requires a strand ID."); return; }
            const { strand } = this.findStrand(targetId);
            if (!strand) { this.logOutput(`Error: Strand '${targetId}' not found.`); return; }

            let rate = strand.mutation_rate;
            const rateArg = args.find(a => a.startsWith('rate='));
            if (rateArg) {
                rate = parseFloat(rateArg.split('=')[1]);
            }
            
            this.logOutput(`Inducing mutation in ${strand.genome_id} with probability ${rate}...`);
            let mutationOccurred = false;
            for(let i=0; i < strand.codons.length; i++) {
                if (Math.random() < rate) {
                    mutationOccurred = true;
                    const originalCodon = strand.codons[i];
                    const codonTypes = Object.keys(this.codons);
                    let newCodon = originalCodon;
                    while (newCodon === originalCodon) {
                        newCodon = codonTypes[Math.floor(Math.random() * codonTypes.length)];
                    }
                    strand.codons[i] = newCodon;
                    this.logOutput(`  > Codon ${i} (${originalCodon}) mutated to (${newCodon})`);

                    // Also mutate exon/intron status
                    if(Math.random() < 0.3) {
                        const exonIndex = strand.exons.indexOf(i);
                        if (exonIndex > -1) {
                            strand.exons.splice(exonIndex, 1);
                            this.logOutput(`    > Codon ${i} silenced (now an intron).`);
                        } else {
                            strand.exons.push(i);
                            this.logOutput(`    > Codon ${i} activated (now an exon).`);
                        }
                    }
                }
            }
            if(mutationOccurred) {
                strand.last_expressed = new Date().toISOString(); // Mutation makes it "relevant"
                this.renderGenome();
            } else {
                this.logOutput("No mutation occurred at current rate.");
            }
        },

        commandFuse: function(targetStr) {
            if (!targetStr || !targetStr.includes('+')) { this.logOutput("Error: 'fuse' requires two IDs separated by '+'. (e.g., fuse 0+1)"); return; }
            
            const [id1, id2] = targetStr.split('+');
            const { strand: s1 } = this.findStrand(id1);
            const { strand: s2 } = this.findStrand(id2);

            if (!s1 || !s2) { this.logOutput("Error: One or both strands for fusion not found."); return; }

            this.logOutput(`Fusing ${s1.genome_id} and ${s2.genome_id}...`);

            const newCodons = s1.codons.slice(0, Math.ceil(s1.codons.length / 2))
                .concat(s2.codons.slice(Math.floor(s2.codons.length / 2)));
            
            const newExons = s1.exons.filter(i => i < Math.ceil(s1.codons.length / 2))
                .concat(s2.exons.filter(i => i >= Math.floor(s2.codons.length / 2)).map(i => i + Math.ceil(s1.codons.length / 2) - Math.floor(s2.codons.length / 2)));

            const newStrand = {
                genome_id: `scope-fus${this.genome.length}`,
                codons: newCodons,
                exons: newExons,
                phenotype_type: "hybrid",
                mutation_rate: (s1.mutation_rate + s2.mutation_rate) / 2,
                last_expressed: new Date().toISOString(),
                resonance_coords: s1.resonance_coords.map((c, i) => (c + s2.resonance_coords[i]) / 2),
                data: { ...s1.data, ...s2.data }
            };

            this.genome.push(newStrand);
            this.logOutput(`Splicing complete. New strand ${newStrand.genome_id} created.`);
            this.renderGenome();
        },

        // --- üß¨ Genome & Expression Rendering ---
        renderGenome: function() {
            const container = document.getElementById('genome-columns');
            container.innerHTML = '';
            this.genome.forEach((strand, index) => {
                const strandEl = document.createElement('div');
                strandEl.className = 'strand';
                strandEl.title = `[${index}] ${strand.genome_id}\nClick to trace`;
                strandEl.onclick = () => {
                    this.logOutput(`> trace ${index}`);
                    this.processCommand(`trace ${index}`);
                };

                const idEl = document.createElement('div');
                idEl.className = 'strand-id';
                idEl.textContent = `[${index}]`;
                
                const gelEl = document.createElement('div');
                gelEl.className = 'electrophoresis-gel';

                // Intensity shows age/relevance
                const age = Date.now() - new Date(strand.last_expressed).getTime();
                const relevance = Math.max(0.2, Math.exp(-age / (1000 * 60 * 60))); // Exponential decay over an hour

                strand.codons.forEach((codonType, i) => {
                    const bandEl = document.createElement('div');
                    bandEl.className = 'codon-band';
                    if (!strand.exons.includes(i)) {
                        bandEl.classList.add('intron');
                    }
                    bandEl.dataset.type = codonType;
                    bandEl.style.opacity = relevance;
                    bandEl.style.boxShadow = `0 0 ${relevance * 8}px ${this.codons[codonType].color}`;
                    gelEl.appendChild(bandEl);
                });

                strandEl.appendChild(idEl);
                strandEl.appendChild(gelEl);
                container.appendChild(strandEl);
            });
        },
        
        getExpressionHTML: function(strand, codonType) {
            let content = '';
            switch(codonType) {
                case 'TXT':
                    content += `<div class="output-text">${strand.data.TXT || "[No text data]"}</div>`;
                    break;
                case 'IMG':
                    content += `<img src="${strand.data.IMG || ""}" class="output-image" alt="[Image data stream]">`;
                    break;
                case 'AUC':
                    const sparkline = '‚ñÇ‚ñÉ‚ñÖ‚ñÜ‚ñá‚ñÜ‚ñÖ‚ñÉ‚ñÇ'.repeat(5);
                    content += `<div class="output-sparkline">[[SPARKLINE]] ${sparkline}</div><div>${strand.data.AUC || "[No audio log]"}</div>`;
                    break;
                case 'SRC':
                    content += `<div class="output-code">${strand.data.SRC || "[No source code]"}</div>`;
                    break;
                case 'LNK':
                    content += `<div>Hyperlink established -> ${strand.data.LNK || "[No link target]"}. Use 'trace' or 'express' to follow.</div>`;
                    break;
                case 'CMD':
                     content += `<div>Command sequence queued: <code>${strand.data.CMD || "[No command]"}</code></div>`;
                    break;
                case 'FRG':
                default:
                    content += `<div>[Fragment data detected - non-expressible]</div>`;
            }
            return `<div style="margin-top: 1em;">${content}</div>`;
        },

        logOutput: function(message, isHTML = false) {
            const line = document.createElement('div');
            if (isHTML) {
                line.innerHTML = message;
            } else {
                line.textContent = message;
            }
            this.console.output.appendChild(line);
            this.console.output.scrollTop = this.console.output.scrollHeight;
        },

        // --- üåä MIRE Field Logic ---
        setupMireParticles: function() {
            const createParticles = (count, z) => Array.from({length: count}, () => ({
                x: Math.random(), y: Math.random(), z,
                vx: (Math.random() - 0.5) * 0.0001,
                vy: (Math.random() - 0.5) * 0.0001,
            }));
            this.mire.particles.far = createParticles(150, 0.2);
            this.mire.particles.mid = createParticles(100, 0.5);
            this.mire.particles.near = createParticles(50, 0.8);
        },
        
        resizeMire: function() {
            for (const key in this.mire.canvases) {
                this.mire.canvases[key].width = window.innerWidth;
                this.mire.canvases[key].height = window.innerHeight;
            }
            this.setupMireParticles();
        },
        
        updateMire: function() {
            const updateLayer = (layer, z) => {
                layer.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x > 1 || p.x < 0) p.vx *= -1;
                    if (p.y > 1 || p.y < 0) p.vy *= -1;
                });
            };
            updateLayer(this.mire.particles.far, 0.2);
            updateLayer(this.mire.particles.mid, 0.5);
            updateLayer(this.mire.particles.near, 0.8);
            
            // Decay hotspots
            this.mire.hotspots.forEach((h, i) => {
                h.intensity -= 0.01;
                if (h.intensity <= 0) this.mire.hotspots.splice(i, 1);
            });
        },

        drawMire: function() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            const drawLayer = (ctx, particles, z, color) => {
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = color;
                
                // Parallax shift based on mouse
                const shiftX = (this.mire.mouse.x - 0.5) * -50 * z;
                const shiftY = (this.mire.mouse.y - 0.5) * -50 * z;
                
                particles.forEach(p => {
                    const size = 1.5 * z;
                    ctx.globalAlpha = 0.5 * z;
                    ctx.fillRect(p.x * w + shiftX, p.y * h + shiftY, size, size);
                });
            };

            drawLayer(this.mire.ctx.far, this.mire.particles.far, 0.2, '#1a4d1a');
            drawLayer(this.mire.ctx.mid, this.mire.particles.mid, 0.5, '#2a7d2a');
            drawLayer(this.mire.ctx.near, this.mire.particles.near, 0.8, '#4cff4c');
            
            // Draw hotspots on near layer for max visibility
            const ctx = this.mire.ctx.near;
            this.mire.hotspots.forEach(h => {
                const [hx, hy, hz] = h.coords;
                const shiftX = (this.mire.mouse.x - 0.5) * -50 * hz;
                const shiftY = (this.mire.mouse.y - 0.5) * -50 * hz;
                const x = hx * w + shiftX;
                const y = hy * h + shiftY;
                const radius = h.intensity * 150 * hz;
                
                const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
                grad.addColorStop(0, `${h.color}FF`);
                grad.addColorStop(0.2, `${h.color}AA`);
                grad.addColorStop(1, `${h.color}00`);

                ctx.globalAlpha = h.intensity;
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            });
        },
        
        // --- Main Animation Loop ---
        animate: function() {
            this.updateMire();
            this.drawMire();
            requestAnimationFrame(this.animate.bind(this));
        }
    };

    document.addEventListener('DOMContentLoaded', () => GENOMIRE_SCOPE.init());
    // Caret focus handling
    document.getElementById('input').addEventListener('focus', () => document.getElementById('caret').style.display = 'inline-block');
    document.getElementById('input').addEventListener('blur', () => document.getElementById('caret').style.display = 'none');
    </script>
</body>
</html>