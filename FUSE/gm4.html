<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß¨üñ•Ô∏èüåä‚ú® GENOMIRE SCOPE v2</title>
    <style>
        :root {
            --phosphor-green: #41f095;
            --dark-background: #08090a;
            --soft-glow: 0 0 5px var(--phosphor-green), 0 0 10px rgba(65, 240, 149, 0.3);
            --faint-glow: 0 0 3px rgba(65, 240, 149, 0.4);
            --subtle-text: rgba(65, 240, 149, 0.6);
            --rule-line: rgba(65, 240, 149, 0.2);
            --error-color: #ff5555;
            --system-color: #8c73ff;
            
            --font-main: 'Iosevka Web', 'IBM Plex Mono', 'Courier New', monospace;

            /* Codon Colors */
            --color-txt: #00aaff; --color-img: #ff4747; --color-auc: #ffdd00;
            --color-lnk: #ff00ff; --color-src: #ffffff; --color-frg: #7c4dff;
            --color-cmd: #ff9100;
        }

        @font-face {
            font-family: 'Iosevka Web';
            font-display: swap;
            font-weight: 400;
            font-stretch: normal;
            font-style: normal;
            src: url('https://cdn.jsdelivr.net/npm/typeface-iosevka@1.1.3/dist/iosevka-regular.woff2') format('woff2');
        }

        * { box-sizing: border-box; }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--dark-background);
            color: var(--phosphor-green);
            font-family: var(--font-main);
            font-size: 16px;
            overflow: hidden;
        }
        
        /* --- üåä 3. MIRE Field (Canvas) --- */
        #mire-field {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            background-color: var(--dark-background);
        }

        /* --- Unified System Layout --- */
        #genomire-scope {
            display: flex; position: relative; z-index: 1;
            width: 100%; height: 100%;
            padding: 1.5rem; gap: 2rem;
        }

        /* --- üß¨ 1. Electrophoresis Panel --- */
        #genome-columns {
            flex: 0 0 auto; display: flex; gap: 12px;
            padding-right: 1rem; height: 100%; overflow-y: auto;
            border-right: 1px solid var(--rule-line);
        }
        
        .genome-strand {
            display: flex; flex-direction: column; align-items: center;
            gap: 2px; cursor: pointer; padding-bottom: 2rem; position: relative;
        }
        .genome-strand:hover .genome-id {
            opacity: 1; text-shadow: var(--soft-glow);
        }
        .genome-strand.flicker {
            animation: flicker-anim 0.7s ease-in-out;
        }
        @keyframes flicker-anim {
            0% { filter: brightness(1); }
            50% { filter: brightness(2) drop-shadow(0 0 3px var(--phosphor-green)); }
            100% { filter: brightness(1); }
        }

        .genome-id {
            position: absolute; bottom: 0; font-size: 0.75em;
            color: var(--subtle-text); opacity: 0.8;
            transition: opacity 0.3s, text-shadow 0.3s;
            writing-mode: vertical-rl; text-orientation: mixed;
            transform: rotate(180deg); white-space: nowrap;
        }

        .codon {
            width: 14px; height: 5px;
            transition: opacity 0.5s ease-in-out, transform 0.3s;
        }
        .codon-exon { opacity: 1; }
        .codon-intron { opacity: 0.25; height: 3px; border: 1px dashed rgba(255,255,255,0.2); }
        
        .genome-strand:hover .codon { transform: scaleX(1.2); }

        .codon-TXT { background-color: var(--color-txt); }
        .codon-IMG { background-color: var(--color-img); }
        .codon-AUC { background-color: var(--color-auc); }
        .codon-LNK { background-color: var(--color-lnk); }
        .codon-SRC { background-color: var(--color-src); }
        .codon-FRG { background-color: var(--color-frg); }
        .codon-CMD { background-color: var(--color-cmd); }

        /* --- üñ•Ô∏è 2. Phenotype Console --- */
        #console { flex: 1 1 auto; display: flex; flex-direction: column; height: 100%; overflow: hidden; }
        #console-output { flex-grow: 1; overflow-y: auto; padding-right: 1rem; word-wrap: break-word; }
        #console-output::-webkit-scrollbar, #genome-columns::-webkit-scrollbar { width: 4px; }
        #console-output::-webkit-scrollbar-thumb, #genome-columns::-webkit-scrollbar-thumb { background: rgba(65, 240, 149, 0.3); }

        #console-input-line { display: flex; flex-shrink: 0; }
        .prompt-glyph { margin-right: 0.5em; text-shadow: var(--soft-glow); }
        #console-input {
            flex-grow: 1; background: none; border: none; outline: none;
            color: var(--phosphor-green); font-family: var(--font-main); font-size: 1em;
            text-shadow: var(--soft-glow);
        }
        
        .log-input { color: var(--subtle-text); }
        .log-response, .log-system, .log-error { margin-bottom: 1em; white-space: pre-wrap; }
        .log-error { color: var(--error-color); }
        .log-system { color: var(--system-color); }
        
        /* Inline Phenotype Styles */
        .phenotype-header { border-bottom: 1px solid var(--rule-line); margin-bottom: 0.5em; color: var(--subtle-text); }
        .phenotype-block { padding-left: 1em; border-left: 1px solid var(--rule-line); margin-bottom: 0.5em; }
        .phenotype-block .type { color: var(--subtle-text); display: inline-block; width: 40px; }
        .phenotype-block .content-txt { display: inline; font-style: italic; }
        .phenotype-block .content-img { letter-spacing: -2px; line-height: 0.9em; display: inline-block; padding: 2px; border: 1px solid var(--subtle-text); background: #111; color: #ccc;}
        .phenotype-block .content-auc { letter-spacing: 0; text-shadow: var(--faint-glow); }
        .phenotype-block .content-src { background: rgba(0,0,0,0.3); padding: 0.2em 0.4em; }
        .data-key { color: var(--subtle-text); display: inline-block; width: 120px; }

        @media (max-width: 768px) {
            #genomire-scope { flex-direction: column; padding: 1rem; gap: 1rem; }
            #genome-columns { flex-direction: row; flex-wrap: wrap; flex: 0 0 auto; width: 100%; height: auto; max-height: 25vh; border-right: none; border-bottom: 1px solid var(--rule-line); padding-bottom: 1rem; padding-right: 0; gap: 8px; }
            .genome-strand { flex-direction: row; width: auto; height: 14px; padding: 0; }
            .genome-id { position: static; writing-mode: horizontal-tb; transform: none; margin-left: 8px; }
            .codon { width: 5px; height: 14px; }
            .codon-intron { width: 3px; border-width: 0 1px; }
        }
    </style>
</head>
<body>
    <canvas id="mire-field"></canvas>
    <div id="genomire-scope">
        <div id="genome-columns"></div>
        <div id="console">
            <div id="console-output"></div>
            <div id="console-input-line">
                <span class="prompt-glyph">></span>
                <input type="text" id="console-input" autofocus autocomplete="off" spellcheck="false">
            </div>
        </div>
    </div>

    <script>
    // --- üß† System Engine ---
    const DOM = {
        genomeColumns: document.getElementById('genome-columns'),
        consoleOutput: document.getElementById('console-output'),
        consoleInput: document.getElementById('console-input'),
        mireCanvas: document.getElementById('mire-field')
    };

    const MASTER_CODONS = ["TXT", "IMG", "AUC", "LNK", "SRC", "FRG", "CMD"];
    let nextGenomeNumericId = 5;

    // üß¨ In-memory Database with new schema
    let genomeData = [
        {
            "id": "g-001", "codons": ["TXT", "FRG", "LNK"], "exons": [0, 2], "introns": [1],
            "traits": {"mutability": 0.05, "accessCount": 10, "origin": "seed"},
            "resonance": {"x": 0.2, "y": 0.3, "z": 0.8},
            "content": {"TXT": "The sky turned to memory.", "LNK": "xref://g-004"}
        },
        {
            "id": "g-002", "codons": ["IMG", "IMG", "AUC", "FRG"], "exons": [0, 2], "introns": [1, 3],
            "traits": {"mutability": 0.1, "accessCount": 23, "origin": "fusion-event"},
            "resonance": {"x": 0.8, "y": 0.5, "z": 0.6},
            "content": {"IMG": "Faded polaroid of a lone tree.", "AUC": "Low hum, distant static."}
        },
        {
            "id": "g-003", "codons": ["SRC", "CMD", "FRG", "SRC"], "exons": [0, 1], "introns": [2, 3],
            "traits": {"mutability": 0.02, "accessCount": 5, "origin": "user-drive"},
            "resonance": {"x": 0.5, "y": 0.8, "z": 0.4},
            "content": {"SRC": "function trace() { ... }", "CMD": "report --all"}
        },
        {
            "id": "g-004", "codons": ["TXT", "TXT", "TXT"], "exons": [0, 1, 2], "introns": [],
            "traits": {"mutability": 0.08, "accessCount": 15, "origin": "echo"},
            "resonance": {"x": 0.3, "y": 0.2, "z": 0.9},
            "content": {"TXT": "A response to the first memory."}
        }
    ];

    // --- üåä MIRE Field Logic ---
    const mire = {
        ctx: DOM.mireCanvas.getContext('2d'),
        points: [],
        width: 0,
        height: 0,
        
        init() {
            this.onResize();
            window.addEventListener('resize', () => this.onResize());
            this.mapGenomesToPoints();
            this.animate();
        },

        onResize() {
            this.width = DOM.mireCanvas.width = window.innerWidth;
            this.height = DOM.mireCanvas.height = window.innerHeight;
            this.mapGenomesToPoints();
        },

        mapGenomesToPoints() {
            this.points = genomeData.map(g => ({
                id: g.id,
                x: g.resonance.x * this.width,
                y: g.resonance.y * this.height,
                z: g.resonance.z, // Semantic density
                brightness: 0.1, // Base brightness
                lastFlare: 0
            }));
        },

        getPoint(id) {
            return this.points.find(p => p.id === id);
        },

        flare(id) {
            const point = this.getPoint(id);
            if (point) {
                point.lastFlare = Date.now();
            }
        },

        animate() {
            this.ctx.clearRect(0, 0, this.width, this.height);
            const now = Date.now();

            this.points.forEach(p => {
                const timeSinceFlare = now - p.lastFlare;
                // Flare lasts ~3 seconds, brightness decays
                const flareIntensity = Math.max(0, 1 - timeSinceFlare / 3000);
                
                const brightness = p.z * 0.4 + flareIntensity; // Base brightness + flare
                if (brightness < 0.01) return;

                const size = 2 + brightness * 8;
                
                this.ctx.fillStyle = `rgba(65, 240, 149, ${brightness * 0.8})`;
                this.ctx.shadowColor = `rgba(65, 240, 149, 1)`;
                this.ctx.shadowBlur = brightness * 15;
                
                this.ctx.beginPath();
                this.ctx.rect(p.x - size / 2, p.y - size / 2, size, size);
                this.ctx.fill();
            });

            this.ctx.shadowBlur = 0; // Reset shadow for performance
            requestAnimationFrame(() => this.animate());
        }
    };

    // --- Core System Logic ---
    const system = {
        init() {
            DOM.consoleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.handleCommand();
                }
            });
            this.renderGenomeColumns();
            mire.init();
            this.log('üß¨üñ•Ô∏èüåä‚ú® GENOMIRE SCOPE v2 Initialized.', 'system');
            this.log("Type 'help' for commands.", 'system');
            DOM.consoleInput.focus();
        },

        log(html, type = 'response') {
            const entry = document.createElement('div');
            entry.className = `log-${type}`;
            entry.innerHTML = html;
            DOM.consoleOutput.appendChild(entry);
            DOM.consoleOutput.scrollTop = DOM.consoleOutput.scrollHeight;
        },

        renderGenomeColumns() {
            DOM.genomeColumns.innerHTML = '';
            // Simple sort by id for stability
            genomeData.sort((a,b) => a.id.localeCompare(b.id)); 

            genomeData.forEach(genome => {
                const strand = document.createElement('div');
                strand.className = 'genome-strand';
                strand.dataset.id = genome.id;
                
                genome.codons.forEach((codonType, i) => {
                    const codon = document.createElement('div');
                    const isExon = genome.exons.includes(i);
                    codon.className = `codon codon-${codonType} ${isExon ? 'codon-exon' : 'codon-intron'}`;
                    strand.appendChild(codon);
                });
                
                const idTag = document.createElement('div');
                idTag.className = 'genome-id';
                idTag.textContent = genome.id;
                strand.appendChild(idTag);
                
                strand.addEventListener('click', () => {
                    DOM.consoleInput.value = `express ${genome.id}`;
                    this.handleCommand();
                });

                DOM.genomeColumns.appendChild(strand);
            });
        },
        
        flickerStrand(id) {
            const strandEl = document.querySelector(`.genome-strand[data-id="${id}"]`);
            if (strandEl) {
                strandEl.classList.add('flicker');
                setTimeout(() => strandEl.classList.remove('flicker'), 700);
            }
        },

        handleCommand() {
            const commandText = DOM.consoleInput.value.trim();
            if (commandText === '') return;
            this.log(`> ${commandText}`, 'input');
            DOM.consoleInput.value = '';

            const [command, ...args] = commandText.split(' ');
            try {
                this.commands[command](args);
            } catch (e) {
                if (e instanceof TypeError) {
                     this.log(`‚ñû ERROR: Command not found: ${command}`, 'error');
                } else {
                     this.log(`‚ñû ERROR: ${e.message}`, 'error');
                }
            }
        },

        findGenome(id) {
            const genome = genomeData.find(g => g.id === id);
            if (!genome) throw new Error(`Genome ID '${id}' not found in sequence.`);
            return genome;
        },

        accessGenome(id) {
            const genome = this.findGenome(id);
            genome.traits.accessCount++;
            this.flickerStrand(id);
            mire.flare(id);
            return genome;
        },

        commands: {
            express(args) {
                const genome = system.accessGenome(args[0]);
                let output = `<div class="phenotype-header">[ PHENOTYPE: ${genome.id} ]</div>`;
                
                if(genome.exons.length === 0) {
                     output += `... No expressed exons. Genome is silent.`;
                } else {
                    genome.exons.forEach(exonIndex => {
                        const type = genome.codons[exonIndex];
                        const content = genome.content[type];
                        if (content) {
                            output += system.renderPhenotype(type, content);
                        }
                    });
                }
                system.log(output);
            },

            trace(args) {
                const genome = system.accessGenome(args[0]);
                let output = `[ TRACE DATA: ${genome.id} ]\n`;
                output += `<span class="data-key">Codons</span>: ${genome.codons.join(' ')}\n`;
                output += `<span class="data-key">Exons</span>: [${genome.exons.join(', ')}] (Expressed)\n`;
                output += `<span class="data-key">Introns</span>: [${genome.introns.join(', ')}] (Latent)\n`;
                output += `--- TRAITS ---\n`;
                output += `<span class="data-key">Mutability</span>: ${genome.traits.mutability}\n`;
                output += `<span class="data-key">Access Count</span>: ${genome.traits.accessCount}\n`;
                output += `<span class="data-key">Origin</span>: ${genome.traits.origin}\n`;
                output += `--- RESONANCE ---\n`;
                output += `<span class="data-key">Coordinates</span>: [x:${genome.resonance.x.toFixed(2)}, y:${genome.resonance.y.toFixed(2)}, z:${genome.resonance.z.toFixed(2)}]`;
                system.log(output);
            },

            fuse(args) {
                const [id1, id2] = args[0].split('+');
                if (!id1 || !id2) throw new Error("Fuse requires two IDs separated by '+'. e.g., fuse g-001+g-002");
                const g1 = system.findGenome(id1);
                const g2 = system.findGenome(id2);
                
                const newId = `g-${String(nextGenomeNumericId++).padStart(3, '0')}`;
                const newCodons = [...g1.codons, ...g2.codons].slice(0, 10);
                const newExons = [...g1.exons, ...g2.exons.map(e => e + g1.codons.length)].filter(e => e < newCodons.length);
                const newIntrons = Array.from({length: newCodons.length}, (_, i) => i).filter(i => !newExons.includes(i));
                
                const newGenome = {
                    id: newId,
                    codons: newCodons,
                    exons: newExons,
                    introns: newIntrons,
                    traits: {
                        mutability: ((g1.traits.mutability + g2.traits.mutability) / 2).toFixed(2),
                        accessCount: 1,
                        origin: `fusion(${g1.id}+${g2.id})`
                    },
                    resonance: {
                        x: (g1.resonance.x + g2.resonance.x) / 2,
                        y: (g1.resonance.y + g2.resonance.y) / 2,
                        z: (g1.resonance.z + g2.resonance.z) / 2,
                    },
                    content: { ...g1.content, ...g2.content }
                };
                
                genomeData.push(newGenome);
                system.log(`[ FUSION COMPLETE ]\n  Created ${newId} from ${id1} and ${id2}`, 'system');
                system.renderGenomeColumns();
                mire.mapGenomesToPoints(); // Remap points to include the new one
                system.accessGenome(newId);
            },

            mutate(args) {
                const genome = system.accessGenome(args[0]);
                const mutationRate = genome.traits.mutability;

                let log = `[ MUTATION EVENT: ${genome.id} | rate ${mutationRate} ]\n`;
                
                // 80% chance to mutate a codon, 20% to swap exon/intron
                if (Math.random() < 0.8 || genome.introns.length === 0) {
                    // Mutate a codon
                    const i = Math.floor(Math.random() * genome.codons.length);
                    const oldCodon = genome.codons[i];
                    let newCodon = oldCodon;
                    while (newCodon === oldCodon) {
                         newCodon = MASTER_CODONS[Math.floor(Math.random() * MASTER_CODONS.length)];
                    }
                    genome.codons[i] = newCodon;
                    log += `  Codon at index ${i} changed from ${oldCodon} -> ${newCodon}`;

                } else {
                    // Swap an exon and an intron
                    const exonToSwap = genome.exons[Math.floor(Math.random() * genome.exons.length)];
                    const intronToSwap = genome.introns[Math.floor(Math.random() * genome.introns.length)];
                    
                    genome.exons = genome.exons.filter(e => e !== exonToSwap).concat(intronToSwap);
                    genome.introns = genome.introns.filter(i => i !== intronToSwap).concat(exonToSwap);
                    log += `  Expression shift: Exon ${exonToSwap} <-> Intron ${intronToSwap}`;
                }
                
                system.log(log, 'system');
                system.renderGenomeColumns();
            },

            echo(args) {
                const text = args.join(' ');
                if (!text) throw new Error("Echo requires a text fragment.");
                
                const newId = `g-${String(nextGenomeNumericId++).padStart(3, '0')}`;
                const newGenome = {
                    id: newId,
                    codons: ["TXT", "FRG"],
                    exons: [0],
                    introns: [1],
                    traits: { mutability: 0.1, accessCount: 1, origin: "echo" },
                    resonance: { x: Math.random(), y: Math.random(), z: Math.random() },
                    content: { "TXT": text }
                };
                genomeData.push(newGenome);
                system.log(`[ ECHO RECEIVED ]\n  Created new genome ${newId}`, 'system');
                system.renderGenomeColumns();
                mire.mapGenomesToPoints();
                system.accessGenome(newId);
            },
            
            clear() { DOM.consoleOutput.innerHTML = ''; },

            help() {
                const helpText = `[ GENOMIRE SCOPE :: HELP ]
<span class="data-key">express <id></span> Renders the expressed media of a genome.
<span class="data-key">trace <id></span> Shows the complete metadata for a genome.
<span class="data-key">fuse <id1+id2></span> Combines two genomes into a new one.
<span class="data-key">mutate <id></span> Induces a random mutation in a genome.
<span class="data-key">echo <text></span> Creates a new text-based genome fragment.
<span class="data-key">clear</span> Clears the console output.`;
                system.log(helpText);
            }
        },
        
        renderPhenotype(type, content) {
            const sparkline = () => '‚ñÑ‚ñÉ‚ñÑ‚ñÜ ‚ñÖ‚ñá   '.split('').sort(()=>Math.random()-0.5).join('');
            const imgGlyph = () => `‚ñ•‚ñ§‚ñß‚ñ®‚ñ©\n‚ñ®‚ñ©‚ñ•‚ñ§‚ñß\n‚ñ§‚ñß‚ñ®‚ñ©‚ñ•`;
            let contentHTML = '';
            switch(type) {
                case 'TXT': contentHTML = `<span class="content-txt">‚Äú${content}‚Äù</span>`; break;
                case 'IMG': contentHTML = `<pre class="content-img">${imgGlyph()}</pre>`; break;
                case 'AUC': contentHTML = `<span class="content-auc">${sparkline()}</span>`; break;
                case 'SRC': contentHTML = `<code class="content-src">${content}</code>`; break;
                case 'LNK': contentHTML = `<a href="#" onclick="document.getElementById('console-input').value='express ${content.replace('xref://', '')}'; system.handleCommand(); return false;">${content}</a>`; break;
                default: contentHTML = `<span>${content}</span>`;
            }
            return `<div class="phenotype-block"><span class="type">${type}</span>${contentHTML}</div>`;
        }
    };

    // --- Initialization ---
    system.init();

    </script>
</body>
</html>