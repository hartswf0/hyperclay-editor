<!DOCTYPE html>
<!-- HYPERCLAY MODULE - Standalone -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>HYPERCLAY MODULE</title>
<style>
/* === CSS VARIABLES - INJECTABLE BY ORCHESTRATOR === */
:root {
  /* Core Colors - Can be overridden by parent */
  --bg-0: #050505;
  --bg-1: #0a0e14;
  --cy-primary: #00ffff;
  --cy-secondary: #0088ff;
  --ink: #e6fff9;
  --glow: 0 0 20px rgba(0, 255, 255, 0.2);
  --panel: rgba(10, 14, 20, 0.85);
  
  /* Layout */
  --rack-metal: #1a1a20;
  --rack-highlight: #2a2a30;
  --grid-size: 20px;
  
  /* Module Identity */
  --module-color: #00ffff;
  --module-accent: #ff00ff;
  
  /* Performance */
  --render-quality: 1;
}

/* === MOBILE OPTIMIZATION === */
@media (max-width: 768px) {
  :root {
    --grid-size: 15px;
  }
  
  .tool-rack {
    left: 8px !important;
    transform: translateY(-50%) scale(0.9) !important;
  }
  
  .module-header {
    font-size: 10px !important;
    padding: 4px 8px !important;
  }
  
  .parameter-dial {
    width: 36px !important;
    height: 36px !important;
  }
}

@media (max-width: 480px) {
  :root {
    --grid-size: 12px;
  }
  
  .tool-rack {
    flex-direction: row !important;
    top: auto !important;
    bottom: 70px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: auto !important;
  }
  
  .orchestrator-controls {
    bottom: 120px !important;
  }
}

/* === MODULE STYLES === */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none;
  user-select: none;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--bg-0);
  font-family: 'Courier New', 'Monaco', 'SF Mono', monospace;
  color: var(--ink);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#module-canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
  touch-action: none;
  image-rendering: crisp-edges;
}

/* === UI COMPONENTS === */
.module-header {
  position: fixed;
  top: 12px;
  left: 12px;
  background: var(--panel);
  border: 1px solid rgba(0, 255, 255, 0.3);
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.1em;
  color: var(--cy-primary);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  pointer-events: none;
  z-index: 100;
  box-shadow: var(--glow);
}

.module-header::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--cy-primary), transparent);
}

.tool-rack {
  position: fixed;
  top: 50%;
  left: 12px;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 100;
  background: rgba(5, 5, 5, 0.8);
  padding: 12px;
  border-radius: 8px;
  border: 1px solid rgba(0, 255, 255, 0.2);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.tool-btn {
  width: 40px;
  height: 40px;
  background: linear-gradient(145deg, rgba(10, 14, 20, 0.9), rgba(5, 5, 5, 0.9));
  border: 1px solid rgba(0, 255, 255, 0.3);
  color: rgba(0, 255, 255, 0.7);
  display: grid;
  place-items: center;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.1em;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  border-radius: 6px;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.tool-btn:hover {
  border-color: var(--cy-primary);
  color: var(--cy-primary);
  box-shadow: var(--glow), inset 0 1px 0 rgba(255, 255, 255, 0.2);
  transform: translateY(-1px);
}

.tool-btn.active {
  background: linear-gradient(145deg, var(--cy-primary), rgba(0, 200, 255, 0.8));
  color: #000;
  border-color: var(--cy-primary);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

.tool-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.tool-group + .tool-group {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0, 255, 255, 0.1);
}

.parameter-dial {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 44px;
  height: 44px;
  background: radial-gradient(circle at 30% 30%, rgba(0, 255, 255, 0.1), rgba(0, 0, 0, 0.8));
  border: 2px solid var(--cy-primary);
  border-radius: 50%;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 100;
  box-shadow: var(--glow);
}

.dial-value {
  font-size: 9px;
  color: var(--cy-primary);
  margin-top: 2px;
  font-weight: 700;
}

.dial-value::after {
  content: '%';
  font-size: 7px;
  opacity: 0.7;
}

.orchestrator-controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  z-index: 100;
  background: rgba(5, 5, 5, 0.8);
  padding: 10px;
  border-radius: 8px;
  border: 1px solid rgba(0, 255, 255, 0.2);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.orch-btn {
  padding: 8px 14px;
  background: linear-gradient(145deg, rgba(0, 255, 255, 0.1), rgba(0, 100, 200, 0.1));
  border: 1px solid rgba(0, 255, 255, 0.3);
  color: var(--cy-primary);
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.1em;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
}

.orch-btn:hover {
  background: linear-gradient(145deg, rgba(0, 255, 255, 0.2), rgba(0, 100, 200, 0.2));
  box-shadow: var(--glow);
  transform: translateY(-1px);
}

/* === EXPERIMENTATION OVERLAY === */
.experiment-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.experiment-panel {
  background: var(--bg-1);
  border: 2px solid var(--cy-primary);
  padding: 24px;
  max-width: 400px;
  width: 90%;
  border-radius: 12px;
  box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
}

.experiment-panel h3 {
  color: var(--cy-primary);
  margin-bottom: 20px;
  font-size: 14px;
  letter-spacing: 0.2em;
  text-align: center;
}

.experiment-control {
  margin-bottom: 16px;
}

.experiment-control label {
  display: flex;
  align-items: center;
  gap: 10px;
  color: var(--ink);
  font-size: 12px;
  cursor: pointer;
}

.experiment-slider {
  width: 100%;
  margin: 10px 0;
  -webkit-appearance: none;
  appearance: none;
  height: 4px;
  background: rgba(0, 255, 255, 0.2);
  border-radius: 2px;
  outline: none;
}

.experiment-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: var(--cy-primary);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

/* === PERFORMANCE MONITOR === */
.perf-monitor {
  position: fixed;
  bottom: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: #0f8;
  font-size: 9px;
  font-family: 'Monaco', 'SF Mono', monospace;
  padding: 6px 8px;
  border-radius: 4px;
  pointer-events: none;
  z-index: 50;
  border: 1px solid rgba(0, 255, 255, 0.1);
}

/* === SCANLINE EFFECT === */
.scanline {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 10;
  background: linear-gradient(
    to bottom,
    transparent 50%,
    rgba(0, 0, 0, 0.25) 50%
  );
  background-size: 100% 4px;
  opacity: 0.3;
}

/* === LOADING INDICATOR === */
.loading-indicator {
  position: fixed;
  inset: 0;
  background: var(--bg-0);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  transition: opacity 0.3s;
}

.loading-text {
  color: var(--cy-primary);
  font-size: 12px;
  letter-spacing: 0.2em;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}
</style>
</head>
<body>
<canvas id="module-canvas"></canvas>
<div class="scanline"></div>

<div class="loading-indicator" id="loading">
  <div class="loading-text">LOADING MODULE...</div>
</div>

<div class="module-header">
  <span id="module-id-display">MODULE_000</span> | <span id="mode-display">SCULPT</span>
</div>

<div class="tool-rack">
  <div class="tool-group" id="grp-sculpt">
    <div class="tool-btn active" data-tool="strength" title="Force">F</div>
    <div class="tool-btn" data-tool="radius" title="Radius">R</div>
    <div class="tool-btn" data-tool="density" title="Density">D</div>
  </div>
  <div class="tool-group" id="grp-seq" style="display:none">
    <div class="tool-btn" data-tool="tempo" title="Tempo">T</div>
    <div class="tool-btn" data-tool="filter" title="Filter">F</div>
    <div class="tool-btn" data-tool="release" title="Release">R</div>
  </div>
</div>

<div class="parameter-dial" id="parameter-dial">
  <div class="dial-value" id="dial-value">0</div>
</div>

<div class="perf-monitor" id="perf-monitor">FPS: 60 | CPU: --</div>

<div class="orchestrator-controls">
  <button class="orch-btn" data-action="export">EXPORT</button>
  <button class="orch-btn" data-action="randomize">RANDOM</button>
  <button class="orch-btn" data-action="experiment">EXP</button>
</div>

<div class="experiment-overlay" id="experiment-overlay">
  <div class="experiment-panel">
    <h3>EXPERIMENT MODE</h3>
    <div class="experiment-control">
      <label>
        <input type="checkbox" id="exp-param-sweep">
        PARAMETER SWEEP
      </label>
    </div>
    <div class="experiment-control">
      <label>
        <input type="checkbox" id="exp-osc-sync">
        OSCILLATOR SYNC
      </label>
    </div>
    <div class="experiment-control">
      <label>INTENSITY</label>
      <input type="range" class="experiment-slider" id="exp-intensity" min="0" max="100" value="50">
    </div>
    <div style="display: flex; gap: 10px; margin-top: 20px;">
      <button class="orch-btn" onclick="closeExperiment()" style="flex: 1;">CLOSE</button>
      <button class="orch-btn" onclick="runExperiment()" style="flex: 1;">RUN</button>
    </div>
  </div>
</div>

<script>
// === MODULE CONFIGURATION ===
const MODULE_CONFIG = (() => {
  const urlParams = new URLSearchParams(window.location.search);
  return {
    // Module Identity
    id: urlParams.get('id') || `mod_${Math.random().toString(36).substr(2, 6)}`,
    type: urlParams.get('type') || 'sonifier',
    variant: urlParams.get('variant') || 'default',
    
    // Performance
    targetFPS: 60,
    renderScale: Math.min(window.devicePixelRatio || 1, 2),
    mobileOptimized: /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent),
    
    // Features
    features: {
      sculpt: true,
      sequence: true,
      audio: true,
      midi: false,
      osc: false
    },
    
    // Communication
    parentOrigin: '*',
    heartbeatInterval: 5000
  };
})();

// === UTILITY FUNCTIONS ===
const Utils = {
  clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
  lerp: (a, b, t) => a + (b - a) * t,
  map: (value, inMin, inMax, outMin, outMax) => 
    ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin,
  
  randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
  randomFloat: (min, max) => Math.random() * (max - min) + min,
  
  debounce: (fn, delay) => {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn(...args), delay);
    };
  },
  
  throttle: (fn, limit) => {
    let inThrottle;
    return (...args) => {
      if (!inThrottle) {
        fn(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  },
  
  haptic: (duration = 15) => {
    if (navigator.vibrate) navigator.vibrate(duration);
  }
};

// === PERFORMANCE MONITOR ===
class PerformanceMonitor {
  constructor() {
    this.fps = 60;
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.samples = [];
    this.maxSamples = 60;
  }
  
  update() {
    this.frameCount++;
    const now = performance.now();
    
    if (now - this.lastTime >= 1000) {
      this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
      this.frameCount = 0;
      this.lastTime = now;
      
      // Add to samples for averaging
      this.samples.push(this.fps);
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      
      // Update display
      const avgFps = Math.round(this.samples.reduce((a, b) => a + b) / this.samples.length);
      document.getElementById('perf-monitor').textContent = 
        `FPS: ${avgFps} | ID: ${window.module?.id?.substr(0, 4) || '----'}`;
    }
  }
  
  getAverageFPS() {
    if (this.samples.length === 0) return 60;
    return Math.round(this.samples.reduce((a, b) => a + b) / this.samples.length);
  }
}

// === STATE MANAGEMENT ===
class ModuleState {
  constructor() {
    this.params = {
      // Sculpt Parameters
      strength: { value: 8, min: 1, max: 20, step: 1 },
      radius: { value: 60, min: 20, max: 150, step: 5 },
      density: { value: 20, min: 8, max: 40, step: 4 },
      
      // Sequence Parameters
      tempo: { value: 95, min: 60, max: 180, step: 5 },
      filter: { value: 2000, min: 200, max: 8000, step: 200 },
      release: { value: 400, min: 100, max: 1000, step: 50 },
      
      // Experimental Parameters
      variance: { value: 10, min: 0, max: 100, step: 1 },
      mutation: { value: 5, min: 0, max: 100, step: 1 },
      drift: { value: 2, min: 0, max: 10, step: 0.1 }
    };
    
    this.mode = 'sculpt'; // 'sculpt' or 'sequence'
    this.transport = false;
    this.activeTool = 'strength';
    
    // Experimentation
    this.experiments = new Set();
    this.experimentState = {};
    
    // Variance absorption
    this.paramHistory = new Map();
    this.varianceThreshold = 0.1;
  }
  
  updateParam(name, value, broadcast = true) {
    if (!this.params[name]) return false;
    
    const param = this.params[name];
    const clamped = Utils.clamp(value, param.min, param.max);
    
    // Record history for variance calculation
    if (!this.paramHistory.has(name)) {
      this.paramHistory.set(name, []);
    }
    
    const history = this.paramHistory.get(name);
    history.push(clamped);
    if (history.length > 10) history.shift();
    
    // Calculate variance
    const variance = this.calculateVariance(history);
    
    // If variance is too high, absorb it (dampen changes)
    if (variance > this.varianceThreshold) {
      const avg = history.reduce((a, b) => a + b) / history.length;
      param.value = Utils.lerp(param.value, avg, 0.3);
    } else {
      param.value = clamped;
    }
    
    // Broadcast to orchestrator
    if (broadcast && window.module?.parentConnection) {
      window.module.parentConnection.postMessage({
        type: 'PARAM_CHANGE',
        moduleId: window.module.id,
        param: name,
        value: param.value,
        variance: variance
      }, MODULE_CONFIG.parentOrigin);
    }
    
    return true;
  }
  
  calculateVariance(values) {
    if (values.length < 2) return 0;
    const mean = values.reduce((a, b) => a + b) / values.length;
    const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
    return Math.sqrt(squaredDiffs.reduce((a, b) => a + b) / values.length);
  }
  
  getParamValue(name) {
    return this.params[name]?.value || 0;
  }
  
  exportState() {
    const state = {
      params: {},
      mode: this.mode,
      transport: this.transport,
      experiments: Array.from(this.experiments),
      timestamp: Date.now(),
      version: '1.0.0'
    };
    
    Object.entries(this.params).forEach(([key, param]) => {
      state.params[key] = param.value;
    });
    
    return state;
  }
  
  importState(state) {
    if (state.params) {
      Object.entries(state.params).forEach(([key, value]) => {
        this.updateParam(key, value, false);
      });
    }
    
    if (state.mode) this.mode = state.mode;
    if (state.experiments) {
      this.experiments = new Set(state.experiments);
    }
  }
  
  applyVariance() {
    const varianceAmount = this.getParamValue('variance') / 100;
    const mutationRate = this.getParamValue('mutation') / 100;
    
    Object.keys(this.params).forEach(paramName => {
      if (Math.random() < mutationRate) {
        const param = this.params[paramName];
        const range = param.max - param.min;
        const drift = (Math.random() * 2 - 1) * varianceAmount * range;
        this.updateParam(paramName, param.value + drift);
      }
    });
  }
}

// === RACK UNIT SYSTEM ===
class RackUnit {
  constructor(id, x, y, w, h) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    
    this.cols = 20;
    this.rows = Math.floor(this.cols * (this.h / this.w));
    
    // Mesh
    this.original = [];
    this.current = [];
    this.velocity = [];
    
    // Sequence
    this.sequencer = {
      locked: false,
      cells: [],
      step: 0,
      steps: 16
    };
    
    // Audio
    this.audio = {
      rootFreq: [110, 220, 330][id % 3],
      scale: [0, 2, 4, 7, 9, 12, 14, 16],
      lastTrigger: 0
    };
    
    this.initMesh();
  }
  
  initMesh() {
    this.original = [];
    this.current = [];
    this.velocity = [];
    
    for (let r = 0; r <= this.rows; r++) {
      for (let c = 0; c <= this.cols; c++) {
        const px = this.x + (c / this.cols) * this.w;
        const py = this.y + (r / this.rows) * this.h;
        
        this.original.push({ x: px, y: py });
        this.current.push({ x: px, y: py });
        this.velocity.push({ x: 0, y: 0 });
      }
    }
  }
  
  update(deltaTime) {
    // Physics simulation
    const stiffness = 0.1;
    const damping = 0.95;
    
    for (let i = 0; i < this.current.length; i++) {
      const dx = this.original[i].x - this.current[i].x;
      const dy = this.original[i].y - this.current[i].y;
      
      this.velocity[i].x += dx * stiffness;
      this.velocity[i].y += dy * stiffness;
      
      this.velocity[i].x *= damping;
      this.velocity[i].y *= damping;
      
      this.current[i].x += this.velocity[i].x * deltaTime;
      this.current[i].y += this.velocity[i].y * deltaTime;
    }
  }
  
  sculpt(x, y, strength, radius, pull = false) {
    const r2 = radius * radius;
    let deformed = false;
    
    for (let i = 0; i < this.current.length; i++) {
      const p = this.current[i];
      const dx = p.x - x;
      const dy = p.y - y;
      const d2 = dx * dx + dy * dy;
      
      if (d2 < r2) {
        const dist = Math.sqrt(d2);
        const force = (1 - dist / radius) * strength * (pull ? -1 : 1);
        const angle = Math.atan2(dy, dx);
        
        this.current[i].x += Math.cos(angle) * force;
        this.current[i].y += Math.sin(angle) * force;
        deformed = true;
      }
    }
    
    return deformed;
  }
  
  lockSequencer() {
    this.sequencer.locked = true;
    this.sequencer.cells = [];
    
    for (let r = 0; r < this.rows; r++) {
      for (let c = 0; c < this.cols; c++) {
        const i = r * (this.cols + 1) + c;
        const p1 = this.current[i];
        const p2 = this.current[i + 1];
        const p3 = this.current[i + this.cols + 2];
        const p4 = this.current[i + this.cols + 1];
        
        this.sequencer.cells.push({
          corners: [p1, p2, p3, p4],
          active: Math.random() > 0.7,
          velocity: { x: 0, y: 0 }
        });
      }
    }
  }
  
  unlockSequencer() {
    this.sequencer.locked = false;
    this.sequencer.cells = [];
  }
  
  draw(ctx, state) {
    // Draw rack chassis
    ctx.fillStyle = 'rgba(26, 26, 32, 0.8)';
    ctx.fillRect(this.x - 10, this.y - 10, this.w + 20, this.h + 20);
    
    // Draw mesh
    if (!this.sequencer.locked) {
      this.drawMesh(ctx);
    } else {
      this.drawSequencer(ctx, state);
    }
    
    // Draw rack label
    ctx.save();
    ctx.translate(this.x - 15, this.y + this.h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.font = 'bold 10px "Courier New"';
    ctx.fillStyle = `rgba(0, 255, 255, ${state.transport ? 0.8 : 0.3})`;
    ctx.textAlign = 'center';
    ctx.fillText(`RACK_${this.id}`, 0, 0);
    ctx.restore();
  }
  
  drawMesh(ctx) {
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    
    // Horizontal lines
    for (let r = 0; r <= this.rows; r++) {
      ctx.beginPath();
      for (let c = 0; c <= this.cols; c++) {
        const p = this.current[r * (this.cols + 1) + c];
        if (c === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }
    
    // Vertical lines
    for (let c = 0; c <= this.cols; c++) {
      ctx.beginPath();
      for (let r = 0; r <= this.rows; r++) {
        const p = this.current[r * (this.cols + 1) + c];
        if (r === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }
  }
  
  drawSequencer(ctx, state) {
    this.sequencer.cells.forEach((cell, i) => {
      const [p1, p2, p3, p4] = cell.corners;
      
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.lineTo(p4.x, p4.y);
      ctx.closePath();
      
      if (cell.active) {
        const step = Math.floor(i / (this.sequencer.cells.length / this.sequencer.steps));
        const isCurrent = step === state.sequenceStep && state.transport;
        
        if (isCurrent) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.fill();
        } else {
          ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
          ctx.fill();
        }
      }
      
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.stroke();
    });
  }
  
  hitTest(x, y) {
    return x >= this.x && x <= this.x + this.w && 
           y >= this.y && y <= this.y + this.h;
  }
  
  getCellAt(x, y) {
    if (!this.sequencer.locked) return -1;
    
    for (let i = 0; i < this.sequencer.cells.length; i++) {
      const [p1, p2, p3, p4] = this.sequencer.cells[i].corners;
      
      // Simple point-in-quad test
      const a = (p2.x - p1.x) * (y - p1.y) - (p2.y - p1.y) * (x - p1.x);
      const b = (p3.x - p2.x) * (y - p2.y) - (p3.y - p2.y) * (x - p2.x);
      const c = (p4.x - p3.x) * (y - p3.y) - (p4.y - p3.y) * (x - p3.x);
      const d = (p1.x - p4.x) * (y - p4.y) - (p1.y - p4.y) * (x - p4.x);
      
      if ((a >= 0 && b >= 0 && c >= 0 && d >= 0) || 
          (a <= 0 && b <= 0 && c <= 0 && d <= 0)) {
        return i;
      }
    }
    
    return -1;
  }
}

// === AUDIO ENGINE ===
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.initialized = false;
    this.oscillators = new Map();
    this.nextOscId = 0;
    
    // Audio parameters
    this.reverb = 0.3;
    this.delay = 0.2;
    this.filterBase = 2000;
  }
  
  init() {
    if (this.initialized) return;
    
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AudioContext();
      
      // Master gain
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.3;
      this.master.connect(this.ctx.destination);
      
      // Effects chain
      this.setupEffects();
      
      this.initialized = true;
      console.log('Audio engine initialized');
    } catch (error) {
      console.error('Failed to initialize audio:', error);
    }
  }
  
  setupEffects() {
    // Delay
    this.delayNode = this.ctx.createDelay();
    this.delayNode.delayTime.value = this.delay;
    
    this.delayGain = this.ctx.createGain();
    this.delayGain.gain.value = 0.4;
    
    this.delayNode.connect(this.delayGain);
    this.delayGain.connect(this.delayNode);
    this.delayNode.connect(this.master);
    
    // Filter
    this.filter = this.ctx.createBiquadFilter();
    this.filter.type = 'lowpass';
    this.filter.frequency.value = this.filterBase;
    this.filter.connect(this.master);
  }
  
  playNote(rackId, intensity = 0.5, duration = 0.5) {
    if (!this.initialized || this.ctx.state === 'suspended') {
      this.ctx.resume();
    }
    
    const now = this.ctx.currentTime;
    const oscId = this.nextOscId++;
    
    // Oscillator
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    // Different oscillator types per rack
    if (rackId === 0) osc.type = 'sine';
    else if (rackId === 1) osc.type = 'triangle';
    else osc.type = 'sawtooth';
    
    // Calculate frequency based on rack and intensity
    const baseFreq = [110, 220, 330][rackId % 3];
    const scale = [0, 2, 4, 7, 9];
    const note = scale[Math.floor(intensity * (scale.length - 1))];
    const freq = baseFreq * Math.pow(2, note / 12);
    
    osc.frequency.value = freq;
    
    // Envelope
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(intensity * 0.5, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
    
    // Connect
    osc.connect(gain);
    gain.connect(this.filter);
    
    // Store for cleanup
    this.oscillators.set(oscId, { osc, gain, startTime: now });
    
    // Start and schedule stop
    osc.start(now);
    osc.stop(now + duration + 0.1);
    
    // Cleanup
    setTimeout(() => {
      this.oscillators.delete(oscId);
    }, (duration + 0.1) * 1000);
    
    return oscId;
  }
  
  setParam(param, value) {
    switch (param) {
      case 'filter':
        if (this.filter) {
          this.filter.frequency.value = value;
        }
        break;
      case 'release':
        // Adjust envelope times
        break;
    }
  }
}

// === HYPERCLAY MODULE ===
class HyperclayModule {
  constructor(config = {}) {
    // Configuration
    this.config = { ...MODULE_CONFIG, ...config };
    this.id = this.config.id;
    
    // State
    this.state = new ModuleState();
    this.performance = new PerformanceMonitor();
    
    // Canvas
    this.canvas = document.getElementById('module-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.width = 0;
    this.height = 0;
    this.dpr = this.config.renderScale;
    
    // Racks
    this.racks = [];
    this.rackCount = 3;
    
    // Interaction
    this.dragging = false;
    this.pulling = false;
    this.mouse = { x: 0, y: 0 };
    this.touch = { x: 0, y: 0 };
    
    // Sequence
    this.sequenceStep = 0;
    this.lastStepTime = 0;
    
    // Audio
    this.audio = new AudioEngine();
    
    // Communication
    this.parentConnection = window.parent;
    this.heartbeat = null;
    
    // Experimentation
    this.experimentInterval = null;
    
    // Initialize
    this.init();
  }
  
  init() {
    // Setup canvas
    this.resize();
    
    // Setup audio
    this.audio.init();
    
    // Setup racks
    this.createRacks();
    
    // Setup UI
    this.setupUI();
    
    // Setup communication
    this.setupCommunication();
    
    // Setup event listeners
    this.setupEventListeners();
    
    // Start rendering
    this.start();
    
    // Hide loading screen
    setTimeout(() => {
      document.getElementById('loading').style.opacity = '0';
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
      }, 300);
    }, 500);
    
    // Send ready message
    this.sendMessage('MODULE_READY', {
      id: this.id,
      type: this.config.type,
      capabilities: this.config.features
    });
  }
  
  resize() {
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    
    this.canvas.width = this.width * this.dpr;
    this.canvas.height = this.height * this.dpr;
    this.canvas.style.width = `${this.width}px`;
    this.canvas.style.height = `${this.height}px`;
    
    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
    
    // Recreate racks with new dimensions
    this.createRacks();
  }
  
  createRacks() {
    this.racks = [];
    
    const margin = 60;
    const rackHeight = (this.height - margin * 4) / this.rackCount;
    
    for (let i = 0; i < this.rackCount; i++) {
      const y = margin + i * (rackHeight + margin);
      const rack = new RackUnit(
        i,
        margin,
        y,
        this.width - margin * 2,
        rackHeight
      );
      this.racks.push(rack);
    }
  }
  
  setupUI() {
    // Update module display
    document.getElementById('module-id-display').textContent = 
      this.id.substr(0, 8).toUpperCase();
    
    // Tool buttons
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const tool = e.target.dataset.tool;
        this.setActiveTool(tool);
      });
    });
    
    // Orchestrator buttons
    document.querySelectorAll('.orch-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.dataset.action;
        this.handleOrchestratorAction(action);
      });
    });
    
    // Update mode display
    this.updateModeDisplay();
  }
  
  setupEventListeners() {
    // Window resize
    window.addEventListener('resize', Utils.debounce(() => this.resize(), 250));
    
    // Mouse/Touch events
    this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this));
    this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
    this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
    this.canvas.addEventListener('pointerleave', this.handlePointerUp.bind(this));
    
    // Prevent context menu on touch devices
    this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    
    // Touch gestures
    let touchStartDistance = 0;
    this.canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        touchStartDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      }
    }, { passive: true });
    
    this.canvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        const currentDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const delta = (currentDistance - touchStartDistance) / 100;
        
        // Adjust parameter with pinch gesture
        if (Math.abs(delta) > 0.1) {
          const param = this.state.activeTool;
          if (param) {
            const current = this.state.getParamValue(param);
            this.state.updateParam(param, current + delta * 10);
            this.updateDialDisplay(param, current + delta * 10);
          }
          touchStartDistance = currentDistance;
        }
      }
    }, { passive: true });
  }
  
  setupCommunication() {
    window.addEventListener('message', (event) => {
      // Validate origin (in production, check against known origins)
      // For development, accept all
      
      const message = event.data;
      if (!message || !message.type) return;
      
      switch (message.type) {
        case 'COMMAND':
          this.handleCommand(message.command, message.data);
          break;
          
        case 'UPDATE_PARAM':
          if (message.moduleId === this.id || message.moduleId === 'all') {
            this.state.updateParam(message.param, message.value);
            this.updateDialDisplay(message.param, message.value);
          }
          break;
          
        case 'SET_MODE':
          this.setMode(message.mode);
          break;
          
        case 'TOGGLE_TRANSPORT':
          this.state.transport = !this.state.transport;
          break;
          
        case 'EXPERIMENT':
          this.runExperiment(message.experiment);
          break;
          
        case 'SYNC_STATE':
          this.state.importState(message.state);
          break;
          
        case 'PING':
          this.sendMessage('PONG', { id: this.id, time: Date.now() });
          break;
      }
    });
    
    // Start heartbeat
    this.heartbeat = setInterval(() => {
      this.sendMessage('HEARTBEAT', {
        id: this.id,
        performance: this.performance.getAverageFPS(),
        state: this.state.exportState()
      });
    }, this.config.heartbeatInterval);
  }
  
  sendMessage(type, data) {
    if (this.parentConnection !== window) {
      this.parentConnection.postMessage({
        type,
        moduleId: this.id,
        ...data
      }, this.config.parentOrigin);
    }
  }
  
  handleCommand(command, data) {
    switch (command) {
      case 'play':
        this.state.transport = true;
        break;
        
      case 'stop':
        this.state.transport = false;
        break;
        
      case 'reset':
        Object.keys(this.state.params).forEach(param => {
          const def = this.state.params[param];
          this.state.updateParam(param, (def.min + def.max) / 2);
        });
        break;
        
      case 'randomize':
        this.randomizeParameters();
        break;
        
      case 'export':
        this.exportState();
        break;
    }
  }
  
  handleOrchestratorAction(action) {
    switch (action) {
      case 'export':
        this.exportState();
        break;
        
      case 'randomize':
        this.randomizeParameters();
        Utils.haptic(50);
        break;
        
      case 'experiment':
        this.openExperimentPanel();
        break;
    }
  }
  
  setActiveTool(tool) {
    this.state.activeTool = tool;
    
    // Update UI
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
    
    // Show dial
    const dial = document.getElementById('parameter-dial');
    dial.style.display = 'flex';
    
    // Update dial value
    this.updateDialDisplay(tool, this.state.getParamValue(tool));
    
    Utils.haptic(10);
  }
  
  updateDialDisplay(param, value) {
    const paramDef = this.state.params[param];
    if (!paramDef) return;
    
    const percentage = Math.round(((value - paramDef.min) / (paramDef.max - paramDef.min)) * 100);
    document.getElementById('dial-value').textContent = percentage;
    
    // Update dial visual
    const dial = document.getElementById('parameter-dial');
    const hue = Utils.map(percentage, 0, 100, 180, 300);
    dial.style.borderColor = `hsl(${hue}, 100%, 50%)`;
    dial.style.boxShadow = `0 0 20px hsla(${hue}, 100%, 50%, 0.3)`;
  }
  
  setMode(mode) {
    if (mode === this.state.mode) return;
    
    this.state.mode = mode;
    
    // Update UI
    const sculptGroup = document.getElementById('grp-sculpt');
    const seqGroup = document.getElementById('grp-seq');
    
    if (mode === 'sculpt') {
      sculptGroup.style.display = 'flex';
      seqGroup.style.display = 'none';
      this.racks.forEach(rack => rack.unlockSequencer());
    } else {
      sculptGroup.style.display = 'none';
      seqGroup.style.display = 'flex';
      this.racks.forEach(rack => rack.lockSequencer());
    }
    
    document.getElementById('mode-display').textContent = mode.toUpperCase();
    
    this.sendMessage('MODE_CHANGE', { mode });
    Utils.haptic(20);
  }
  
  toggleMode() {
    this.setMode(this.state.mode === 'sculpt' ? 'sequence' : 'sculpt');
  }
  
  randomizeParameters() {
    Object.keys(this.state.params).forEach(param => {
      const range = this.state.params[param];
      const randomValue = Utils.randomInt(range.min, range.max);
      this.state.updateParam(param, randomValue);
    });
    
    this.sendMessage('PARAMS_RANDOMIZED', {});
  }
  
  exportState() {
    const state = this.state.exportState();
    
    // Create download link
    const dataStr = JSON.stringify(state, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
    
    const exportFileDefaultName = `hyperclay_${this.id}_${Date.now()}.json`;
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
    
    this.sendMessage('STATE_EXPORTED', { state });
  }
  
  // === INTERACTION HANDLERS ===
  handlePointerDown(e) {
    e.preventDefault();
    
    const x = e.clientX || e.touches?.[0]?.clientX || 0;
    const y = e.clientY || e.touches?.[0]?.clientY || 0;
    
    this.mouse.x = x;
    this.mouse.y = y;
    
    // Check for mode toggle (right orb simulation)
    if (x > this.width - 60 && y > this.height - 60) {
      this.toggleMode();
      Utils.haptic(15);
      return;
    }
    
    // Check for transport toggle (left orb simulation)
    if (x < 60 && y > this.height - 60) {
      this.state.transport = !this.state.transport;
      this.sendMessage('TRANSPORT_CHANGE', { transport: this.state.transport });
      Utils.haptic(15);
      return;
    }
    
    // Check racks
    let hitRack = false;
    
    for (const rack of this.racks) {
      if (rack.hitTest(x, y)) {
        if (this.state.mode === 'sequence' && rack.sequencer.locked) {
          // Toggle sequencer cell
          const cellIndex = rack.getCellAt(x, y);
          if (cellIndex !== -1) {
            rack.sequencer.cells[cellIndex].active = !rack.sequencer.cells[cellIndex].active;
            Utils.haptic(5);
          }
        } else {
          // Sculpt mode or unlocked sequencer
          this.dragging = true;
          this.pulling = e.button === 2 || e.ctrlKey || e.metaKey;
          this.sculptAt(x, y);
        }
        hitRack = true;
        break;
      }
    }
    
    if (!hitRack) {
      this.dragging = true;
    }
  }
  
  handlePointerMove(e) {
    e.preventDefault();
    
    const x = e.clientX || e.touches?.[0]?.clientX || 0;
    const y = e.clientY || e.touches?.[0]?.clientY || 0;
    
    this.mouse.x = x;
    this.mouse.y = y;
    
    if (this.dragging && this.state.mode === 'sculpt') {
      this.sculptAt(x, y);
    }
  }
  
  handlePointerUp() {
    this.dragging = false;
    this.pulling = false;
  }
  
  sculptAt(x, y) {
    const strength = this.state.getParamValue('strength');
    const radius = this.state.getParamValue('radius');
    
    let triggeredAudio = false;
    
    this.racks.forEach((rack, i) => {
      if (rack.hitTest(x, y)) {
        const deformed = rack.sculpt(x, y, strength, radius, this.pulling);
        
        // Occasionally trigger audio feedback
        if (deformed && Math.random() > 0.7 && !triggeredAudio) {
          this.audio.playNote(i, Math.random() * 0.5 + 0.3, 0.2);
          triggeredAudio = true;
        }
      }
    });
  }
  
  // === SEQUENCER ===
  updateSequencer(time) {
    if (!this.state.transport) return;
    
    const bpm = this.state.getParamValue('tempo');
    const secondsPerStep = 60 / bpm / 4; // 16th notes
    
    if (time - this.lastStepTime >= secondsPerStep) {
      this.lastStepTime = time;
      
      // Trigger audio for active cells
      this.racks.forEach((rack, rackIndex) => {
        if (!rack.sequencer.locked) return;
        
        const totalCells = rack.sequencer.cells.length;
        const cellsPerStep = Math.ceil(totalCells / 16);
        const start = this.sequenceStep * cellsPerStep;
        const end = Math.min(start + cellsPerStep, totalCells);
        
        let hitCount = 0;
        
        for (let i = start; i < end; i++) {
          if (rack.sequencer.cells[i]?.active) {
            hitCount++;
            
            // Calculate intensity based on cell position
            const intensity = 0.3 + (i % cellsPerStep) / cellsPerStep * 0.7;
            
            // Trigger audio
            this.audio.playNote(rackIndex, intensity, 0.3);
          }
        }
        
        // Visual feedback for step
        if (hitCount > 0) {
          this.sendMessage('STEP_TRIGGERED', {
            rack: rackIndex,
            step: this.sequenceStep,
            hits: hitCount
          });
        }
      });
      
      this.sequenceStep = (this.sequenceStep + 1) % 16;
    }
  }
  
  // === EXPERIMENTATION ===
  openExperimentPanel() {
    document.getElementById('experiment-overlay').style.display = 'flex';
  }
  
  runExperiment(experimentConfig) {
    const config = experimentConfig || {
      paramSweep: document.getElementById('exp-param-sweep').checked,
      oscSync: document.getElementById('exp-osc-sync').checked,
      intensity: parseInt(document.getElementById('exp-intensity').value) / 100
    };
    
    this.state.experiments.add('experiment_' + Date.now());
    
    if (config.paramSweep) {
      this.startParameterSweep();
    }
    
    if (config.oscSync) {
      this.syncOscillators();
    }
    
    // Apply variance
    this.state.applyVariance();
    
    this.sendMessage('EXPERIMENT_STARTED', { config });
    
    // Close panel
    this.closeExperiment();
  }
  
  startParameterSweep() {
    let sweepParam = 'strength';
    let direction = 1;
    let value = this.state.getParamValue(sweepParam);
    
    this.experimentInterval = setInterval(() => {
      value += direction * 2;
      
      if (value >= this.state.params[sweepParam].max || value <= this.state.params[sweepParam].min) {
        direction *= -1;
        sweepParam = sweepParam === 'strength' ? 'radius' : 'strength';
        value = this.state.getParamValue(sweepParam);
      }
      
      this.state.updateParam(sweepParam, value);
      this.updateDialDisplay(sweepParam, value);
      
    }, 100);
    
    // Stop after 30 seconds
    setTimeout(() => {
      if (this.experimentInterval) {
        clearInterval(this.experimentInterval);
        this.experimentInterval = null;
      }
    }, 30000);
  }
  
  syncOscillators() {
    // Sync all racks to same tempo
    const baseTempo = this.state.getParamValue('tempo');
    this.state.updateParam('tempo', baseTempo);
    
    // Sync filter frequencies
    const baseFilter = this.state.getParamValue('filter');
    this.audio.setParam('filter', baseFilter);
  }
  
  closeExperiment() {
    document.getElementById('experiment-overlay').style.display = 'none';
    
    if (this.experimentInterval) {
      clearInterval(this.experimentInterval);
      this.experimentInterval = null;
    }
  }
  
  // === RENDERING ===
  start() {
    let lastTime = 0;
    
    const render = (time) => {
      const deltaTime = (time - lastTime) / 1000;
      lastTime = time;
      
      // Update performance monitor
      this.performance.update();
      
      // Update sequencer
      this.updateSequencer(time / 1000);
      
      // Update racks
      this.racks.forEach(rack => rack.update(deltaTime));
      
      // Render
      this.render();
      
      // Continue loop
      requestAnimationFrame(render);
    };
    
    requestAnimationFrame(render);
  }
  
  render() {
    // Clear canvas
    this.ctx.fillStyle = getComputedStyle(document.documentElement)
      .getPropertyValue('--bg-0').trim();
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Draw grid background
    this.drawGrid();
    
    // Draw racks
    this.racks.forEach(rack => {
      rack.draw(this.ctx, {
        mode: this.state.mode,
        transport: this.state.transport,
        sequenceStep: this.sequenceStep
      });
    });
    
    // Draw cursor/brush
    if (this.dragging && this.state.mode === 'sculpt') {
      this.drawBrush();
    }
    
    // Draw control orbs
    this.drawOrbs();
  }
  
  drawGrid() {
    const gridSize = parseInt(getComputedStyle(document.documentElement)
      .getPropertyValue('--grid-size').trim());
    
    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.03)';
    this.ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x < this.width; x += gridSize) {
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.height);
      this.ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y < this.height; y += gridSize) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, y);
      this.ctx.lineTo(this.width, y);
      this.ctx.stroke();
    }
  }
  
  drawBrush() {
    const radius = this.state.getParamValue('radius');
    
    this.ctx.beginPath();
    this.ctx.arc(this.mouse.x, this.mouse.y, radius, 0, Math.PI * 2);
    
    if (this.pulling) {
      this.ctx.strokeStyle = 'rgba(255, 0, 100, 0.5)';
      this.ctx.fillStyle = 'rgba(255, 0, 100, 0.1)';
    } else {
      this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
      this.ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
    }
    
    this.ctx.fill();
    this.ctx.stroke();
  }
  
  drawOrbs() {
    const orbRadius = 24;
    
    // Left orb (transport)
    this.ctx.beginPath();
    this.ctx.arc(30, this.height - 30, orbRadius, 0, Math.PI * 2);
    this.ctx.fillStyle = this.state.transport ? 'rgba(0, 255, 100, 0.2)' : 'rgba(0, 255, 255, 0.1)';
    this.ctx.strokeStyle = this.state.transport ? '#0f8' : '#0ff';
    this.ctx.lineWidth = 2;
    this.ctx.fill();
    this.ctx.stroke();
    
    // Transport symbol
    this.ctx.fillStyle = '#fff';
    this.ctx.font = 'bold 14px monospace';
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'middle';
    this.ctx.fillText(this.state.transport ? '■' : '▶', 30, this.height - 30);
    
    // Right orb (mode)
    this.ctx.beginPath();
    this.ctx.arc(this.width - 30, this.height - 30, orbRadius, 0, Math.PI * 2);
    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
    this.ctx.strokeStyle = '#0ff';
    this.ctx.lineWidth = 2;
    this.ctx.fill();
    this.ctx.stroke();
    
    // Mode symbol
    this.ctx.fillStyle = '#fff';
    this.ctx.fillText(this.state.mode === 'sculpt' ? 'S' : 'Q', this.width - 30, this.height - 30);
  }
  
  updateModeDisplay() {
    const display = document.getElementById('mode-display');
    display.textContent = this.state.mode.toUpperCase();
    display.style.color = this.state.mode === 'sculpt' ? 'var(--cy-primary)' : 'var(--module-accent)';
  }
}

// === GLOBAL FUNCTIONS ===
function closeExperiment() {
  if (window.module) {
    window.module.closeExperiment();
  }
}

function runExperiment() {
  if (window.module) {
    window.module.runExperiment();
  }
}

// === INITIALIZATION ===
window.addEventListener('DOMContentLoaded', () => {
  // Parse URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const config = {};
  
  // Apply theme variables from URL
  if (urlParams.get('themeVars')) {
    try {
      const themeVars = JSON.parse(urlParams.get('themeVars'));
      Object.entries(themeVars).forEach(([key, value]) => {
        document.documentElement.style.setProperty(`--${key}`, value);
      });
    } catch (e) {
      console.warn('Failed to parse theme vars:', e);
    }
  }
  
  // Initialize module
  try {
    window.module = new HyperclayModule(config);
    
    // Make module available globally
    window.HyperclayModule = HyperclayModule;
    window.ModuleState = ModuleState;
    window.RackUnit = RackUnit;
    
    console.log(`Hyperclay Module ${config.id || 'default'} initialized`);
  } catch (error) {
    console.error('Failed to initialize module:', error);
    document.getElementById('loading').innerHTML = 
      '<div style="color: #ff5555; text-align: center;">ERROR: Failed to initialize module</div>';
  }
});

// === ERROR HANDLING ===
window.addEventListener('error', (event) => {
  console.error('Module error:', event.error);
  
  if (window.module) {
    window.module.sendMessage('ERROR', {
      message: event.error.message,
      stack: event.error.stack
    });
  }
});

// === CLEANUP ===
window.addEventListener('beforeunload', () => {
  if (window.module) {
    window.module.sendMessage('MODULE_UNLOADING', { id: window.module.id });
    
    if (window.module.heartbeat) {
      clearInterval(window.module.heartbeat);
    }
    
    if (window.module.experimentInterval) {
      clearInterval(window.module.experimentInterval);
    }
  }
});
</script>
</body>
</html>
