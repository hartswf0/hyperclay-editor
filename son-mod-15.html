<!-- hyperclay-terrain-v2.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>MODULE // TERRAIN v2</title>
<style>
  :root {
    /* TERRAIN PALETTE */
    --bg: #0c0b0a;
    --panel: #161412;
    --border: #332d26;
    --accent: #d4a418;  /* Gold/Ochre */
    --accent-dim: #5c4d26;
    --signal: #4fffa0;  /* Signal Green */
    --text: #c2b280;    /* Sand */
    --text-dim: #5e544a;
    
    --h: 150px; /* Slight height bump for new controls */
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
  
  body {
    margin: 0; background: var(--bg); height: 100vh;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Courier New', monospace; overflow: hidden;
  }

  /* RACK CHASSIS */
  .rack {
    width: 100%; max-width: 900px; height: var(--h);
    background: var(--panel);
    border: 1px solid var(--border);
    display: grid;
    grid-template-columns: 140px 1fr 90px; /* Left | Center | Right */
    box-shadow: 0 20px 50px #000;
    border-radius: 4px;
    position: relative;
  }
  
  /* DECORATIVE SCREWS */
  .rack::before, .rack::after {
    content:'+'; position:absolute; top:4px; color:var(--border); font-size:10px;
  }
  .rack::before { left:6px; } .rack::after { right:6px; }

  /* --- LEFT: PARAMETERS --- */
  .controls-left {
    padding: 10px;
    display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
    gap: 8px; border-right: 1px solid var(--border);
  }

  .dial-wrapper {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    cursor: ns-resize;
  }
  
  .dial-svg { width: 40px; height: 40px; display: block; }
  .dial-bg { fill: none; stroke: #26221e; stroke-width: 4; }
  .dial-val { 
    fill: none; stroke: var(--accent); stroke-width: 4; stroke-linecap: round;
    stroke-dasharray: 0 100; transform: rotate(-90deg); transform-origin: 50% 50%;
  }
  .dial-label { font-size: 8px; color: var(--text-dim); margin-top: 4px; letter-spacing: 1px; font-weight: bold; }

  /* --- CENTER: SCREEN --- */
  .screen-area {
    position: relative; background: #050504; 
    overflow: hidden; cursor: crosshair;
  }
  canvas { display: block; width: 100%; height: 100%; }
  
  /* HUD Overlay */
  .hud-mode {
    position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
    font-size: 10px; color: var(--text-dim); letter-spacing: 2px;
    pointer-events: none; opacity: 0.5;
  }
  .hud-mode.active { color: var(--accent); opacity: 1; text-shadow: 0 0 10px var(--accent-dim); }

  /* --- RIGHT: TRANSPORT & MINIMAP --- */
  .controls-right {
    border-left: 1px solid var(--border);
    display: flex; flex-direction: column;
    padding: 8px; gap: 8px;
    background: #11100f;
  }

  /* TEMPO DISPLAY */
  .tempo-box {
    background: #000; border: 1px solid var(--border);
    height: 24px; display: flex; align-items: center; justify-content: center;
    color: var(--accent); font-size: 11px; letter-spacing: 1px;
    cursor: ns-resize; border-radius: 2px;
  }
  .tempo-label { font-size: 7px; color: var(--text-dim); margin-right: 4px; }

  /* MINIMAP (OSCILLOSCOPE) */
  .minimap-container {
    flex: 1; background: #050505; 
    border: 1px solid var(--border); border-radius: 2px;
    position: relative; overflow: hidden;
  }
  #mini-scope { width: 100%; height: 100%; opacity: 0.8; }

  /* TRANSPORT BUTTONS */
  .transport-row {
    display: flex; gap: 6px; justify-content: center;
  }
  
  .btn {
    flex: 1; height: 32px; background: #1a1815; border: 1px solid var(--border);
    color: var(--text-dim); display: grid; place-items: center;
    font-size: 14px; cursor: pointer; border-radius: 2px; transition: all 0.1s;
  }
  .btn:hover { border-color: var(--accent-dim); color: var(--text); }
  .btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent-dim); box-shadow: 0 0 10px var(--accent-dim); }
  .btn-small { font-size: 10px; height: 24px; }

  /* --- RESPONSIVE --- */
  @media (max-width: 600px) {
    .rack { grid-template-columns: 110px 1fr 80px; }
    .dial-svg { width: 32px; height: 32px; }
    .hud-mode { font-size: 8px; }
  }
</style>
</head>
<body>

<div class="rack">
  
  <!-- LEFT: PARAMS -->
  <div class="controls-left">
    <!-- DIAL: STRENGTH -->
    <div class="dial-wrapper" id="d-str" data-param="strength" data-min="1" data-max="30" data-val="12">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">FORCE</div>
    </div>
    <!-- DIAL: RADIUS -->
    <div class="dial-wrapper" id="d-rad" data-param="radius" data-min="20" data-max="150" data-val="50">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">SIZE</div>
    </div>
    <!-- DIAL: FILTER -->
    <div class="dial-wrapper" id="d-flt" data-param="filter" data-min="200" data-max="5000" data-val="1200">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">TONE</div>
    </div>
    <!-- DIAL: DECAY -->
    <div class="dial-wrapper" id="d-dec" data-param="release" data-min="100" data-max="1000" data-val="300">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">FADE</div>
    </div>
  </div>

  <!-- CENTER: CANVAS -->
  <div class="screen-area" id="screen">
    <canvas id="cv"></canvas>
    <div class="hud-mode" id="mode-text">SCULPT</div>
  </div>

  <!-- RIGHT: CONTROLS -->
  <div class="controls-right">
    <!-- TEMPO -->
    <div class="tempo-box" id="tempo-control" title="Drag to change BPM">
      <span class="tempo-label">BPM</span> <span id="tempo-val">110</span>
    </div>
    
    <!-- MINIMAP / SCOPE -->
    <div class="minimap-container">
      <canvas id="mini-scope"></canvas>
    </div>

    <!-- TRANSPORT -->
    <div class="transport-row">
      <div class="btn" id="btn-play">▶</div>
    </div>
    <div class="transport-row">
      <div class="btn btn-small" id="btn-mode">MODE</div>
      <div class="btn btn-small" id="btn-clr">CLR</div>
    </div>
  </div>

</div>

<script>
/**
 * HYPERCLAY TERRAIN MODULE V2
 * Features: Live Oscilloscope, Draggable Tempo, Terrain Mesh
 */

const CFG = {
  cols: 16, // Steps
  rows: 8,  // Pitch quantization
  color: '#d4a418'
};

const params = {
  strength: 12, radius: 50, filter: 1200, release: 300,
  tempo: 110
};

const state = {
  playing: false,
  mode: 'sculpt', // sculpt | seq
  mx: 0, my: 0,
  down: false,
  step: 0,
  lastTime: 0
};

// --- AUDIO ENGINE ---
const Audio = {
  ctx: null,
  analyser: null,
  bufferLength: 0,
  dataArray: null,
  
  init() {
    if(this.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AC();
    
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.4;
    
    // Analyser for Minimap
    this.analyser = this.ctx.createAnalyser();
    this.analyser.fftSize = 256;
    this.bufferLength = this.analyser.frequencyBinCount;
    this.dataArray = new Uint8Array(this.bufferLength);
    
    this.master.connect(this.analyser);
    this.analyser.connect(this.ctx.destination);
  },

  playNote(yNorm) {
    if(!this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const flt = this.ctx.createBiquadFilter();
    const gain = this.ctx.createGain();
    
    // Scale Logic
    const scale = [0, 2, 4, 7, 9, 12];
    const idx = Math.floor((1-yNorm) * (scale.length)); 
    const note = scale[Math.max(0, Math.min(idx, scale.length-1))];
    const freq = 110 * Math.pow(2, note/12); // A2 Root

    osc.frequency.setValueAtTime(freq, t);
    osc.type = 'sawtooth'; // Gritty sound
    
    flt.type = 'lowpass';
    flt.frequency.value = params.filter;
    flt.Q.value = 4;
    
    const dur = params.release / 1000;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + dur);

    osc.connect(flt).connect(gain).connect(this.master);
    osc.start(t); osc.stop(t + dur + 0.1);
  }
};

// --- CANVAS & MESH ---
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const scopeCv = document.getElementById('mini-scope');
const scopeCtx = scopeCv.getContext('2d');
let W, H, pts = [], cells = [];

function resize() {
  const rect = cv.parentElement.getBoundingClientRect();
  W = cv.width = rect.width;
  H = cv.height = rect.height;
  
  // Scope Resize
  const sRect = scopeCv.parentElement.getBoundingClientRect();
  scopeCv.width = sRect.width;
  scopeCv.height = sRect.height;

  initGrid();
}

function initGrid() {
  pts = [];
  // Create organic mesh points
  const pRows = 10, pCols = 30;
  for(let r=0; r<=pRows; r++) {
    for(let c=0; c<=pCols; c++) {
      const x = (c/pCols) * W;
      const y = (r/pRows) * H;
      pts.push({x, y, ox:x, oy:y, active:false});
    }
  }
  
  cells = [];
  // Create sequencer cells (16 steps)
  const cellW = W/16;
  const cellH = H;
  for(let i=0; i<16; i++) {
    cells.push({ x: i*cellW, w: cellW, active: false, triggerY: 0 });
  }
}

// --- INTERACTION ---
function sculpt(x, y) {
  const r2 = params.radius * params.radius;
  pts.forEach(p => {
    const dx = p.x - x;
    const dy = p.y - y;
    if(dx*dx + dy*dy < r2) {
      const d = Math.sqrt(dx*dx + dy*dy);
      const f = (1 - d/params.radius) * (params.strength * 0.5);
      // Soft push logic
      p.y += (y - p.y) * 0.1 * f; 
      // Clamp
      p.y = Math.max(0, Math.min(H, p.y));
    }
  });
}

function checkCells() {
  // Determine if a cell is active based on mesh distortion
  cells.forEach((c, i) => {
    // Find points in this cell column
    const colPts = pts.filter(p => p.x >= c.x && p.x < c.x + c.w);
    let maxDist = 0;
    let avgY = 0;
    colPts.forEach(p => {
      const dist = Math.abs(p.y - p.oy);
      if(dist > maxDist) maxDist = dist;
      avgY += p.y;
    });
    
    if(maxDist > 10) {
      c.active = true;
      c.triggerY = avgY / colPts.length;
    } else {
      c.active = false;
    }
  });
}

// Event Listeners
cv.addEventListener('pointerdown', e => {
  Audio.init();
  state.down = true;
  state.mx = e.offsetX; state.my = e.offsetY;
  cv.setPointerCapture(e.pointerId);
  if(state.mode === 'sculpt') sculpt(state.mx, state.my);
  else {
    // Manual Trigger in Seq mode
    Audio.playNote(state.my/H);
  }
});

cv.addEventListener('pointermove', e => {
  state.mx = e.offsetX; state.my = e.offsetY;
  if(state.down && state.mode === 'sculpt') sculpt(state.mx, state.my);
});

window.addEventListener('pointerup', () => state.down = false);
window.addEventListener('resize', resize);

// --- CONTROLS LOGIC ---
// Dials
document.querySelectorAll('.dial-wrapper').forEach(el => {
  let startY, startVal;
  const param = el.dataset.param;
  const min = parseFloat(el.dataset.min);
  const max = parseFloat(el.dataset.max);
  
  const update = (v) => {
    params[param] = v;
    const pct = (v - min)/(max - min);
    el.querySelector('.dial-val').style.strokeDasharray = `${pct*100} 100`;
  };
  
  // Init visual
  update(parseFloat(el.dataset.val));

  el.addEventListener('pointerdown', e => {
    startY = e.clientY; startVal = params[param];
    el.setPointerCapture(e.pointerId);
    el.onpointermove = ev => {
      const d = startY - ev.clientY;
      const val = Math.max(min, Math.min(max, startVal + (d/100)*(max-min)));
      update(val);
    };
    el.onpointerup = () => el.onpointermove = null;
  });
});

// Tempo Drag
const tempoEl = document.getElementById('tempo-control');
const tempoValEl = document.getElementById('tempo-val');
let tempoStartY, tempoStartVal;
tempoEl.addEventListener('pointerdown', e => {
  tempoStartY = e.clientY;
  tempoStartVal = params.tempo;
  tempoEl.setPointerCapture(e.pointerId);
  tempoEl.onpointermove = ev => {
    const d = tempoStartY - ev.clientY;
    params.tempo = Math.floor(Math.max(60, Math.min(240, tempoStartVal + d)));
    tempoValEl.innerText = params.tempo;
  };
  tempoEl.onpointerup = () => tempoEl.onpointermove = null;
});

// Buttons
const btnPlay = document.getElementById('btn-play');
btnPlay.onclick = () => {
  Audio.init();
  state.playing = !state.playing;
  btnPlay.classList.toggle('active', state.playing);
  btnPlay.innerText = state.playing ? '■' : '▶';
  if(state.playing && Audio.ctx.state === 'suspended') Audio.ctx.resume();
};

const btnMode = document.getElementById('btn-mode');
btnMode.onclick = () => {
  state.mode = state.mode === 'sculpt' ? 'seq' : 'sculpt';
  document.getElementById('mode-text').innerText = state.mode.toUpperCase();
  document.getElementById('mode-text').classList.toggle('active', state.mode === 'seq');
};

document.getElementById('btn-clr').onclick = () => {
  initGrid();
};

// --- RENDER LOOP ---
function drawScope() {
  const w = scopeCv.width;
  const h = scopeCv.height;
  scopeCtx.fillStyle = '#050505';
  scopeCtx.fillRect(0,0,w,h);
  
  if(!Audio.analyser) return;
  
  Audio.analyser.getByteTimeDomainData(Audio.dataArray);
  
  scopeCtx.lineWidth = 2;
  scopeCtx.strokeStyle = state.playing ? '#4fffa0' : '#333';
  scopeCtx.beginPath();
  
  const sliceWidth = w * 1.0 / Audio.bufferLength;
  let x = 0;
  
  for(let i=0; i<Audio.bufferLength; i++) {
    const v = Audio.dataArray[i] / 128.0;
    const y = v * h/2;
    if(i===0) scopeCtx.moveTo(x,y);
    else scopeCtx.lineTo(x,y);
    x += sliceWidth;
  }
  scopeCtx.stroke();
  
  // Grid lines on scope
  scopeCtx.fillStyle = 'rgba(255,255,255,0.1)';
  scopeCtx.fillRect(0, h/2, w, 1);
}

function loop() {
  requestAnimationFrame(loop);
  
  // Logic
  checkCells();
  
  if(state.playing && Audio.ctx) {
    const now = Audio.ctx.currentTime;
    const stepTime = 60 / params.tempo / 4; // 16th notes
    if(now - state.lastTime > stepTime) {
      state.lastTime = now;
      state.step = (state.step + 1) % 16;
      
      const c = cells[state.step];
      if(c.active) Audio.playNote(c.triggerY / H);
    }
  }

  // Draw Main
  ctx.fillStyle = '#050504';
  ctx.fillRect(0,0,W,H);
  
  // Draw Grid
  ctx.strokeStyle = '#1a1815';
  ctx.lineWidth = 1;
  cells.forEach(c => {
    ctx.beginPath(); ctx.moveTo(c.x, 0); ctx.lineTo(c.x, H); ctx.stroke();
  });
  
  // Draw Mesh
  ctx.strokeStyle = '#d4a418';
  ctx.lineWidth = 1;
  ctx.beginPath();
  // Horizontal lines (rows)
  const pRows = 10, pCols = 30;
  for(let r=0; r<=pRows; r++) {
    for(let c=0; c<=pCols; c++) {
      const p = pts[r*(pCols+1)+c];
      if(c===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
  }
  ctx.stroke();
  
  // Highlight Active Cells
  cells.forEach((c, i) => {
    if(c.active) {
      ctx.fillStyle = 'rgba(212, 164, 24, 0.2)';
      ctx.fillRect(c.x, 0, c.w, H);
    }
  });

  // Playhead
  if(state.playing) {
    const x = (state.step / 16) * W;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  
  // Draw Cursor
  if(state.down && state.mode === 'sculpt') {
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath(); ctx.arc(state.mx, state.my, params.radius, 0, Math.PI*2); ctx.stroke();
  }
  
  // Draw Scope
  drawScope();
}

resize();
loop();

</script>
</body>
</html>
