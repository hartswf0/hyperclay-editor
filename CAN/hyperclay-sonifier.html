<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>HyperClay — Server Rack Sequencer</title>
<style>
  :root{
    --bg0:#0a0e27;--bg1:#121636;--cy:#00ffff;--ink:#e6fff9;--glow:0 0 30px rgba(0,255,255,.4);
    --panel:rgba(0,0,0,.55);--panel2:rgba(0,0,0,.22);--ring:rgba(0,255,255,.18);
    --ok:#00ff88;--warn:#ff3355;--note:#33aaff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(120% 120% at 50% 20%,var(--bg1) 0%,var(--bg0) 60%);
       font-family: Courier,"Courier New",monospace;color:var(--ink);overflow:hidden;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility}
  canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block;background:transparent;touch-action:none}
  /* HUD (hidden – we integrate controls into canvas) */
  .hud{display:none}
  .mode{position:fixed;top:env(safe-area-inset-top,8px);left:50%;transform:translateX(-50%);
        border:1px solid var(--cy);padding:6px 10px;border-radius:4px;background:var(--panel);
        color:var(--cy);font-weight:700;font-size:10px;letter-spacing:.18em;box-shadow:var(--glow)}
  .aux{position:fixed;top:env(safe-area-inset-top,8px);right:env(safe-area-inset-right,8px);display:flex;gap:6px}
  .chip{border:1px solid var(--ring);background:var(--panel2);padding:4px 6px;border-radius:4px;font-size:9px;color:var(--cy)}
  .tool-palette{position:fixed;top:50%;left:16px;transform:translateY(-50%);display:flex;flex-direction:column;gap:6px;z-index:2000;transition:opacity .3s}
  .tool-btn{width:64px;height:32px;background:rgba(0,0,0,.9);border:1px solid rgba(0,255,255,.3);
            color:rgba(0,255,255,.7);font-size:9px;display:flex;align-items:center;justify-content:center;
            cursor:pointer;transition:all .15s;backdrop-filter:blur(10px);letter-spacing:.15em;text-transform:uppercase;
            font-weight:700;border-radius:2px}
  .tool-btn:hover{border-color:rgba(0,255,255,.8);color:rgba(0,255,255,.95);background:rgba(0,255,255,.08)}
  .tool-btn.active{border-color:var(--cy);color:#000;background:var(--cy);box-shadow:0 0 12px rgba(0,255,255,.6)}
  .gate{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(60% 60% at 50% 40%,rgba(0,255,255,.06),transparent 60%),linear-gradient(135deg,rgba(0,255,255,.06),transparent);pointer-events:auto}
  .gate .card{border:1px solid var(--cy);border-radius:6px;padding:16px;background:var(--panel);box-shadow:var(--glow);text-align:center;max-width:520px}
  .gate h1{margin:0 0 6px 0;font-size:16px;letter-spacing:.28em;text-transform:uppercase;color:var(--cy)}
  .gate p{margin:6px 0;font-size:12px;opacity:.85}
  .prime{margin-top:8px}
  .prime button{all:unset;cursor:pointer;border:1px solid var(--cy);padding:8px 12px;border-radius:4px;color:var(--cy);font-weight:800;letter-spacing:.2em;text-transform:uppercase;box-shadow:var(--glow)}
  .prime button:hover{background:rgba(0,255,255,.12)}
  .hide{opacity:0;pointer-events:none;transition:opacity .35s ease}
  .scan{position:fixed;inset:0;background:repeating-linear-gradient(180deg,rgba(0,255,255,.03),rgba(0,255,255,.03) 1px,transparent 1px,transparent 3px);mix-blend-mode:overlay;pointer-events:none}
  @media (prefers-reduced-motion:reduce){.scan{display:none}}
</style>
</head>
<body>
  <canvas id="cv"></canvas>
  <div class="scan"></div>

  <div class="mode" id="mode">SCULPT</div>

  <!-- Tool Palettes -->
  <div class="tool-palette" id="sculpt-tools">
    <div class="tool-btn active" data-tool="strength">FORCE</div>
    <div class="tool-btn" data-tool="radius">SIZE</div>
    <div class="tool-btn" data-tool="density">GRID</div>
  </div>
  <div class="tool-palette" id="seq-tools" style="opacity:0;pointer-events:none">
    <div class="tool-btn active" data-tool="tempo">TEMPO</div>
    <div class="tool-btn" data-tool="filter">FILTER</div>
    <div class="tool-btn" data-tool="attack">ATTACK</div>
    <div class="tool-btn" data-tool="release">DECAY</div>
  </div>

  <!-- Canvas-integrated controls: two corner orbs (left = transport/scale; right = sculpt params). HUD removed. -->
  <div class="gate" id="gate">
    <div class="card">
      <h1>HYPERCLAY</h1>
      <p>Grid mesh topology IS the synthesizer. Sculpt the grids freely, then LOCK them to turn each irregular quad into a sequencer cell.</p>
      <p>The sequencer inherits the exact geometry of your deformation. Shape → Sound → Sequence.</p>
      <div class="prime"><button id="enter">ENTER</button></div>
      <p style="opacity:.65;margin-top:10px">Select tool · Drag right orb in circle to adjust value · Tap left orb to play · Tap right orb to lock/unlock</p>
    </div>
  </div>

<script>
// ====== Utilities
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const DPR=clamp(Math.round((window.devicePixelRatio||1)*1)/1,1,2);
const haptic=(ms)=>{try{ if(navigator.vibrate) navigator.vibrate(ms); }catch(e){}};

// ====== Canvas + Resize
const cv=document.getElementById('cv');
const ctx=cv.getContext('2d');
function resize(){
  const {innerWidth:w, innerHeight:h}=window; 
  cv.width=w*DPR; cv.height=h*DPR; cv.style.width=w+'px'; cv.style.height=h+'px'; ctx.setTransform(DPR,0,0,DPR,0,0);
  if(w<600){ density=Math.max(12,density); }
  buildRacks(); buildSequencerGrid(); computeOrbs();
}

// ====== Parameters / State
let strength=8, radius=60, density=20; 
let sculptMode=true, dragging=false, pulling=false; 
let trance=false, wavePhase=0; 
let lastTime=performance.now(), fps=0, fpsFilter=0;
let mode='sculpt'; // 'sculpt' | 'seq' | 'images'
let _scale='majp'; // UI's notion of current scale

// Gesture helpers
let lastTap=0, longTimer=null, moved=false; const pointers=new Map(); let pinchStart=null;
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

// ====== Mesh (3 racks = 3 tracks)
class RackUnit{
  constructor(x,y,w,h,track){ this.x=x; this.y=y; this.w=w; this.h=h; this.track=track; this.active=true; this.cols=density; this.rows=Math.floor(density*(h/w)); this.orig=[]; this.pts=[]; this.seqLocked=false; this.seqCells=[]; this.init(); }
  init(){ this.pts.length=0; this.orig.length=0; for(let r=0;r<=this.rows;r++){
      for(let c=0;c<=this.cols;c++){
        const px=this.x+(c/this.cols)*this.w; const py=this.y+(r/this.rows)*this.h;
        const p={x:px,y:py}; this.pts.push(p); this.orig.push({x:px,y:py});
      }
    }
  }
  regrid(){ this.cols=density; this.rows=Math.floor(density*(this.h/this.w)); this.init(); if(this.seqLocked) this.lockSequencer(); }
  reset(){ this.pts=this.orig.map(p=>({x:p.x,y:p.y})); }
  sculpt(mx,my,s,rad,pull=false){ const r2=rad*rad; let influenceSum=0; let cx=0,cy=0;
    for(let i=0;i<this.pts.length;i++){
      const p=this.pts[i]; const dx=p.x-mx, dy=p.y-my; const d2=dx*dx+dy*dy;
      if(d2<r2){ const dist=Math.sqrt(d2); const infl=1-(dist/rad); const f=infl*s*(pull?-1:1); const ang=Math.atan2(dy,dx); p.x+=Math.cos(ang)*f; p.y+=Math.sin(ang)*f; influenceSum+=infl; cx+=p.x*infl; cy+=p.y*infl; }
    }
    if(influenceSum>0){ const cxn=cx/influenceSum, cyn=cy/influenceSum; sound.sculptMod(this.track,cxn/innerWidth, cyn/innerHeight, pull); twinkleBurst(cxn,cyn); }
  }
  wave(t){ for(let i=0;i<this.pts.length;i++){ const o=this.orig[i]; const p=this.pts[i]; p.x=o.x + Math.sin(t*0.0015+ o.y*0.012)*18; p.y=o.y + Math.cos(t*0.0012+ o.x*0.010)*9; } }
  explode(){ for(let i=0;i<this.pts.length;i++){ const o=this.orig[i]; const cx=this.x+this.w/2, cy=this.y+this.h/2; const dx=o.x-cx, dy=o.y-cy; const ang=Math.atan2(dy,dx); const force=30+Math.random()*55; this.pts[i].x=o.x+Math.cos(ang)*force; this.pts[i].y=o.y+Math.sin(ang)*force; } }
  draw(){
    ctx.strokeStyle='rgba(0,255,255,.22)'; ctx.lineWidth=1;
    for(let r=0;r<=this.rows;r++){ ctx.beginPath(); for(let c=0;c<=this.cols;c++){ const i=r*(this.cols+1)+c; const p=this.pts[i]; if(c===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke(); }
    for(let c=0;c<=this.cols;c++){ ctx.beginPath(); for(let r=0;r<=this.rows;r++){ const i=r*(this.cols+1)+c; const p=this.pts[i]; if(r===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke(); }
    for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){
      const i=r*(this.cols+1)+c; const p1=this.pts[i], p2=this.pts[i+1], p3=this.pts[i+this.cols+1], p4=this.pts[i+this.cols+2];
      const g=ctx.createLinearGradient(p1.x,p1.y,p4.x,p4.y); g.addColorStop(0,'rgba(42,42,74,.55)'); g.addColorStop(1,'rgba(26,26,46,.85)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p4.x,p4.y); ctx.lineTo(p3.x,p3.y); ctx.closePath(); ctx.fill();
      if(mode==='images') drawCellImage(p1,p2,p4,p3);
    }
    this.drawLEDs();
    if(this.seqLocked) this.drawSequencer();
  }
  drawLEDs(){ const num=8, sx=this.x+30, sp=(this.w-60)/num; for(let i=0;i<num;i++){ const lx=sx+i*sp, ly=this.y+20; let cd=1e9, cp={x:lx,y:ly}; for(const p of this.pts){ const d=(p.x-lx)**2+(p.y-ly)**2; if(d<cd){ cd=d; cp=p; } } const isPlaying=(lastNoteLane===this.track && notePulse>0.3); const color= isPlaying? 'rgba(51,170,255,.9)' : 'rgba(255,255,255,.25)'; ctx.fillStyle=color; ctx.shadowBlur= isPlaying? 14: 6; ctx.shadowColor=color; ctx.beginPath(); ctx.arc(cp.x,cp.y, isPlaying? 4.5:3,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; } }
  lockSequencer(){
    // Lock current mesh geometry as sequencer cells
    this.seqLocked = true;
    this.seqCells = [];
    // Each quad becomes a sequencer cell
    for(let row=0; row<this.rows; row++){
      for(let col=0; col<this.cols; col++){
        const i = row*(this.cols+1)+col;
        const p1=this.pts[i], p2=this.pts[i+1], p3=this.pts[i+this.cols+1], p4=this.pts[i+this.cols+2];
        this.seqCells.push({
          corners: [{x:p1.x,y:p1.y},{x:p2.x,y:p2.y},{x:p4.x,y:p4.y},{x:p3.x,y:p3.y}],
          active: false,
          row, col
        });
      }
    }
    haptic(20);
  }
  unlockSequencer(){
    this.seqLocked = false;
    this.seqCells = [];
    haptic(12);
  }
  drawSequencer(){
    // Draw sequencer cells as irregular quads matching mesh geometry
    const totalCells = this.seqCells.length;
    const cellsPerStep = Math.max(1, Math.floor(totalCells / 16));
    
    this.seqCells.forEach((cell, idx)=>{{
      const step = Math.floor(idx / cellsPerStep);
      const isCurrentStep = (seqStep === step);
      const corners = cell.corners;
      
      // Draw irregular quad
      ctx.beginPath();
      ctx.moveTo(corners[0].x, corners[0].y);
      ctx.lineTo(corners[1].x, corners[1].y);
      ctx.lineTo(corners[2].x, corners[2].y);
      ctx.lineTo(corners[3].x, corners[3].y);
      ctx.closePath();
      
      // Background
      ctx.fillStyle = isCurrentStep ? 'rgba(0,255,255,.2)' : 'rgba(0,0,0,.4)';
      ctx.fill();
      
      // Active indicator
      if(cell.active){
        ctx.fillStyle = isCurrentStep ? 'rgba(0,255,255,.9)' : 'rgba(0,255,255,.5)';
        ctx.fill();
      }
      
      // Border
      ctx.strokeStyle = 'rgba(0,255,255,.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }});
  }
  hitTestCell(x,y){ 
    if(!this.seqLocked) return null;
    // Test against irregular quad geometry
    for(let i=0; i<this.seqCells.length; i++){
      const corners = this.seqCells[i].corners;
      if(pointInQuad(x, y, corners)){
        return i;
      }
    }
    return null;
  }
  hitTest(x,y){ return x>=this.x && x<=this.x+this.w && y>=this.y && y<=this.y+this.h; }
}

// Point-in-quad test using ray casting
function pointInQuad(px, py, corners){
  let inside = false;
  for(let i=0, j=3; i<4; j=i++){
    const xi=corners[i].x, yi=corners[i].y;
    const xj=corners[j].x, yj=corners[j].y;
    if(((yi>py)!==(yj>py)) && (px<(xj-xi)*(py-yi)/(yj-yi)+xi)){
      inside = !inside;
    }
  }
  return inside;
}

let racks=[]; function buildRacks(){ const W=innerWidth,H=innerHeight,pad=Math.min(200,W*0.12); const x=pad,w=W-pad*2,h=Math.min(140,Math.max(86,H*0.14)); racks=[new RackUnit(x,H*0.18,w,h,0),new RackUnit(x,H*0.43,w,h,1),new RackUnit(x,H*0.68,w,h,2)]; }

// ====== Sequencer State
let seqStep=0; let seqTempo=90; 
let lastNoteLane=-1; let notePulse=0; 
function buildSequencerGrid(){ /* sequences are on each rack */ }

// ====== Shape → Sound metrics (DEEP SYNTH INTEGRATION)
// Grid mesh topology directly controls synthesizer parameters
function rackMetrics(r){
  let area=0, devSum=0, count=0, cx=0, cy=0;
  let maxDev=0, minDev=1e9; // track extremes
  const cols=r.cols, rows=r.rows, pts=r.pts, orig=r.orig;
  
  // VERTEX ANALYSIS: Each vertex displacement = harmonic weight
  const vertexDeviations = [];
  for(let i=0;i<pts.length;i++){ 
    const p=pts[i], o=orig[i]; 
    const dev = Math.hypot(p.x-o.x,p.y-o.y);
    devSum += dev;
    vertexDeviations.push(dev);
    maxDev = Math.max(maxDev, dev);
    minDev = Math.min(minDev, dev);
    cx+=p.x; cy+=p.y; count++; 
  }
  
  // EDGE TENSION: Stretched edges = higher harmonics
  let edgeTension = 0;
  for(let row=0; row<=rows; row++){
    for(let col=0; col<cols; col++){
      const i=row*(cols+1)+col;
      const p1=pts[i], p2=pts[i+1];
      const o1=orig[i], o2=orig[i+1];
      const curLen = Math.hypot(p2.x-p1.x, p2.y-p1.y);
      const origLen = Math.hypot(o2.x-o1.x, o2.y-o1.y);
      edgeTension += Math.abs(curLen - origLen) / origLen;
    }
  }
  edgeTension /= (cols*(rows+1));
  
  // QUAD AREA: Each quad deformation = filter modulation
  const quadAreas = [];
  for(let row=0; row<rows; row++){
    for(let col=0; col<cols; col++){
      const i=row*(cols+1)+col;
      const p1=pts[i], p2=pts[i+1], p3=pts[i+cols+1], p4=pts[i+cols+2];
      const a = Math.abs( (p1.x*p2.y - p2.x*p1.y) + (p2.x*p4.y - p4.x*p2.y) + (p4.x*p3.y - p3.x*p4.y) + (p3.x*p1.y - p1.x*p3.y) ) * 0.5;
      area += a;
      quadAreas.push(a);
    }
  }
  
  const normArea = clamp(area/(r.w*r.h),0,3);
  const dev = (devSum/Math.max(1,count));
  const normDev = clamp(dev/80,0,1);
  cx/=Math.max(1,count); cy/=Math.max(1,count);
  const pan = clamp((cx - (r.x + r.w/2)) / (r.w/2), -1, 1);
  const bright = clamp(1 - ((cy - r.y) / r.h), 0, 1);
  
  // TOPOLOGY METRICS for deep synth control
  const devRange = maxDev - minDev; // spread = complexity
  const avgQuadArea = area / quadAreas.length;
  const quadVariance = quadAreas.reduce((sum,a)=>sum+Math.abs(a-avgQuadArea),0)/quadAreas.length;
  
  return {
    area: normArea,           // → pitch
    dev: normDev,            // → gain/duration
    pan,                     // → stereo
    bright,                  // → frequency mod
    tension: clamp(edgeTension,0,1),  // → harmonic content
    complexity: clamp(devRange/50,0,1), // → filter resonance
    variance: clamp(quadVariance/200,0,1) // → modulation depth
  };
}

// Racks ARE the sequencer - no separate grid needed

// Images mode (simple per-cell stickers)
let images=[];
function drawCellImage(p1,p2,p3,p4){ if(images.length===0) return; const cx=(p1.x+p2.x+p3.x+p4.x)/4, cy=(p1.y+p2.y+p3.y)/4; const img=images[(Math.floor(cx+cy))%images.length]; const size=24; ctx.save(); ctx.globalAlpha=0.9; ctx.drawImage(img, cx-size/2, cy-size/2, size, size); ctx.restore(); }

// ====== Input (pointer & keys)
let mx=0,my=0; let Wcache=innerWidth,Hcache=innerHeight;
cv.addEventListener('contextmenu',e=>e.preventDefault());
cv.addEventListener('pointerdown',(e)=>{
  const rect=cv.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  // Check if clicking a sequencer cell (irregular quad)
  for(const r of racks){
    const cellIdx = r.hitTestCell(x,y);
    if(cellIdx !== null){
      r.seqCells[cellIdx].active = !r.seqCells[cellIdx].active;
      haptic(8);
      return;
    }
  }
  // Prevent sculpting when sequencer is locked
  const anyLocked = racks.some(r=>r.seqLocked);
  if(anyLocked || !sculptMode) return; 
  const now=performance.now(); if(now-lastTap<300){ sculptMode=!sculptMode; document.getElementById('mode').textContent=sculptMode?'SCULPT':'VIEW'; haptic(10); if(sound.ready) sound.toggleGate(sculptMode); lastTap=0; return; }
  lastTap=now; moved=false; dragging=true; pulling=(e.button===2||e.ctrlKey||e.metaKey); pointers.set(e.pointerId,{x:e.clientX,y:e.clientY}); clearTimeout(longTimer); longTimer=setTimeout(()=>{ if(!moved){ pulling=true; haptic(18);} }, 350); mx=e.clientX; my=e.clientY; cv.setPointerCapture(e.pointerId); paint(mx,my); haptic(pulling?14:9); sound.ready && sound.brushHit();
});
cv.addEventListener('pointermove',(e)=>{
  if(pointers.has(e.pointerId)) pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(pointers.size===2){ const pts=[...pointers.values()]; if(!pinchStart){ pinchStart={d:dist(pts[0],pts[1]), r:radius}; } const dNow=dist(pts[0],pts[1]); const s=clamp(dNow/(pinchStart.d||1),0.5,2); radius=Math.round(clamp(pinchStart.r*s,20,180)); return; }
  if(!dragging||!sculptMode) return; const dx=Math.abs(e.clientX-mx), dy=Math.abs(e.clientY-my); if(dx+dy>3) moved=true; mx=e.clientX; my=e.clientY; paint(mx,my); if(Math.random()<0.18) haptic(2); sound.ready && Math.random()<0.2 && sound.brushScrub();
});
cv.addEventListener('pointerup',(e)=>{ dragging=false; clearTimeout(longTimer); pointers.delete(e.pointerId); pinchStart=null; pulling=false; });
cv.addEventListener('pointercancel',(e)=>{ pointers.delete(e.pointerId); pinchStart=null; dragging=false; clearTimeout(longTimer); pulling=false; });
function paint(x,y){ const rect=cv.getBoundingClientRect(); const lx=x-rect.left, ly=y-rect.top; for(const r of racks){ r.sculpt(lx,ly,strength,radius,pulling); } }

document.addEventListener('keydown',(e)=>{ if(e.code==='Space'){ e.preventDefault(); sculptMode=!sculptMode; document.getElementById('mode').textContent=sculptMode?'SCULPT':'VIEW'; haptic(6); sound.ready && sound.toggleGate(sculptMode); return; } if(e.key==='t'||e.key==='T'){ toggleTrance(); } if(e.key==='w'||e.key==='W'){ for(const r of racks) r.wave(performance.now()); } if(e.key==='x'||e.key==='X'){ for(const r of racks) r.explode(); haptic(25); sound.ready && sound.boom(); } });

// ====== (No external HUD). Compact inputs live on-canvas via corner orbs.
// File input for Images mode (single instance to avoid redeclaration)
const imgFileInput=document.createElement('input');
imgFileInput.type='file'; imgFileInput.accept='image/*'; imgFileInput.multiple=true; imgFileInput.style.display='none';
document.body.appendChild(imgFileInput);
imgFileInput.onchange=(e)=>{ const files=[...e.target.files]; images=[]; files.slice(0,32).forEach(f=>{ const img=new Image(); img.src=URL.createObjectURL(f); img.onload=()=>{ images.push(img); }; }); };

function toggleTrance(){ trance=!trance; haptic(8); sound.ready && sound.setTrance(trance); }

// ====== Sound Engine (event‑based, no constant drone)
const sound=(function(){
  const ctx=new (window.AudioContext||window.webkitAudioContext)();
  const master=ctx.createGain(); master.gain.value=0; master.connect(ctx.destination);
  const space=ctx.createGain(); space.gain.value=0.22; space.connect(master);
  const dL=ctx.createDelay(1.2), dR=ctx.createDelay(1.2); dL.delayTime.value=0.27; dR.delayTime.value=0.41; const fbL=ctx.createGain(), fbR=ctx.createGain(); fbL.gain.value=0.23; fbR.gain.value=0.2; dL.connect(fbL); fbL.connect(dL); dR.connect(fbR); fbR.connect(dR); dL.connect(space); dR.connect(space);

  let scale='majp';
  const scales={ lyd:[0,2,4,6,7,9,11], majp:[0,2,4,7,9], dor:[0,2,3,5,7,9,10], aeo:[0,2,3,5,7,8,10] };
  const base=[196,220,247]; // G3, A3, B3

  function degreeToFreq(track, step){ const arr=scales[scale]; const deg=arr[(step)%arr.length]; return base[track]*Math.pow(2,deg/12); }
  function pluck(freq, pan=0, gain=0.16, dur=0.42, tone='sine'){
    const osc=ctx.createOscillator(); osc.type=tone; osc.frequency.value=freq;
    const f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=Math.min(2200, freq*6); f.Q.value=0.5;
    const p=ctx.createStereoPanner? ctx.createStereoPanner():null; osc.connect(f); if(p){ f.connect(p); p.pan.value=pan; p.connect(master); p.connect(dL); p.connect(dR);} else { f.connect(master); f.connect(dL); f.connect(dR); }
    const now=ctx.currentTime; const g=ctx.createGain(); g.gain.value=0.0001; (p||f).connect(g); g.connect(master);
    g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(gain, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
    osc.start(); osc.stop(now+dur+0.02);
  }
  function sculptMod(track,x,y,pull){ const freq=degreeToFreq(track, Math.floor(x*8)); pluck(freq*(pull?0.5:1), (x-0.5)*1.2, 0.12, 0.3, 'triangle'); }
  function playNote(track, step){ const freq=degreeToFreq(track, step); const pan=(track-1)*0.5; const tone = track===0? 'sine' : (track===1? 'triangle':'square'); pluck(freq, pan, 0.18, 0.36, tone); haptic(8); }
  function playShape(track, metrics){
    // DEEP INTEGRATION: Grid topology IS the synth control surface
    // Vertices, edges, and quads each control different synthesis parameters
    
    // PITCH: Area determines base frequency
    const deg = Math.floor(clamp(metrics.area*7,0,6));
    let freq = degreeToFreq(track, deg);
    
    // FREQUENCY MOD: Brightness + tension modulate pitch
    const freqMod = 1 + metrics.bright*0.08 + metrics.tension*0.05;
    freq *= freqMod;
    
    // TIMBRE: Deformation intensity + complexity control gain/duration
    const gain = 0.10 + metrics.dev*0.15 + metrics.complexity*0.08;
    const baseDur = 0.24 + metrics.dev*0.22 + metrics.variance*0.18;
    const dur = baseDur * (envelopeRelease / 400); // USER-CONTROLLED release
    
    // WAVEFORM: Track-based, but tension adds harmonics
    let tone = track===0? 'sine' : (track===1? 'triangle':'square');
    if(metrics.tension > 0.6) tone = 'sawtooth'; // high tension = rich harmonics
    
    // FILTER: USER-CONTROLLED cutoff + mesh variance
    const osc=ctx.createOscillator(); osc.type=tone; osc.frequency.value=freq;
    const meshFilter = clamp(freq * (2 + metrics.variance*4 + metrics.complexity*3), 200, 8000);
    const finalFilter = clamp(meshFilter * (filterCutoff / 2000), 200, 8000); // Blend user + mesh
    const f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=finalFilter;
    f.Q.value = 0.5 + metrics.tension*2; // tension = resonance
    
    // STEREO: Pan position from centroid
    const p=ctx.createStereoPanner? ctx.createStereoPanner():null; 
    osc.connect(f); 
    if(p){ f.connect(p); p.pan.value=metrics.pan; p.connect(master); p.connect(dL); p.connect(dR);} 
    else { f.connect(master); f.connect(dL); f.connect(dR); }
    
    // ENVELOPE: USER-CONTROLLED attack + mesh variance
    const now=ctx.currentTime; const g=ctx.createGain(); g.gain.value=0.0001; 
    (p||f).connect(g); g.connect(master);
    const attack = (envelopeAttack / 1000) + metrics.variance*0.03; // User attack in ms
    g.gain.setValueAtTime(0.0001, now); 
    g.gain.exponentialRampToValueAtTime(gain, now+attack); 
    g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
    osc.start(); osc.stop(now+dur+0.02);
  }
  let started=false,on=true; function start(){ if(started) return; started=true; master.gain.linearRampToValueAtTime(0.2, ctx.currentTime+0.12); }
  function stop(){ on=false; master.gain.linearRampToValueAtTime(0.0001, ctx.currentTime+0.2); }
  function toggle(){ on=!on; if(on) start(); else stop(); }
  function setTrance(t){ /* keep sparse */ }
  function brushHit(){}
  function brushScrub(){}
  function shimmer(){}
  function click(){ const osc=ctx.createOscillator(); osc.frequency.value=660; const g=ctx.createGain(); g.gain.value=0.03; osc.connect(g); g.connect(master); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.04); osc.start(); osc.stop(ctx.currentTime+0.04); }
  function tick(){ const osc=ctx.createOscillator(); osc.frequency.value=880; const g=ctx.createGain(); g.gain.value=0.02; osc.connect(g); g.connect(master); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.05); osc.start(); osc.stop(ctx.currentTime+0.05); }
  function boom(){}
  function toggleGate(sculpt){ master.gain.linearRampToValueAtTime(sculpt?0.2:0.12, ctx.currentTime+0.1); }
  function setScale(s){ scale=s; haptic(14); }
  return {ctx,master,start,stop,toggle,setTrance,brushHit,brushScrub,shimmer,click,tick,boom,toggleGate,sculptMod,playNote,playShape,setScale,get ready(){return ctx&&ctx.state!=='closed'},get on(){return on}};
})();

// Audio gate
const gate=document.getElementById('gate');
const enter=document.getElementById('enter');
enter.addEventListener('click', async ()=>{ try{ await sound.ctx.resume(); sound.start(); gate.classList.add('hide'); setTimeout(()=>gate.style.display='none', 400); haptic(20);}catch(e){ console.warn(e);} });

// ====== Clock (swing + tempo)
let transport=false; let stepDur=0.166; let nextTime=0;
function updateClock(){ stepDur = 60/seqTempo/4; }
function startClock(){ updateClock(); nextTime = sound.ctx.currentTime + 0.05; tickClock(); haptic(20); }
function tickClock(){ if(!transport) return; const now=sound.ctx.currentTime; while(nextTime < now + 0.1){ 
  // Play racks where cells in current step are active
  for(let r=0;r<racks.length;r++){ 
    if(!racks[r].seqLocked) continue;
    const totalCells = racks[r].seqCells.length;
    const cellsPerStep = Math.max(1, Math.floor(totalCells / 16));
    const startIdx = seqStep * cellsPerStep;
    const endIdx = Math.min(startIdx + cellsPerStep, totalCells);
    
    // Check if any cell in this step is active
    let stepActive = false;
    for(let i=startIdx; i<endIdx; i++){
      if(racks[r].seqCells[i].active){
        stepActive = true;
        break;
      }
    }
    
    if(stepActive){ 
      const m=rackMetrics(racks[r]); 
      sound.playShape(r, m); 
      lastNoteLane=r; 
      notePulse=1; 
    } 
  }
  seqStep = (seqStep + 1) % 16;
  nextTime += stepDur; }
 setTimeout(tickClock, 25); }

// ====== Radial Dial System with Haptic Ticks
let activeTool='strength', dialActive=false;
const toolRanges={strength:{min:1,max:20,current:8,step:1},radius:{min:20,max:180,current:60,step:5},density:{min:8,max:40,current:20,step:2},tempo:{min:40,max:200,current:90,step:5},filter:{min:200,max:8000,current:2000,step:100},attack:{min:10,max:100,current:20,step:5},release:{min:100,max:800,current:400,step:25}};
let filterCutoff=2000,envelopeAttack=20,envelopeRelease=400;

function updateToolPalette(){
  const anyLocked=racks.some(r=>r.seqLocked); const sculptTools=document.getElementById('sculpt-tools'); const seqTools=document.getElementById('seq-tools');
  if(anyLocked){ sculptTools.style.opacity='0'; sculptTools.style.pointerEvents='none'; seqTools.style.opacity='1'; seqTools.style.pointerEvents='auto'; activeTool='tempo'; }
  else{ sculptTools.style.opacity='1'; sculptTools.style.pointerEvents='auto'; seqTools.style.opacity='0'; seqTools.style.pointerEvents='none'; activeTool='strength'; }
  document.querySelectorAll('.tool-btn').forEach(btn=>btn.classList.toggle('active',btn.dataset.tool===activeTool));
}
document.querySelectorAll('.tool-btn').forEach(btn=>{
  btn.onclick=()=>{ activeTool=btn.dataset.tool; document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); sound.click(); haptic(10); };
});

function drawRadialDial(){
  if(!dialActive) return;
  const orb=orbs.right;
  const range=toolRanges[activeTool];
  const pct=(range.current-range.min)/(range.max-range.min);
  const angle=-Math.PI/2+pct*Math.PI*1.5;
  
  ctx.save();
  
  // Background arc
  ctx.strokeStyle='rgba(0,255,255,.15)';
  ctx.lineWidth=6;
  ctx.beginPath();
  ctx.arc(orb.x,orb.y,orb.r+14,-Math.PI/2,Math.PI*0.75);
  ctx.stroke();
  
  // Active arc
  ctx.strokeStyle='rgba(0,255,255,.85)';
  ctx.lineWidth=6;
  ctx.beginPath();
  ctx.arc(orb.x,orb.y,orb.r+14,-Math.PI/2,angle);
  ctx.stroke();
  
  // Tick marks
  const steps=Math.ceil((range.max-range.min)/range.step);
  for(let i=0;i<=steps;i++){
    const tickAngle=-Math.PI/2+(i/steps)*Math.PI*1.5;
    const tickLen=(i%5===0)?5:2;
    const r1=orb.r+11;
    const r2=orb.r+11+tickLen;
    const x1=orb.x+Math.cos(tickAngle)*r1;
    const y1=orb.y+Math.sin(tickAngle)*r1;
    const x2=orb.x+Math.cos(tickAngle)*r2;
    const y2=orb.y+Math.sin(tickAngle)*r2;
    ctx.strokeStyle='rgba(0,255,255,.5)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
  }
  
  // Indicator dot
  const dotR=orb.r+14;
  const dotX=orb.x+Math.cos(angle)*dotR;
  const dotY=orb.y+Math.sin(angle)*dotR;
  ctx.fillStyle='rgba(0,255,255,1)';
  ctx.shadowBlur=8;
  ctx.shadowColor='rgba(0,255,255,.8)';
  ctx.beginPath();
  ctx.arc(dotX,dotY,4,0,Math.PI*2);
  ctx.fill();
  ctx.shadowBlur=0;
  
  // Value display
  ctx.fillStyle='rgba(0,255,255,.95)';
  ctx.font='bold 13px Courier';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  const val=Math.round(range.current);
  ctx.fillText(val,orb.x,orb.y-orb.r-28);
  
  // Tool name
  ctx.fillStyle='rgba(0,255,255,.6)';
  ctx.font='9px Courier';
  ctx.fillText(activeTool.toUpperCase(),orb.x,orb.y-orb.r-40);
  
  ctx.restore();
}

function applyToolValue(tool,value){
  const range=toolRanges[tool]; range.current=value;
  if(tool==='strength') strength=value;
  else if(tool==='radius') radius=value;
  else if(tool==='density'){ density=value; racks.forEach(r=>r.regrid()); }
  else if(tool==='tempo'){ seqTempo=value; updateClock(); }
  else if(tool==='filter') filterCutoff=value;
  else if(tool==='attack') envelopeAttack=value;
  else if(tool==='release') envelopeRelease=value;
}

// ====== Draw
function drawBG(){ const W=innerWidth,H=innerHeight; Wcache=W; Hcache=H; ctx.clearRect(0,0,W,H); const a=trance?.08:.05; ctx.strokeStyle=`rgba(0,255,255,${a})`; ctx.lineWidth=1; const grid=40; for(let x=0;x<W;x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<H;y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } ctx.strokeStyle='rgba(0,255,255,.2)'; ctx.lineWidth=1; ctx.strokeRect(4,4,W-8,H-8); drawOrbs(); drawRadialDial(); }
function frame(now){ notePulse*=0.92; drawBG(); if(trance){ for(const r of racks) r.wave(now); } for(const r of racks) r.draw(); if(sculptMode&&mode==='sculpt'){ ctx.strokeStyle=pulling?'rgba(255,0,255,.55)':'rgba(0,255,255,.55)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(mx,my,radius,0,Math.PI*2); ctx.stroke(); } requestAnimationFrame(frame);} 
// ====== On‑canvas Orbs (corner hotkeys)
const orbs={ left:{x:36,y:0,r:26}, right:{x:0,y:0,r:26} };
let orbActive=null; let orbStart={x:0,y:0}; let orbAccum={x:0,y:0};
function computeOrbs(){ orbs.left.y=innerHeight-36; orbs.right.x=innerWidth-36; orbs.right.y=innerHeight-36; }
function drawOrbs(){
  const l=orbs.left, r=orbs.right;
  const anyLocked = racks.some(r=>r.seqLocked);
  ctx.save();
  ctx.fillStyle='rgba(0,255,255,.12)'; ctx.strokeStyle='rgba(0,255,255,.6)';
  ctx.beginPath(); ctx.arc(l.x,l.y,l.r,0,Math.PI*2); ctx.fill(); ctx.stroke();
  // Right orb changes when sequencer locked
  if(anyLocked){
    ctx.fillStyle='rgba(255,215,0,.2)'; ctx.strokeStyle='rgba(255,215,0,.9)';
  }
  ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.fill(); ctx.stroke();
  // glyphs
  ctx.fillStyle='rgba(0,255,255,.9)'; ctx.font='12px Courier'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(transport? '■':'▶', l.x, l.y);
  ctx.fillStyle = anyLocked ? 'rgba(255,215,0,.9)' : 'rgba(0,255,255,.9)';
  ctx.fillText(anyLocked ? '🔒' : '⊞', r.x, r.y);
  ctx.restore();
}
function inOrb(x,y,o){ const dx=x-o.x, dy=y-o.y; return Math.hypot(dx,dy) <= o.r; }

// gestures mapped to orbs: left = transport/tempo/swing/scale, right = sculpt (strength/radius) + mode toggles
cv.addEventListener('pointerdown',(e)=>{
  const rect=cv.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  if(inOrb(x,y,orbs.left)){ orbActive='left'; orbStart={x,y}; orbAccum={x:0,y:0}; haptic(10); return; }
  if(inOrb(x,y,orbs.right)){ orbActive='right'; orbStart={x,y}; orbAccum={x:0,y:0}; haptic(10); return; }
}, true);
cv.addEventListener('pointermove',(e)=>{
  if(!orbActive) return; const rect=cv.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  if(orbActive==='left'){
    const dx=x-orbStart.x, dy=y-orbStart.y; orbAccum.x+=dx; orbAccum.y+=dy; orbStart={x,y};
    if(Math.abs(orbAccum.x)>15){ const dir=orbAccum.x>0?1:-1; seqTempo=clamp(seqTempo+dir*5,40,200); updateClock(); orbAccum.x=0; haptic(8); sound.tick(); }
    return;
  }
  if(orbActive==='right'){
    dialActive=true;
    const orb=orbs.right; const dx=x-orb.x, dy=y-orb.y; let angle=Math.atan2(dy,dx);
    if(angle<-Math.PI/2) angle+=Math.PI*2;
    const range=toolRanges[activeTool]; let pct=(angle+Math.PI/2)/(Math.PI*1.5); pct=clamp(pct,0,1);
    const newValue=range.min+pct*(range.max-range.min); const snapped=Math.round(newValue/range.step)*range.step;
    if(Math.abs(snapped-range.current)>=range.step){ applyToolValue(activeTool,snapped); haptic(5); sound.tick(); }
    orbStart={x,y};
    return;
  }
}, true);
cv.addEventListener('pointerup', (e)=>{
  if(!orbActive) return; const which=orbActive; orbActive=null; dialActive=false;
  if(which==='left'){
    // tap toggles transport; double-tap cycles scale
    if(e.timeStamp - (cv._lt||0) < 280){ // double tap
      const order=['majp','lyd','dor','aeo']; const idx=(order.indexOf(_scale)||0); const next=order[(idx+1)%order.length]; sound.setScale(next); _scale=next; haptic(16);
    } else { transport=!transport; if(transport) startClock(); haptic(14); }
    cv._lt = e.timeStamp;
  } else if(which==='right'){
    // Toggle sequencer lock
    const anyLocked = racks.some(r=>r.seqLocked);
    if(anyLocked){
      racks.forEach(r=>r.unlockSequencer());
      document.getElementById('mode').textContent = 'SCULPT';
    } else {
      racks.forEach(r=>r.lockSequencer());
      document.getElementById('mode').textContent = 'SEQUENCE';
    }
    updateToolPalette();
    haptic(12);
    cv._rt = e.timeStamp;
  }
}, true);

// ====== Twinkle visual burst
function twinkleBurst(x,y){ ctx.save(); ctx.fillStyle='rgba(255,255,255,.15)'; ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.fill(); ctx.restore(); }

// ====== Tests
function runTests(){
  const out=[];
  try{ out.push(['RackUnit defined', typeof RackUnit==='function']); }catch(e){ out.push(['RackUnit defined',false]); }
  out.push(['sound playShape', typeof sound.playShape==='function']);
  // Sequencer tests
  out.push(['racks exist', racks.length===3]);
  out.push(['lockSequencer exists', typeof racks[0].lockSequencer==='function']);
  out.push(['hitTestCell exists', typeof racks[0].hitTestCell==='function']);
  out.push(['drawSequencer exists', typeof racks[0].drawSequencer==='function']);
  // Tool palette tests
  out.push(['sculpt tools exist', !!document.getElementById('sculpt-tools')]);
  out.push(['seq tools exist', !!document.getElementById('seq-tools')]);
  out.push(['tool buttons exist', document.querySelectorAll('.tool-btn').length===7]);
  // Clock test
  const oldTempo=seqTempo; seqTempo=120; updateClock(); const okStep=Math.abs(stepDur - (60/120/4))<1e-6; out.push(['clock stepDur correct', okStep]); seqTempo=oldTempo; updateClock();
  // Sculpt test
  try{ const r=racks[0]; const before={x:r.pts[0].x,y:r.pts[0].y}; r.sculpt(r.x+5,r.y+5,10,50,false); const after=r.pts[0]; out.push(['sculpt works', (before.x!==after.x)||(before.y!==after.y)]);}catch(e){ out.push(['sculpt works', false]); }
  // Deep metrics test
  try{ const m=rackMetrics(racks[0]); out.push(['deep metrics', ['area','dev','pan','bright','tension','complexity','variance'].every(k=>k in m)]); }catch(e){ out.push(['deep metrics', false]); }
  
  console.log('✓ All sequencer tests:', out.every(([,v])=>!!v) ? 'PASS' : 'FAIL');
  if(!out.every(([,v])=>!!v)) console.table(out.map(([t,v])=>({test:t,pass:!!v})));
}

// ====== Boot
window.addEventListener('resize', resize, {passive:true});
resize();
requestAnimationFrame((t)=>{ requestAnimationFrame(frame); runTests(); });
</script>
</body>
</html>
