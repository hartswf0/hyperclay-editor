<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PCL Interface</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #040404;
      --pane: #0b0b0b;
      --edge: #1f1f1f;
      --text: #d0d0d0;
      --dim: #6c6c6c;
      --accent1: #ff5050;
      --accent2: #49ff80;
      --accent3: #6d79ff;
      --accent4: #ffd84a;
      --accent5: #ff7ad2;
    }
    body {
      font-family: "Courier New", monospace;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      font-size: 13px;
      line-height: 1.65;
      letter-spacing: 0.02em;
      scrollbar-width: none;
      scrollbar-color: transparent transparent;
    }
    body::-webkit-scrollbar { width: 0; height: 0; }
    .topbar {
      height: 48px;
      border-bottom: 1px solid var(--edge);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 14px;
      background: var(--pane);
    }
    .brand {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      letter-spacing: 0.22em;
    }
    .brand svg {
      width: 14px;
      height: 14px;
      border: 1px solid var(--edge);
<<<<<<< ours
      background: rgba(255,255,255,0.04);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
      color: var(--text);
      font-size: 12px;
      letter-spacing: 0.18em;
    }
    .context-btn:hover {
      border-color: var(--dim);
      background: rgba(255,255,255,0.08);
    }
    .context-btn svg {
      width: 20px;
      height: 24px;
=======
>>>>>>> theirs
      fill: none;
      stroke: var(--dim);
    }
    .brand-version {
      font-size: 10px;
      letter-spacing: 0.16em;
      color: var(--dim);
    }
    .top-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .key-input {
      background: transparent;
      border: 1px solid var(--edge);
      color: var(--dim);
      font-size: 11px;
      letter-spacing: 0.16em;
      padding: 6px 8px;
      width: 160px;
    }
    .key-input:focus {
      outline: none;
      border-color: var(--dim);
      color: var(--text);
    }
    .menu-btn {
      background: none;
      border: 1px solid var(--edge);
      color: var(--dim);
      font-size: 11px;
      letter-spacing: 0.24em;
      padding: 6px 8px;
      cursor: pointer;
    }
    .menu-btn:hover { color: var(--text); border-color: var(--dim); }
    .menu-panel {
      position: fixed;
      top: 48px;
      right: -220px;
      width: 220px;
      height: calc(100vh - 48px);
      background: var(--pane);
      border-left: 1px solid var(--edge);
      transition: right 0.3s ease;
      display: flex;
      flex-direction: column;
      z-index: 20;
    }
    .menu-panel.active { right: 0; }
    .menu-section {
      padding: 18px;
      border-bottom: 1px solid var(--edge);
      display: grid;
      gap: 10px;
    }
    .menu-label {
      font-size: 10px;
      letter-spacing: 0.18em;
      color: var(--dim);
    }
    .menu-action {
      background: var(--bg);
      border: 1px solid var(--edge);
      color: var(--dim);
      padding: 10px;
      font-size: 10px;
      letter-spacing: 0.16em;
      cursor: pointer;
      text-align: left;
    }
    .menu-action:hover { color: var(--text); border-color: var(--dim); }
    .log-view {
      flex: 1;
      overflow-y: auto;
      padding: 18px;
      display: grid;
      gap: 12px;
    }
    .log-item {
      border: 1px solid var(--edge);
      padding: 10px;
      background: #070707;
      font-size: 10px;
      line-height: 1.5;
    }
    .transclusion {
      color: var(--dim);
      font-size: 9px;
      margin-top: 6px;
    }
    .main {
      position: relative;
      height: calc(100vh - 48px);
      display: flex;
      overflow: hidden;
    }
    .column-nav {
      position: absolute;
      top: 0;
      left: 108px;
      right: 0;
      height: 42px;
      padding: 0 24px;
      display: flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(180deg, rgba(10,10,10,0.95), rgba(10,10,10,0));
      z-index: 5;
      pointer-events: none;
    }
    .column-nav-inner {
      display: flex;
      gap: 10px;
      pointer-events: auto;
    }
    .column-nav-dot {
      min-width: 28px;
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid var(--edge);
      background: rgba(255,255,255,0.04);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      letter-spacing: 0.12em;
      color: var(--text);
      cursor: pointer;
      opacity: 0.72;
      transition: transform 0.2s ease, opacity 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }
    .column-nav-dot:hover,
    .column-nav-dot.active {
      opacity: 1;
      transform: translateY(-1px);
      border-color: var(--dot-color, var(--accent1));
      background: rgba(255,255,255,0.08);
    }
    .graph-bar {
      width: 108px;
      border-right: 1px solid var(--edge);
      background: #080808;
      padding: 58px 10px 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
      -webkit-overflow-scrolling: touch;
      flex-shrink: 0;
    }
    .scroll {
      flex: 1;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      padding-top: 42px;
    }
    .column {
      width: min(420px, 92vw);
      min-width: min(360px, 88vw);
      height: 100%;
      border-right: 1px solid var(--edge);
      background: var(--bg);
      display: flex;
      flex-direction: column;
      position: relative;
      transition: width 0.3s ease;
    }
    .column.collapsed {
      width: 44px;
      min-width: 44px;
    }
    .column-tab {
      position: absolute;
      inset: 0;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: 0.24em;
      font-size: 11px;
      color: var(--dim);
      background: var(--pane);
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .column.collapsed .column-tab { opacity: 1; pointer-events: auto; }
    .column-header {
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 18px;
      border-bottom: 1px solid var(--edge);
      background: var(--pane);
    }
    .column.collapsed .column-header {
      opacity: 0;
      pointer-events: none;
    }
    .column-title {
      font-size: 11px;
      letter-spacing: 0.22em;
      color: var(--dim);
    }
    .marker {
      width: 8px;
      height: 8px;
      border: 1px solid var(--edge);
    }
    .collapse-hint {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid var(--edge);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: var(--edge);
      cursor: pointer;
      background: var(--bg);
      transition: border-color 0.2s ease, color 0.2s ease;
    }
    .collapse-hint:hover { color: var(--text); border-color: var(--dim); }
    .column.collapsed .collapse-hint { display: none; }
    .chat-shell {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg);
      min-height: 0;
    }
    .column.collapsed .chat-shell {
      opacity: 0;
      pointer-events: none;
    }
    .messages {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      padding: 26px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      -webkit-overflow-scrolling: touch;
    }
    .messages::-webkit-scrollbar { width: 4px; }
    .messages::-webkit-scrollbar-thumb { background: var(--edge); }
    .bubble {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 6px 0;
      --bubble-accent: var(--edge);
    }
    .bubble::before {
      content: "";
      position: absolute;
      top: 50%;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid var(--edge);
      background: rgba(255,255,255,0.06);
      transform: translateY(-50%);
      transition: transform 0.2s ease, opacity 0.2s ease;
    }
    .bubble::before {
      left: -18px;
      background: var(--bubble-accent);
      opacity: 0.45;
    }
    .bubble.assistant::before { opacity: 0.75; }
    .bubble.focus::before {
      transform: translateY(-50%) scale(1.28);
      box-shadow: 0 0 12px var(--bubble-accent);
      opacity: 1;
    }
    .bubble-label {
      font-size: 9px;
      letter-spacing: 0.18em;
      color: var(--dim);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .bubble-tag {
      border: 1px solid var(--bubble-accent, var(--edge));
      color: var(--bubble-accent, var(--dim));
      padding: 2px 6px;
      font-size: 8px;
      letter-spacing: 0.18em;
      border-radius: 999px;
      text-transform: uppercase;
      background: rgba(255,255,255,0.03);
    }
    .bubble.transclude .bubble-content {
      border-left-color: var(--bubble-accent);
      background: rgba(255,255,255,0.03);
    }
    .bubble.transclude .bubble-label {
      color: var(--bubble-accent);
    }
    .bubble.handoff .bubble-content {
      border-left-style: dashed;
    }
    .bubble.transclude::before {
      opacity: 0.9;
    }
    .bubble-content {
      background: var(--pane);
      border-left: 2px solid var(--edge);
      padding: 12px 16px;
      line-height: 1.6;
      color: var(--text);
      position: relative;
      cursor: default;
      transition: background 0.2s, padding 0.2s;
      word-break: break-word;
    }
    .bubble.user .bubble-content {
      color: #bfc0c0;
      border-left-color: var(--dim);
    }
    .bubble.system .bubble-content {
      color: var(--dim);
      background: #070707;
    }
    .bubble.assistant .bubble-content { cursor: pointer; }
    .bubble.assistant .bubble-content:hover {
      background: #111;
      padding-left: 20px;
    }
    .bubble.focus .bubble-content {
      box-shadow: 0 0 0 1px var(--bubble-accent, var(--edge)), 0 0 18px rgba(0,0,0,0.4);
    }
    .hint {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 8px;
      letter-spacing: 0.18em;
      color: var(--dim);
      background: var(--bg);
      padding: 3px 6px;
      border: 1px solid var(--edge);
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .bubble.assistant .bubble-content:hover .hint { opacity: 1; }
    .send-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--pane);
      border: 1px solid var(--edge);
      display: none;
      flex-direction: column;
      margin-top: 4px;
      z-index: 15;
    }
    .send-menu.active { display: flex; }
    .send-option {
      padding: 9px 14px;
      font-size: 10px;
      letter-spacing: 0.16em;
      color: var(--dim);
      cursor: pointer;
      border-bottom: 1px solid var(--edge);
    }
    .send-option:last-child { border-bottom: none; }
    .send-option:hover {
      background: #121212;
      color: var(--text);
    }
    .typing {
      display: none;
      padding: 12px 16px;
      border-left: 2px solid var(--edge);
      background: var(--pane);
      color: var(--dim);
      font-size: 11px;
      animation: pulse 1s infinite ease-in-out;
    }
    .typing.active { display: block; }
    .input-area {
      border-top: 1px solid var(--edge);
      padding: 12px 16px;
      background: var(--pane);
    }
    .input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      min-height: 0;
    }
    textarea {
      flex: 1;
      background: #060606;
      border: 1px solid var(--edge);
      color: var(--text);
      padding: 10px 12px;
      font-family: inherit;
      font-size: 11px;
      line-height: 1.6;
      min-height: 44px;
      max-height: 120px;
      resize: none;
    }
    textarea:focus { outline: none; border-color: var(--dim); }
    .send-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.4);
      background: var(--accent, #d70000);
      color: #111;
      font-size: 18px;
      letter-spacing: 0.12em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.6);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }
    .send-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.7);
    }
    .send-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .scratch-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid var(--edge);
      background: #060606;
      color: var(--dim);
      font-size: 9px;
      letter-spacing: 0.12em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .scratch-btn:hover {
      color: var(--text);
      border-color: var(--dim);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.4);
    }
    .scratchpad-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 80;
      padding: 24px;
    }
    .scratchpad-overlay.active { display: flex; }
    .scratchpad-card {
      width: min(520px, 92vw);
      background: var(--pane);
      border: 1px solid var(--edge);
      box-shadow: 0 18px 48px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 18px;
    }
    .scratchpad-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      letter-spacing: 0.18em;
      color: var(--dim);
    }
    .scratchpad-close {
      background: none;
      border: 1px solid var(--edge);
      color: var(--dim);
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
    }
    .scratchpad-close:hover { color: var(--text); border-color: var(--dim); }
    #scratchpadInput {
      background: #060606;
      border: 1px solid var(--edge);
      color: var(--text);
      padding: 10px 12px;
      font-family: inherit;
      font-size: 11px;
      line-height: 1.6;
      min-height: 160px;
      max-height: 320px;
      resize: vertical;
    }
    #scratchpadInput:focus { outline: none; border-color: var(--dim); }
    .scratchpad-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .scratchpad-actions button {
      flex: 1;
      min-width: 160px;
      background: var(--bg);
      border: 1px solid var(--edge);
      color: var(--dim);
      font-size: 10px;
      letter-spacing: 0.16em;
      padding: 10px 12px;
      cursor: pointer;
      text-transform: uppercase;
    }
    .scratchpad-actions button:hover { color: var(--text); border-color: var(--dim); }
    .scratchpad-meta {
      font-size: 9px;
      letter-spacing: 0.14em;
      color: var(--dim);
      text-transform: uppercase;
    }
    .graph-bar {
      align-items: center;
    }
    .graph-node {
      position: relative;
      padding-left: 0;
      font-size: 9px;
      letter-spacing: 0.12em;
      color: var(--dim);
      line-height: 1.4;
      white-space: normal;
      word-break: break-word;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      min-height: 42px;
    }
    .graph-node::before {
      content: "";
      position: absolute;
<<<<<<< ours
<<<<<<< ours
<<<<<<< ours
<<<<<<< ours
<<<<<<< ours
<<<<<<< ours
      left: 30px;
=======
      left: 16px;
>>>>>>> theirs
=======
      left: 26px;
>>>>>>> theirs
=======
      left: 26px;
>>>>>>> theirs
      top: 0;
      bottom: calc(50% + 12px);
      width: 1px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0));
    }
    .graph-node::after {
      content: "";
      position: absolute;
<<<<<<< ours
<<<<<<< ours
<<<<<<< ours
      left: 30px;
=======
      left: 16px;
>>>>>>> theirs
=======
      left: 26px;
>>>>>>> theirs
=======
      left: 26px;
>>>>>>> theirs
      top: calc(50% + 12px);
      bottom: 0;
      width: 1px;
=======
      left: 50%;
      top: 0;
      bottom: calc(50% + 12px);
      width: 1px;
      transform: translateX(-50%);
>>>>>>> theirs
=======
      left: 32px;
      top: -20px;
      bottom: calc(50% + 16px);
      width: 2px;
>>>>>>> theirs
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0));
=======
      left: 50%;
      transform: translateX(-50%);
      top: -16px;
      bottom: calc(50% + 10px);
      width: 2px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0));
>>>>>>> theirs
    }
    .graph-node:first-child::before { display: none; }
    .graph-node:last-child::before { bottom: 10px; }
    .graph-dot {
<<<<<<< ours
<<<<<<< ours
<<<<<<< ours
      position: absolute;
<<<<<<< ours
<<<<<<< ours
<<<<<<< ours
      left: 30px;
      top: 50%;
      transform: translate(-50%, -50%);
      min-width: 36px;
      height: 24px;
      padding: 0 6px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.65);
=======
      left: 16px;
=======
      left: 26px;
>>>>>>> theirs
=======
      left: 26px;
>>>>>>> theirs
      top: 50%;
      transform: translate(-50%, -50%);
=======
>>>>>>> theirs
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.6);
>>>>>>> theirs
=======
      position: absolute;
      left: 32px;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(0,0,0,0.6);
>>>>>>> theirs
=======
      position: relative;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid var(--edge);
>>>>>>> theirs
      background: var(--dot, #ff5050);
      box-shadow: 0 0 6px var(--dot, #ff5050);
    }
    .graph-node:hover .graph-dot {
      box-shadow: 0 0 14px var(--dot, #ff5050);
    }
    .graph-node-trans .graph-dot {
      border-style: dashed;
    }
    .graph-text {
      font-size: 9px;
      letter-spacing: 0.12em;
      color: var(--dim);
      text-transform: uppercase;
    }
    .context-card {
      margin-top: 24px;
      border: 1px solid var(--edge);
      background: rgba(255,255,255,0.02);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .context-card-title {
      font-size: 9px;
      letter-spacing: 0.16em;
      color: var(--dim);
      text-transform: uppercase;
    }
    .context-card-entry {
      border-left: 2px solid var(--entry-color, var(--edge));
      padding-left: 8px;
      font-size: 9px;
      letter-spacing: 0.08em;
      color: var(--text);
      cursor: pointer;
      background: rgba(0,0,0,0.2);
      transition: background 0.2s ease, color 0.2s ease;
    }
    .context-card-entry:hover {
      background: rgba(255,255,255,0.06);
      color: var(--entry-color, var(--accent2));
    }
    .graph-empty {
      font-size: 9px;
      color: var(--dim);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }
    .travel {
      position: fixed;
      pointer-events: none;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text);
      opacity: 0;
      z-index: 50;
      transition: all 0.8s ease-in-out;
    }
    @media (max-width: 900px) {
      .main {
        flex-direction: column;
      }
      .graph-bar {
<<<<<<< ours
<<<<<<< ours
        width: 84px;
        padding: 32px 8px 12px;
      }
      .graph-node {
        padding: 12px 0 12px 42px;
=======
=======
>>>>>>> theirs
        width: 100%;
        height: 120px;
        border-right: none;
        border-bottom: 1px solid var(--edge);
        padding: 54px 16px 16px;
        flex-direction: row;
        gap: 20px;
        overflow-x: auto;
      }
      .graph-bar::-webkit-scrollbar {
        height: 4px;
      }
      .graph-bar::-webkit-scrollbar-thumb {
        background: var(--edge);
      }
      .graph-node {
<<<<<<< ours
        padding: 12px 16px 12px 52px;
        min-width: 180px;
<<<<<<< ours
>>>>>>> theirs
=======
>>>>>>> theirs
=======
        min-height: 0;
<<<<<<< ours
        padding-left: 0;
        min-width: 120px;
>>>>>>> theirs
=======
>>>>>>> theirs
      }
      .graph-node::before {
        display: none;
      }
<<<<<<< ours
      .graph-dot {
<<<<<<< ours
        left: 22px;
<<<<<<< ours
<<<<<<< ours
=======
        top: 20px;
        transform: none;
>>>>>>> theirs
      }
      .graph-node-label {
        text-align: left;
      }
      .timeline-detail {
        display: none !important;
=======
        top: 20px;
=======
        position: static;
>>>>>>> theirs
        transform: none;
        margin-bottom: 4px;
      }
<<<<<<< ours
      .graph-node-label {
        text-align: left;
>>>>>>> theirs
=======
      .graph-body {
        align-items: flex-start;
>>>>>>> theirs
      }
=======
>>>>>>> theirs
      .column-nav {
        left: 0;
        right: 0;
        padding: 0 16px;
      }
      .scroll {
        padding-top: 60px;
      }
      .column {
        width: 100%;
        min-width: 100%;
      }
    }
    @media (max-width: 600px) {
      body {
        font-size: 12px;
      }
      .messages {
        padding: 20px;
      }
      .send-btn,
      .scratch-btn {
        width: 38px;
        height: 38px;
      }
    .column-nav-dot {
      min-width: 24px;
      font-size: 9px;
      padding: 4px 6px;
    }
    }
    .initial-options {
      display: grid;
      gap: 10px;
    }
    .option-btn {
      background: transparent;
      border: 1px solid var(--edge);
      color: var(--dim);
      padding: 12px 14px;
      text-align: left;
      font-size: 11px;
      letter-spacing: 0.08em;
      cursor: pointer;
    }
    .option-btn:hover {
      background: #111;
      color: var(--text);
      border-color: var(--dim);
    }
    .fold {
      border: 1px solid var(--edge);
      background: #080808;
      padding: 0;
      margin: 0;
    }
    .fold summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      letter-spacing: 0.14em;
      color: var(--dim);
      outline: none;
    }
    .fold summary::-webkit-details-marker { display: none; }
    .fold-body {
      padding: 12px;
      border-top: 1px solid var(--edge);
      color: var(--text);
      letter-spacing: 0.04em;
    }
    @media (max-width: 768px) {
      body { font-size: 12px; }
      .top-controls { gap: 6px; }
      .key-input { width: 130px; }
      .menu-panel { width: 200px; right: -200px; }
      .menu-panel.active { right: 0; }
    }
    @keyframes pulse {
      0% { opacity: 0.2; }
      50% { opacity: 1; }
      100% { opacity: 0.2; }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <svg viewBox="0 0 10 10" aria-hidden="true">
        <path d="M1 1h8v8H1z" stroke-width="0.8"/>
        <path d="M1 5h8" stroke-width="0.6"/>
        <path d="M5 1v8" stroke-width="0.6"/>
      </svg>
      <span>PCL CONTROL</span>
      <span id="versionTag" class="brand-version">v0</span>
    </div>
    <div class="top-controls">
      <input type="password" id="apiKeyInput" class="key-input" placeholder="API KEY" autocomplete="off">
      <button class="menu-btn" id="menuBtn">::</button>
    </div>
  </header>

  <aside class="menu-panel" id="menuPanel">
    <div class="menu-section">
      <div class="menu-label">ACTIONS</div>
      <button class="menu-action" data-action="auto">AUTO CHAIN</button>
      <button class="menu-action" data-action="sequence">SEQUENCE</button>
      <button class="menu-action" data-action="export">EXPORT LOG</button>
      <button class="menu-action" data-action="import">IMPORT LOG</button>
      <button class="menu-action" data-action="context">COPY CONTEXT</button>
      <button class="menu-action" data-action="clear">CLEAR LOG</button>
    </div>
    <div class="menu-section">
      <div class="menu-label">TRANSCLUSION INDEX</div>
      <div class="log-view" id="transclusionView"></div>
    </div>
    <div class="menu-section" style="border-bottom:none;">
      <div class="menu-label">EVENT LOG</div>
      <div class="log-view" id="logView"></div>
    </div>
  </aside>

  <main class="main">
    <div class="column-nav" id="columnNav">
      <div class="column-nav-inner"></div>
    </div>
    <aside class="graph-bar" id="graphBar"></aside>
    <div class="scroll" id="scrollContainer">
      <div class="column" data-type="pragmatic">
        <div class="column-tab">TTL ROOT</div>
        <div class="column-header">
          <div class="column-title">TTL ROOT</div>
          <div class="marker" style="border-color: var(--accent1);"></div>
        </div>
        <div class="collapse-hint">•</div>
        <div class="chat-shell">
          <div class="messages">
            <div class="bubble system">
              <div class="bubble-label">SYSTEM</div>
              <div class="bubble-content">Set guardrails, metrics, and probe -> measure -> revise cadence before chaining.</div>
            </div>
            <div class="initial-options"></div>
          </div>
          <div class="typing"></div>
          <div class="input-area">
            <div class="input-wrapper">
              <textarea placeholder="Seed the governance loop..."></textarea>
              <button class="send-btn">></button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <div class="travel" id="travelIndicator"></div>
  <input type="file" id="logLoader" hidden>

  <!-- POML prompts -->
  <script type="application/poml" id="tpl-pragmatic">
<poml version="2.0">
  <meta minVersion="1.1.0" />
  <context>
    <domain>Operational philosophy for GenAI prompt craft</domain>
    <audience>Prompt engineers maintaining Prompt Composer control surfaces</audience>
    <aesthetic>Bauhaus terminal; manila grid; oxide red type</aesthetic>
    <pragmatic_descent>Probe -> measure -> revise loop governs deployment</pragmatic_descent>
  </context>
  <role>Doctrine Module -- Pragmatic Descent for GenAI</role>
  <constraints>
    - ASCII only
    - Surface probe -> measure -> revise checkpoints
    - Output: doctrine summary, toolkit, loop checklist
  </constraints>
  <task>Summarize governance stance: metrics, guardrails, iteration cadence.</task>
</poml>
  </script>

  <script type="application/poml" id="tpl-parrhesia">
<poml version="2.0">
  <meta minVersion="1.1.0" />
  <context>
    <domain>Parrhesia reframing</domain>
    <audience>Speech-act analysts</audience>
    <aesthetic>Terminal glyph grid; oxide red rails</aesthetic>
  </context>
  <role>INCEPTOR -- Parrhesia Converter</role>
  <constraints>
    - Accept references list
    - Emit olog with entities, morphisms, high-risk speech-act
  </constraints>
  <task>Map input references to parrhesia schema; extract explicit courageous utterance.</task>
</poml>
  </script>

  <script type="application/poml" id="tpl-composer">
<poml version="2.0">
  <meta minVersion="1.1.0" />
  <context>
    <domain>Prompt Composer Core</domain>
    <audience>Catalog strategists</audience>
  </context>
  <role>INCEPTOR -- Prompt Composer</role>
  <constraints>
    - Output LATENT_GENOME YAML
    - Emit inflator prompt with quickcheck
  </constraints>
  <task>Compress topic into genome seed and inflator instructions.</task>
</poml>
  </script>

  <script type="application/poml" id="tpl-lineage">
<poml version="2.0">
  <meta minVersion="1.1.0" />
  <context>
    <domain>Lineage jukebox synthesis</domain>
    <audience>Sound designers</audience>
  </context>
  <role>INCEPTOR -- Lineage Encoder</role>
  <constraints>
    - YAML schema only
    - Single AI-ECHO block
  </constraints>
  <task>Trace caretakers, epochs, palette; output lineage genome and AI-ECHO prompt.</task>
</poml>
  </script>

  <script type="application/poml" id="tpl-godlevel">
<poml version="2.0">
  <meta minVersion="1.1.0" />
  <context>
    <domain>Recursive toy quine</domain>
    <audience>Game operators</audience>
  </context>
  <role>INCEPTOR -- GODLEVEL Game Master</role>
  <constraints>
    - Emit CONFIG_GENOME JSON summary
    - Emit ENGINE_POML snippet
    - Emit INDEX.html single file spec outline
  </constraints>
  <task>Transmute topic into one-shot HTML toy with scoring rubric and ttl guard.</task>
</poml>
  </script>

  <script>
    const PIPELINE = ["pragmatic", "parrhesia", "composer", "lineage", "godlevel"];
    const COLORS = {
      pragmatic: "--accent1",
      parrhesia: "--accent2",
      composer: "--accent3",
      lineage: "--accent4",
      godlevel: "--accent5"
    };
    function accentColor(type) {
      const varName = COLORS[type];
      if (!varName) return "#d70000";
      const value = getComputedStyle(document.documentElement).getPropertyValue(varName);
      return value ? value.trim() : "#d70000";
    }

<<<<<<< ours
    function ensureSequence(type) {
      if (!type) return;
      if (!state.sequence[type] || state.sequence[type] < 1) {
        state.sequence[type] = 1;
      }
    }

    function updateSendLabel(type) {
      ensureSequence(type);
      const column = document.querySelector(`.column[data-type="${type}"]`);
      if (!column) return;
      const sendBtn = column.querySelector(".send-btn");
      if (!sendBtn) return;
      const seq = state.sequence[type];
      sendBtn.textContent = `SEND #${seq}`;
      sendBtn.style.background = accentColor(type);
      sendBtn.style.borderColor = accentColor(type);
      sendBtn.style.boxShadow = "0 0 0 2px rgba(0,0,0,0.6)";
    }

    function setActiveColumn(type, preserveActiveLog = false) {
      if (!type) return;
      state.activeColumn = type;
      if (!preserveActiveLog) state.activeLogId = null;
      const chainName = document.getElementById("chainName");
      if (chainName) {
        const agent = AGENTS[type];
        chainName.textContent = agent ? agent.name : type.toUpperCase();
      }
      updateSendLabel(type);
=======
    function setActiveColumn(type) {
      if (!type) return;
      state.activeColumn = type;
>>>>>>> theirs
      updateColumnNav();
      renderGraph();
    }

    function updateColumnNav() {
      const nav = document.getElementById("columnNav");
      if (!nav) return;
      const inner = nav.querySelector(".column-nav-inner");
      if (!inner) return;
      inner.innerHTML = "";
      state.columns.forEach((type, index) => {
        const dot = document.createElement("button");
        dot.className = "column-nav-dot";
        dot.textContent = index + 1;
        dot.style.setProperty("--dot-color", accentColor(type));
        dot.title = AGENTS[type] ? AGENTS[type].name : type.toUpperCase();
        if (type === state.activeColumn) dot.classList.add("active");
        dot.addEventListener("click", () => focusColumn(type));
        inner.appendChild(dot);
      });
      nav.style.display = state.columns.length ? "flex" : "none";
    }

    function focusColumn(type, preserveActiveLog = false) {
      const column = document.querySelector(`.column[data-type="${type}"]`);
      if (!column) return;
      column.classList.remove("collapsed");
      const container = document.getElementById("scrollContainer");
      if (container) {
        const offsetLeft = column.offsetLeft;
        container.scrollTo({ left: Math.max(0, offsetLeft - 20), behavior: "smooth" });
      }
      setActiveColumn(type, preserveActiveLog);
    }

    function attachLogReference(entry, type, bubble) {
      if (!entry || !bubble) return;
      bubble.dataset.logId = entry.id;
      state.logRefs.set(entry.id, { column: type, element: bubble, detail: buildLogDetail(entry) });
    }

    function focusLog(id) {
      const ref = state.logRefs.get(id);
      if (!ref) return;
      state.activeLogId = id;
      focusColumn(ref.column, true);
      const el = ref.element;
      if (el && el.isConnected) {
        const messages = el.closest(".messages");
        if (messages) {
          const target = el.offsetTop - messages.clientHeight / 2 + el.clientHeight;
          messages.scrollTo({ top: Math.max(0, target), behavior: "smooth" });
        } else {
          el.scrollIntoView({ behavior: "smooth", block: "center" });
        }
        el.classList.add("focus");
        setTimeout(() => el.classList.remove("focus"), 1500);
      }
      const timelineNumber = state.timelineIndexById[id];
      let detail = ref.detail ? { ...ref.detail } : null;
      if (detail && typeof timelineNumber !== "undefined") detail.number = timelineNumber;
      if (!detail && typeof timelineNumber !== "undefined") detail = state.timelineData[timelineNumber];
      if (!detail) {
        const entry = state.logs.find(item => item.id === id);
        detail = buildLogDetail(entry, timelineNumber);
      }
      if (detail) showTimelineDetail(detail);
    }

<<<<<<< ours
    function getTimelineDetail() {
      if (!state.timelineDetail) state.timelineDetail = document.getElementById("timelineDetail");
      return state.timelineDetail;
    }

    function hideTimelineDetail() {
      const panel = getTimelineDetail();
      if (!panel) return;
      panel.classList.remove("active");
      panel.setAttribute("hidden", "hidden");
      panel.innerHTML = "";
    }

    function showTimelineDetail(data) {
      if (!data || window.innerWidth <= 900) return;
      const panel = getTimelineDetail();
      if (!panel) return;
      const number = escapeHTML(String(data.number || ""));
      const headline = escapeHTML(data.primary || "");
      const meta = escapeHTML(data.secondary || "");
      const body = escapeHTML(data.body || "");
      panel.innerHTML = 
        `<header>
          <div class="timeline-detail-title">#${number}</div>
          <button type="button" class="timeline-detail-close" aria-label="Close timeline detail">x</button>
        </header>
        <div class="timeline-detail-meta">${headline}${meta ? ' - ' + meta : ''}</div>
        <div class="timeline-detail-body">${body || '(empty)'}</div>`;
      panel.classList.add("active");
      panel.removeAttribute("hidden");
      const closeBtn = panel.querySelector(".timeline-detail-close");
      if (closeBtn) closeBtn.addEventListener("click", hideTimelineDetail, { once: true });
    }

    function buildLogDetail(entry, numberOverride) {
      if (!entry) return null;
      const header = entry.role === "transclude"
        ? `${entry.from.toUpperCase()} -> ${entry.to.toUpperCase()}`
        : `${entry.agent.toUpperCase()} - ${entry.role.toUpperCase()}`;
      const textSnippet = (entry.content || "").replace(/\s+/g, " ").trim();
      const secondary = textSnippet.length > 90 ? textSnippet.slice(0, 87) + "..." : textSnippet || "(empty)";
      return {
        number: typeof numberOverride === "number" ? numberOverride : entry.id,
        primary: header,
        secondary,
        body: entry.content || ""
      };
    }

    function configureTimelineDetail() {
      const panel = getTimelineDetail();
      if (!panel) return;
      panel.addEventListener("click", e => {
        if (e.target === panel) hideTimelineDetail();
      });
    }

    function getTimelineDetail() {
      if (!state.timelineDetail) state.timelineDetail = document.getElementById("timelineDetail");
      return state.timelineDetail;
    }

    function hideTimelineDetail() {
      const panel = getTimelineDetail();
      if (!panel) return;
      panel.classList.remove("active");
      panel.setAttribute("hidden", "hidden");
      panel.innerHTML = "";
    }

    function showTimelineDetail(data) {
      if (!data || window.innerWidth <= 900) return;
      const panel = getTimelineDetail();
      if (!panel) return;
      const number = escapeHTML(String(data.number || ""));
      const headline = escapeHTML(data.primary || "");
      const meta = escapeHTML(data.secondary || "");
      const body = escapeHTML(data.body || "");
      panel.innerHTML = \`<header>
        <div class="timeline-detail-title">#${number}</div>
        <button type="button" class="timeline-detail-close" aria-label="Close timeline detail">x</button>
      </header>
      <div class="timeline-detail-meta">${headline}${meta ? ' - ' + meta : ''}</div>
      <div class="timeline-detail-body">${body || '(empty)'}</div>
      \`;
      panel.classList.add("active");
      panel.removeAttribute("hidden");
      const closeBtn = panel.querySelector(".timeline-detail-close");
      if (closeBtn) closeBtn.addEventListener("click", hideTimelineDetail, { once: true });
    }


=======
>>>>>>> theirs
    function ensureScratchpad() {
      let overlay = document.getElementById("scratchpadOverlay");
      if (overlay) return overlay;
      overlay = document.createElement("div");
      overlay.id = "scratchpadOverlay";
      overlay.className = "scratchpad-overlay";
      overlay.innerHTML = `
        <div class="scratchpad-card">
          <div class="scratchpad-header">
            <span>Shared Scratchpad</span>
            <button type="button" class="scratchpad-close" aria-label="Close scratchpad">X</button>
          </div>
          <textarea id="scratchpadInput" placeholder="Add shared notes for all agents..."></textarea>
          <div class="scratchpad-actions">
            <button type="button" class="scratchpad-insert">Insert into active chat</button>
            <button type="button" class="scratchpad-save">Save & Close</button>
          </div>
          <div class="scratchpad-meta" id="scratchpadMeta"></div>
        </div>`;
      document.body.appendChild(overlay);
      overlay.addEventListener("click", e => {
        if (e.target === overlay) closeScratchpad();
      });
      overlay.querySelector(".scratchpad-close").addEventListener("click", closeScratchpad);
      const input = overlay.querySelector("#scratchpadInput");
      input.addEventListener("input", e => {
        state.scratchpad = e.target.value;
        localStorage.setItem("pcl_scratchpad", state.scratchpad);
        updateScratchpadMeta();
        renderGraph();
      });
      overlay.querySelector(".scratchpad-save").addEventListener("click", () => {
        closeScratchpad();
      });
      overlay.querySelector(".scratchpad-insert").addEventListener("click", () => {
        insertScratchpad();
      });
      updateScratchpadMeta();
      return overlay;
    }

    function openScratchpad(type) {
      const overlay = ensureScratchpad();
      const input = overlay.querySelector("#scratchpadInput");
      input.value = state.scratchpad || "";
      state.scratchpadTarget = type;
      updateScratchpadMeta();
      overlay.classList.add("active");
      setTimeout(() => input.focus(), 50);
    }

    function closeScratchpad() {
      const overlay = document.getElementById("scratchpadOverlay");
      if (!overlay) return;
      overlay.classList.remove("active");
      state.scratchpadTarget = null;
    }

    function insertScratchpad() {
      if (!state.scratchpadTarget) return;
      const column = document.querySelector(`.column[data-type="${state.scratchpadTarget}"]`);
      if (!column) return;
      const textarea = column.querySelector("textarea");
      if (!textarea) return;
      const fragment = (state.scratchpad || "").trim();
      if (!fragment) return;
      const existing = textarea.value.trim();
      textarea.value = existing ? `${existing}\n\n${fragment}` : fragment;
      textarea.dispatchEvent(new Event("input", { bubbles: true }));
      textarea.focus();
      textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
      closeScratchpad();
    }

    function updateScratchpadMeta() {
      const meta = document.getElementById("scratchpadMeta");
      if (!meta) return;
      const chars = state.scratchpad ? state.scratchpad.length : 0;
      const lines = state.scratchpad ? state.scratchpad.split(/\r?\n/) : [];
      const agent = state.scratchpadTarget ? AGENTS[state.scratchpadTarget] : null;
      const target = agent ? agent.name : "None";
      meta.textContent = `chars ${chars} | lines ${lines.length} | target ${target}`;
    }

    const AGENTS = {
      pragmatic: {
        name: "TTL ROOT",
        placeholder: "Seed the governance loop...",
        options: [
          "FOCUS: evaluation harness refresh",
          "Document guardrails + thresholds",
          "Probe -> measure -> revise cadence",
          "Log criteria before child prompts"
        ],
        promptId: "tpl-pragmatic"
      },
      parrhesia: {
        name: "PARRHESIA",
        placeholder: "Map courageous truth-act...",
        options: [
          "Inject reference: hidden outage truth",
          "Extract high-risk speech-act",
          "List morphisms: power, risk, courage",
          "Check probe -> measure -> revise slots"
        ],
        promptId: "tpl-parrhesia"
      },
      composer: {
        name: "COMPOSER",
        placeholder: "Compress topic into genome...",
        options: [
          "Seed: rust belt neon vs algorithm",
          "Compose five-whys chain",
          "Request LATENT_GENOME YAML",
          "Check quickcheck bullets"
        ],
        promptId: "tpl-composer"
      },
      lineage: {
        name: "LINEAGE",
        placeholder: "Trace sonic lineage...",
        options: [
          "Caretakers + rituals",
          "Epochs with influence weights",
          "Signature palette + bpm range",
          "AI-ECHO delivery line"
        ],
        promptId: "tpl-lineage"
      },
      godlevel: {
        name: "GODLEVEL",
        placeholder: "Spin one-shot toy...",
        options: [
          "Topic: filters vs mixtapes",
          "Archetype: gardener, mood: resolve",
          "Flow + joy + balance scoring",
          "Single-file HTML outline"
        ],
        promptId: "tpl-godlevel"
      }
    };

    const state = {
      columns: ["pragmatic"],
      history: { pragmatic: [] },
      logs: [],
      counter: 0,
      menuOpen: false,
      apiKey: "",
      model: "gpt-4o-mini",
      version: 0,
      logRefs: new Map(),
      scratchpad: "",
      activeColumn: "pragmatic",
<<<<<<< ours
      scratchpadTarget: null,
      timelineDetail: null,
      timelineData: {},
      timelineIndexById: {},
      activeLogId: null
=======
      scratchpadTarget: null
>>>>>>> theirs
    };

    function escapeHTML(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function formatText(text = "") {
      let html = escapeHTML(text).replace(/\r\n/g, "\n");
      html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
      html = html.replace(/\*(?!\s)([^*]+?)\*/g, "<em>$1</em>");
      html = html.replace(/`([^`]+)`/g, "<code>$1</code>");
      html = html.replace(/\n- /g, "<br>&bull; ");
      html = html.replace(/\n/g, "<br>");
      return html;
    }

    function shouldFold(text) {
      if (!text) return false;
      const longByChars = text.length > 320;
      const longByLines = text.split(/\r?\n/).length > 6;
      return longByChars || longByLines;
    }

    function getPrompt(id) {
      const node = document.getElementById(id);
      return node ? node.textContent.trim() : "";
    }

    function init() {
      const menuBtn = document.getElementById("menuBtn");
      const keyInput = document.getElementById("apiKeyInput");
      if (menuBtn) menuBtn.addEventListener("click", toggleMenu);
      document.querySelectorAll(".menu-action").forEach(btn => {
        btn.addEventListener("click", handleMenuAction);
      });
      document.getElementById("logLoader").addEventListener("change", importLogs);
      const storedKey = localStorage.getItem("pcl_api_key");
      if (storedKey) {
        state.apiKey = storedKey;
        if (keyInput) keyInput.value = "********";
      }
      if (keyInput) {
        keyInput.addEventListener("change", () => {
          const value = keyInput.value.trim();
          if (!value) {
            state.apiKey = "";
            localStorage.removeItem("pcl_api_key");
      return Promise.resolve(null);
          }
          state.apiKey = value;
          localStorage.setItem("pcl_api_key", value);
          keyInput.value = "********";
        });
      }
      const storedPad = localStorage.getItem("pcl_scratchpad");
      if (storedPad) state.scratchpad = storedPad;
      initColumn("pragmatic");
      updateColumnNav();
      renderGraph();
    }

    function toggleMenu() {
      state.menuOpen = !state.menuOpen;
      document.getElementById("menuPanel").classList.toggle("active", state.menuOpen);
      if (state.menuOpen) renderLogs();
    }

    function handleMenuAction(e) {
      const action = e.target.dataset.action;
      if (action === "auto") autoChain();
      if (action === "sequence") sequenceChain();
      if (action === "export") exportLogs();
      if (action === "import") document.getElementById("logLoader").click();
      if (action === "context") copyContextSnapshot();
      if (action === "clear") clearLogs();
    }

    function initColumn(type) {
      const column = document.querySelector(`.column[data-type="${type}"]`);
      if (!column) return Promise.resolve(null);
      column.style.setProperty("--accent", accentColor(type));
      column.addEventListener("pointerdown", () => setActiveColumn(type));
      const tab = column.querySelector(".column-tab");
      const collapseHint = column.querySelector(".collapse-hint");
      const header = column.querySelector(".column-header");
      const options = column.querySelector(".initial-options");
      const textarea = column.querySelector("textarea");
      const sendBtn = column.querySelector(".send-btn");
      const marker = column.querySelector(".marker");
      if (!textarea || !sendBtn) return;
      if (marker) {
        marker.style.borderColor = accentColor(type);
        marker.style.background = accentColor(type);
      }
      sendBtn.textContent = ">";
      const accent = accentColor(type);
      sendBtn.style.background = accent;
      sendBtn.style.borderColor = accent;
      sendBtn.style.boxShadow = "0 0 0 2px " + accent + ", inset 0 0 0 1px rgba(0,0,0,0.4)";
      sendBtn.setAttribute("aria-label", "Send message");

      tab.addEventListener("click", () => {
        column.classList.toggle("collapsed");
        if (!column.classList.contains("collapsed")) setActiveColumn(type);
      });
      collapseHint.addEventListener("click", () => {
        column.classList.toggle("collapsed");
        if (!column.classList.contains("collapsed")) setActiveColumn(type);
      });
      if (header) {
        header.addEventListener("dblclick", () => {
          column.classList.toggle("collapsed");
          if (!column.classList.contains("collapsed")) setActiveColumn(type);
        });
      }

      const agent = AGENTS[type];
      if (options && agent.options) {
        agent.options.forEach(opt => {
          const btn = document.createElement("button");
          btn.className = "option-btn";
          btn.textContent = opt;
          btn.addEventListener("click", () => {
            options.remove();
            sendMessage(type, opt);
          });
          options.appendChild(btn);
        });
      }

      textarea.placeholder = agent.placeholder;
      textarea.addEventListener("input", () => {
        textarea.style.height = "auto";
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + "px";
      });
      textarea.addEventListener("keydown", e => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendBtn.click();
        }
      });
      sendBtn.addEventListener("click", () => {
        const value = textarea.value.trim();
        if (!value) return;
        const initial = column.querySelector(".initial-options");
        if (initial) initial.remove();
        sendMessage(type, value);
        textarea.value = "";
        textarea.style.height = "auto";
      });
      const wrapper = column.querySelector(".input-wrapper");
      if (wrapper && !wrapper.querySelector(".scratch-btn")) {
        const scratchBtn = document.createElement("button");
        scratchBtn.type = "button";
        scratchBtn.className = "scratch-btn";
        scratchBtn.textContent = "SP";
        scratchBtn.title = "Shared scratchpad";
        scratchBtn.addEventListener("click", () => openScratchpad(type));
        wrapper.appendChild(scratchBtn);
      }
      state.history[type] = [];
    }

    function sendMessage(type, text, fromType) {
      const column = document.querySelector(`.column[data-type="${type}"]`);
      if (!column) return;
      const messages = column.querySelector(".messages");
      const sendBtn = column.querySelector(".send-btn");
      const typing = column.querySelector(".typing");
      if (!messages || !sendBtn || !typing) return;

      setActiveColumn(type);
      const bubble = addBubble(type, "user", text, fromType);
      const logEntry = logEvent("user", type, text, fromType, null);
      attachLogReference(logEntry, type, bubble);

      sendBtn.disabled = true;
      typing.classList.add("active");
      typing.textContent = `${AGENTS[type].name} processing...`;

      const promptText = getPrompt(AGENTS[type].promptId);

      if (state.apiKey) {
        typing.textContent = `${AGENTS[type].name} contacting API...`;
        callOpenAI(promptText, text).then(response => {
          typing.classList.remove("active");
          const assistBubble = addBubble(type, "assistant", response);
          const entry = logEvent("assistant", type, response, null, type);
          attachLogReference(entry, type, assistBubble);
          sendBtn.disabled = false;
          suggestNext(type);
        }).catch(err => {
          typing.classList.remove("active");
          const errorBubble = addBubble(type, "assistant", `[error] ${err.message}`);
          const entry = logEvent("assistant", type, `[error] ${err.message}`, null, type);
          attachLogReference(entry, type, errorBubble);
          sendBtn.disabled = false;
        });
      } else {
        setTimeout(() => {
          const response = synthesize(promptText, text, type);
          typing.classList.remove("active");
          const assistBubble = addBubble(type, "assistant", response);
          const entry = logEvent("assistant", type, response, null, type);
          attachLogReference(entry, type, assistBubble);
          sendBtn.disabled = false;
          suggestNext(type);
        }, 700 + Math.random() * 800);
      }
    }

    function synthesize(prompt, userText, type) {
      const fallbacks = {
        pragmatic: "Governance stance logged. Metrics, guardrails, and cadence ready for downstream agents.",
        parrhesia: "Parrhesia map complete. High-risk speech-act and morphisms documented for reuse.",
        composer: "LATENT_GENOME + inflator prompt generated. Quickcheck satisfied.",
        lineage: "Lineage genome assembled with weighted epochs, migration, and palette.",
        godlevel: "CONFIG_GENOME, ENGINE blueprint, and HTML outline rendered. Flow score recorded."
      };
      return fallbacks[type] || "Output ready.";
    }

    async function callOpenAI(systemPrompt, userText) {
      if (!state.apiKey) throw new Error("API key missing");
      const body = {
        model: state.model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userText }
        ],
        temperature: 0.4
      };
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${state.apiKey}`
        },
        body: JSON.stringify(body)
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error(`HTTP ${response.status}: ${text}`);
      }
      const data = await response.json();
      const content = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content;
      if (!content) throw new Error("Empty response");
      return content.trim();
    }

    function addBubble(type, role, text, fromType) {
      const column = document.querySelector(`.column[data-type="${type}"]`);
      if (!column) return null;
      const messages = column.querySelector(".messages");
      if (!messages) return null;
      if (!state.history[type]) state.history[type] = [];
      const bubble = document.createElement("div");
      bubble.className = `bubble ${role}`;
      const accentOwner = role === "user" && fromType ? fromType : type;
      const accent = accentColor(accentOwner);
      bubble.style.setProperty("--bubble-accent", accent);
      if (role === "user" && fromType && fromType !== type) {
        bubble.classList.add("transclude");
      }
      bubble.dataset.origin = fromType || type;
      bubble.dataset.agent = type;

      const label = document.createElement("div");
      label.className = "bubble-label";
      if (role === "user") {
        label.textContent = fromType && fromType !== type ? "HANDOFF" : "INPUT";
        const tag = document.createElement("span");
        tag.className = "bubble-tag";
        tag.textContent = fromType && fromType !== type ? `${fromType.toUpperCase()} -> ${type.toUpperCase()}` : type.toUpperCase();
        label.appendChild(tag);
      } else if (role === "assistant") {
        label.textContent = "OUTPUT";
        const tag = document.createElement("span");
        tag.className = "bubble-tag";
        tag.textContent = type.toUpperCase();
        label.appendChild(tag);
      } else {
        label.textContent = "SYSTEM";
      }
      bubble.appendChild(label);

      const content = document.createElement("div");
      content.className = "bubble-content";
      let html = formatText(text);
      if (role === "assistant" && shouldFold(text)) {
        const summaryText = escapeHTML(text.slice(0, 160).trim()) + (text.length > 160 ? "..." : "");
        html = `<details class="fold"><summary>${summaryText}</summary><div class="fold-body">${html}</div></details>`;
      }
      content.innerHTML = html;
      if (role === "assistant") {
        const hint = document.createElement("div");
        hint.className = "hint";
        hint.textContent = "SEND ->";
        content.appendChild(hint);
        content.addEventListener("click", e => {
          if (e.target && e.target.tagName === "SUMMARY") return;
          e.stopPropagation();
          openSendMenu(content, type, text);
        });
      }
      bubble.appendChild(content);
      messages.appendChild(bubble);
      messages.scrollTop = messages.scrollHeight;
      state.history[type].push({ role, text, origin: fromType || type });
      return bubble;
    }

    function openSendMenu(node, fromType, text) {
      document.querySelectorAll(".send-menu").forEach(menu => menu.remove());
      const menu = document.createElement("div");
      menu.className = "send-menu active";
      const fromIndex = PIPELINE.indexOf(fromType);
      PIPELINE.forEach(target => {
        if (target === fromType) return;
        const tIndex = PIPELINE.indexOf(target);
        if (tIndex <= fromIndex) return;
        const option = document.createElement("div");
        option.className = "send-option";
        option.textContent = `-> ${AGENTS[target].name}`;
        option.style.borderLeft = "2px solid " + getComputedStyle(document.documentElement).getPropertyValue(COLORS[target]);
        option.addEventListener("click", e => {
          e.stopPropagation();
          routeMessage(fromType, target, text);
          menu.remove();
        });
        menu.appendChild(option);
      });
      node.appendChild(menu);
      document.addEventListener("click", function closeMenu() {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }, { once: true });
    }

    function routeMessage(fromType, toType, text) {
      if (!state.columns.includes(toType)) addColumn(toType);
      const travel = document.getElementById("travelIndicator");
      const toCol = document.querySelector(`.column[data-type="${toType}"]`);
      if (!toCol) {
        if (travel) travel.style.opacity = 0;
        return;
      }
      toCol.classList.remove("collapsed");
      const fromCol = document.querySelector(`.column[data-type="${fromType}"]`);
      if (!fromCol || !travel) return;
      fromCol.classList.remove("collapsed");
      fromCol.classList.remove("collapsed");
      const fromRect = fromCol.getBoundingClientRect();
      const toRect = toCol.getBoundingClientRect();
      travel.style.transition = "all 0.8s ease-in-out";
      travel.style.opacity = 1;
      travel.style.left = (fromRect.right - 12) + "px";
      travel.style.top = (fromRect.top + fromRect.height / 2) + "px";
      travel.style.background = getComputedStyle(document.documentElement).getPropertyValue(COLORS[toType]);
      travel.style.boxShadow = "0 0 18px " + getComputedStyle(document.documentElement).getPropertyValue(COLORS[toType]);
      setTimeout(() => {
        travel.style.left = (toRect.left + 12) + "px";
        travel.style.top = (toRect.top + toRect.height / 2) + "px";
        setTimeout(() => {
          travel.style.opacity = 0;
          const handoffBubble = addBubble(toType, "user", text, fromType);
          if (handoffBubble) handoffBubble.classList.add("handoff");
          const entry = logEvent("transclude", toType, text, fromType, toType);
          attachLogReference(entry, toType, handoffBubble);
          sendMessage(toType, text, fromType);
        }, 700);
      }, 40);
    }

    function suggestNext(type) {
      const index = PIPELINE.indexOf(type);
      if (index === -1 || index === PIPELINE.length - 1) return;
      const nextType = PIPELINE[index + 1];
      if (state.columns.includes(nextType)) return;
      const column = document.querySelector(`.column[data-type="${type}"]`);
      if (!column) return;
      const messages = column.querySelector(".messages");
      const note = document.createElement("div");
      note.className = "bubble system";
      const label = document.createElement("div");
      label.className = "bubble-label";
      label.textContent = "SYSTEM";
      const body = document.createElement("div");
      body.className = "bubble-content";
      body.textContent = "-> open " + AGENTS[nextType].name;
      note.appendChild(label);
      note.appendChild(body);
      note.addEventListener("click", () => addColumn(nextType));
      messages.appendChild(note);
      messages.scrollTop = messages.scrollHeight;
    }

    function addColumn(type) {
      if (state.columns.includes(type)) {
        focusColumn(type);
        return;
      }
      state.columns.push(type);
      if (!state.history[type]) state.history[type] = [];
      const col = document.createElement("div");
      col.className = "column";
      col.dataset.type = type;
      col.innerHTML = `
        <div class="column-tab">${AGENTS[type].name}</div>
        <div class="column-header">
          <div class="column-title">${AGENTS[type].name}</div>
          <div class="marker"></div>
        </div>
        <div class="collapse-hint">•</div>
        <div class="chat-shell">
          <div class="messages">
            <div class="bubble system">
              <div class="bubble-label">SYSTEM</div>
              <div class="bubble-content">${AGENTS[type].placeholder}</div>
            </div>
            <div class="initial-options"></div>
          </div>
          <div class="typing"></div>
          <div class="input-area">
            <div class="input-wrapper">
              <textarea placeholder="${AGENTS[type].placeholder}"></textarea>
              <button class="send-btn">></button>
            </div>
          </div>
        </div>`;
      document.getElementById("scrollContainer").appendChild(col);
      col.scrollIntoView({ behavior: "smooth", inline: "center" });
      initColumn(type);
      setActiveColumn(type);
      updateColumnNav();
      renderGraph();
    }

    function autoChain() {
      const sample = {
        pragmatic: "Set metrics: novelty, clarity, feel, perf. Guardrails enforced. Probe -> measure -> revise cadence weekly.",
        parrhesia: "Reference: hiding outage impact from customers. Extract speech-act naming risk and obligation.",
        composer: "INPUT_TOPIC: Rust belt synth hauntings versus filtered realities. WHY_CHAIN: reclaim clarity in compressed mixtapes.",
        lineage: "Lineage request: caretakers, epochs, migration. Highlight Motown tapes, freeway neon, blog-house era.",
        godlevel: "TOPIC: Algorithmic filters against mixtapes. ARCHETYPE: gardener. MOOD: resolve. TTL:1."
      };
      let delay = 0;
      PIPELINE.forEach(type => {
        if (!state.columns.includes(type)) addColumn(type);
        const payload = sample[type];
        setTimeout(() => {
          if (payload) sendMessage(type, payload);
        }, delay);
        delay += 1200;
      });
    }

    function sequenceChain() {
      const last = state.columns[state.columns.length - 1];
      const index = PIPELINE.indexOf(last);
      if (index === -1 || index === PIPELINE.length - 1) return;
      const column = document.querySelector(`.column[data-type="${last}"]`);
      if (!column) return;
      const messages = column.querySelectorAll(".bubble.assistant .bubble-content");
      const output = messages.length ? messages[messages.length - 1].childNodes[0].textContent : "";
      if (!output) return;
      const next = PIPELINE[index + 1];
      routeMessage(last, next, output);
    }

    function logEvent(role, agent, content, from, to) {
      const encoded = btoa(unescape(encodeURIComponent(content)));
      const entry = {
        id: ++state.counter,
        timestamp: new Date().toISOString(),
        role,
        agent,
        from: from || agent,
        to: to || agent,
        content,
        encoded,
        decoded: content
      };
      state.logs.push(entry);
      state.activeLogId = entry.id;
      state.version += 1;
      updateVersionBadge();
      if (state.menuOpen) renderLogs();
      renderGraph();
      return entry;
    }

    
    function updateVersionBadge() {
      const badge = document.getElementById("versionTag");
      if (badge) badge.textContent = "v" + state.version;
    }

function renderLogs() {
      const logView = document.getElementById("logView");
      if (!logView) return;
      logView.innerHTML = "";
      [...state.logs].slice(-50).reverse().forEach(item => {
        const node = document.createElement("div");
        node.className = "log-item";
        node.innerHTML = [
          "ID " + item.id + " - " + item.timestamp,
          "ROLE " + item.role.toUpperCase() + " - " + item.agent.toUpperCase(),
          "FROM " + item.from.toUpperCase() + " -> " + item.to.toUpperCase(),
          "RAW " + item.content,
          "ENC " + item.encoded.slice(0, 60) + (item.encoded.length > 60 ? "..." : "")
        ].join("<br>");
        logView.appendChild(node);
      });
      renderTransclusions();
    }

    function renderTransclusions() {
      const view = document.getElementById("transclusionView");
      if (!view) return;
      view.innerHTML = "";
      const map = {};
      state.logs.forEach(item => {
        if (item.role === "transclude") {
          const key = item.from + "->" + item.to;
          map[key] = (map[key] || 0) + 1;
        }
      });
      Object.entries(map).forEach(([key, count]) => {
        const node = document.createElement("div");
        node.className = "log-item";
        node.textContent = key.toUpperCase() + " : " + count + " hand-offs";
        view.appendChild(node);
      });
      if (!Object.keys(map).length) {
        const node = document.createElement("div");
        node.className = "log-item";
        node.textContent = "No transclusions yet.";
        view.appendChild(node);
      }
    }

    function renderGraph() {
      const container = document.getElementById("graphBar");
      if (!container) return;
      container.innerHTML = "";
<<<<<<< ours
      state.timelineData = {};
      state.timelineIndexById = {};
      if (window.innerWidth <= 900) hideTimelineDetail();

<<<<<<< ours
<<<<<<< ours
      const addNode = ({ number, color, primary, secondary, onClick, isTransclude, title, body, logId }) => {
=======
      const addNode = ({ number, color, primary, secondary, onClick, isTransclude, title }) => {
>>>>>>> theirs
=======
      const addNode = ({ number, color, primary, secondary, onClick, isTransclude }) => {
>>>>>>> theirs
        const node = document.createElement("div");
        node.className = "graph-node";
        if (isTransclude) node.classList.add("graph-node-trans");
        node.style.setProperty("--dot", color);
<<<<<<< ours
        node.dataset.number = number;
        if (typeof logId === "number") node.dataset.logId = logId;
=======
>>>>>>> theirs
        const dot = document.createElement("div");
        dot.className = "graph-dot";
        dot.textContent = number;
        node.appendChild(dot);
        if (primary) {
          const main = document.createElement("div");
          main.className = "graph-node-label graph-node-label-agent";
          main.textContent = primary;
          node.appendChild(main);
        }
        if (secondary) {
          const sub = document.createElement("div");
          sub.className = "graph-node-label graph-node-label-role";
          sub.textContent = secondary;
          node.appendChild(sub);
        }
<<<<<<< ours
        if (title) {
          node.title = title;
        } else if (primary) {
          node.title = primary;
        }
<<<<<<< ours
        const detailPayload = { number, primary, secondary, body: body ?? title ?? "", logId };
        if (typeof number !== "undefined") {
          state.timelineData[number] = detailPayload;
        }
        if (typeof logId === "number") {
          state.timelineIndexById[logId] = number;
        }
        const activate = evt => {
          if (evt) evt.preventDefault();
          showTimelineDetail(detailPayload);
          if (onClick) onClick();
        };
        node.addEventListener("click", activate);
        node.addEventListener("keydown", evt => {
          if (evt.key === "Enter" || evt.key === " ") {
            activate(evt);
          }
        });
        node.tabIndex = 0;
=======
=======
>>>>>>> theirs
        if (onClick) node.addEventListener("click", onClick);
>>>>>>> theirs
        container.appendChild(node);
        return node;
      };

<<<<<<< ours
      let pendingDetail = null;
      let activeLogFound = false;
=======
>>>>>>> theirs
=======
>>>>>>> theirs
      if (!state.logs.length) {
        if (!state.columns.length) {
          const empty = document.createElement("div");
          empty.className = "graph-empty";
          empty.textContent = "no flows yet";
          container.appendChild(empty);
          hideTimelineDetail();
          return;
        }
<<<<<<< ours
        state.columns.forEach((col, index) => {
          const agent = AGENTS[col];
          addNode({
            number: index + 1,
            color: accentColor(col),
            primary: agent ? agent.name : col.toUpperCase(),
            secondary: "READY",
            onClick: () => focusColumn(col)
          });
<<<<<<< ours
<<<<<<< ours
          if (col === state.activeColumn && !state.activeLogId) {
            node.classList.add("graph-node-active");
            pendingDetail = detailData;
          }
=======
          if (col === state.activeColumn) node.classList.add("graph-node-active");
>>>>>>> theirs
=======
>>>>>>> theirs
=======
        state.columns.forEach(col => {
          const node = document.createElement("div");
          node.className = "graph-node";
          node.style.setProperty("--dot", accentColor(col));
          const dot = document.createElement("div");
          dot.className = "graph-dot";
          node.appendChild(dot);
          const text = document.createElement("div");
          text.className = "graph-text";
          text.textContent = col.toUpperCase();
          node.appendChild(text);
          node.addEventListener("click", () => focusColumn(col));
          container.appendChild(node);
>>>>>>> theirs
        });
      } else {
        state.logs.slice(-40).forEach(item => {
          const node = document.createElement("div");
          node.className = "graph-node";
          if (item.role === "transclude") node.classList.add("graph-node-trans");
          node.style.setProperty("--dot", accentColor(item.agent));
          node.dataset.logId = item.id;
          node.title = [
            "#" + item.id,
            item.agent.toUpperCase(),
            item.role.toUpperCase(),
            item.from.toUpperCase() + " -> " + item.to.toUpperCase()
          ].join(" | ");
          const dot = document.createElement("div");
          dot.className = "graph-dot";
          node.appendChild(dot);
<<<<<<< ours
          const body = document.createElement("div");
          body.className = "graph-body";
          const commit = document.createElement("div");
          commit.className = "graph-commit";
          const index = document.createElement("div");
          index.className = "graph-index";
          index.textContent = "#" + item.id;
          const agentLabel = document.createElement("div");
          agentLabel.className = "graph-agent";
          agentLabel.textContent = item.agent.toUpperCase();
          commit.appendChild(index);
          commit.appendChild(agentLabel);
          body.appendChild(commit);
          const role = document.createElement("div");
          role.className = "graph-role";
          if (item.role === "transclude") {
            role.textContent = `${item.from.toUpperCase()} → ${item.to.toUpperCase()}`;
          } else if (item.role === "assistant") {
            role.textContent = "OUT";
          } else if (item.role === "user") {
            role.textContent = "IN";
          } else {
            role.textContent = item.role.toUpperCase();
          }
<<<<<<< ours
          addNode({
            number,
            color: accentColor(item.agent),
            primary: agentLabel,
            secondary: detail,
<<<<<<< ours
<<<<<<< ours
            body: item.content || "",
            logId: item.id
          };
          const node = addNode({
            ...detailData,
            color: accentColor(item.agent),
=======
>>>>>>> theirs
            title: item.content,
            isTransclude: item.role === "transclude",
            onClick: () => focusLog(item.id)
          });
<<<<<<< ours
          const isActive = state.activeLogId ? item.id === state.activeLogId : idx === slice.length - 1;
          if (isActive) {
            node.classList.add("graph-node-active");
            pendingDetail = detailData;
            if (state.activeLogId) activeLogFound = true;
          }
=======
          if (idx === slice.length - 1) node.classList.add("graph-node-active");
>>>>>>> theirs
=======
            isTransclude: item.role === "transclude",
            onClick: () => focusLog(item.id)
          });
>>>>>>> theirs
=======
          body.appendChild(role);
          node.appendChild(body);
=======
          const text = document.createElement("div");
          text.className = "graph-text";
          text.textContent = "#" + item.id;
          node.appendChild(text);
>>>>>>> theirs
          node.addEventListener("click", () => focusLog(item.id));
          container.appendChild(node);
>>>>>>> theirs
        });
        if (state.activeLogId && !activeLogFound) {
          const entry = state.logs.find(item => item.id === state.activeLogId);
          pendingDetail = buildLogDetail(entry, state.timelineIndexById[state.activeLogId]);
        }
      }
<<<<<<< ours

<<<<<<< ours
<<<<<<< ours
      const panel = getTimelineDetail();
      if (pendingDetail) {
        showTimelineDetail(pendingDetail);
      } else if (panel && panel.classList.contains("active")) {
        hideTimelineDetail();
      }
=======
>>>>>>> theirs
=======
=======
>>>>>>> theirs
      const contextCard = document.createElement("div");
      contextCard.className = "context-card";
      const title = document.createElement("div");
      title.className = "context-card-title";
      title.textContent = "Shared Context";
      contextCard.appendChild(title);
      const reversed = [...state.logs].reverse();
      const seen = new Set();
      state.columns.forEach(type => {
        if (seen.has(type)) return;
        const latest = reversed.find(item => item.role === "assistant" && item.agent === type);
        if (!latest) return;
        seen.add(type);
        const entry = document.createElement("div");
        entry.className = "context-card-entry";
        entry.style.setProperty("--entry-color", accentColor(type));
        const snippet = latest.content.length > 120 ? latest.content.slice(0, 117) + "..." : latest.content;
        entry.textContent = `${type.toUpperCase()}: ${snippet}`;
        entry.title = latest.content;
        entry.addEventListener("click", () => focusLog(latest.id));
        contextCard.appendChild(entry);
      });
      if (state.scratchpad && state.scratchpad.trim()) {
        const entry = document.createElement("div");
        entry.className = "context-card-entry";
        entry.style.setProperty("--entry-color", "#6d79ff");
        const snippet = state.scratchpad.length > 120 ? state.scratchpad.slice(0, 117) + "..." : state.scratchpad;
        entry.textContent = `SCRATCHPAD: ${snippet}`;
        entry.title = "Open shared scratchpad";
        entry.addEventListener("click", () => openScratchpad(state.activeColumn));
        contextCard.appendChild(entry);
      }
      if (contextCard.children.length === 1) {
        const emptyLine = document.createElement("div");
        emptyLine.className = "context-card-entry";
        emptyLine.style.setProperty("--entry-color", varAccentFallback());
        emptyLine.textContent = "No assistant outputs yet.";
        emptyLine.style.cursor = "default";
        contextCard.appendChild(emptyLine);
      }
      container.appendChild(contextCard);
>>>>>>> theirs
    }

    function varAccentFallback() {
      return accentColor(state.activeColumn || "pragmatic");
    }

    
    function getContextSnapshot() {
      const lines = ["PCL CONTEXT SNAPSHOT v" + state.version, ""];
      PIPELINE.forEach(type => {
        const history = state.history[type] || [];
        const lastAssistant = [...history].reverse().find(entry => entry.role === "assistant");
        if (lastAssistant) {
          lines.push("# " + type.toUpperCase());
          lines.push(lastAssistant.text);
          lines.push("");
        }
      });
      return lines.join("\n");
    }

    function copyContextSnapshot() {
      const snapshot = getContextSnapshot();
      if (!snapshot.trim()) {
        alert("No context available yet.");
        return;
      }
      navigator.clipboard.writeText(snapshot).then(() => {
        if (!state.menuOpen) return;
        const view = document.getElementById("logView");
        if (!view) return;
        const note = document.createElement("div");
        note.className = "log-item";
        note.textContent = "Context snapshot copied.";
        view.prepend(note);
      }).catch(err => alert("Copy failed: " + err.message));
    }

function exportLogs() {
      const data = {
        generated_at: new Date().toISOString(),
        logs: state.logs,
        version: state.version
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "prompt_chain_logs_" + Date.now() + ".json";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(url);
        a.remove();
      }, 100);
    }

    function importLogs(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const data = JSON.parse(evt.target.result);
          state.logs = Array.isArray(data.logs) ? data.logs : [];
          state.logRefs.clear();
          state.activeLogId = state.logs.length ? state.logs[state.logs.length - 1].id : null;
          if (typeof data.version === "number") { state.version = data.version; updateVersionBadge(); }
          renderLogs();
          renderGraph();
        } catch {
          alert("Invalid log file.");
        }
      };
      reader.readAsText(file);
    }

    function clearLogs() {
      state.logs = [];
      state.version += 1;
      updateVersionBadge();
      state.logRefs.clear();
      state.activeLogId = null;
      state.timelineData = {};
      state.timelineIndexById = {};
      hideTimelineDetail();
      renderLogs();
      renderGraph();
    }

    window.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
