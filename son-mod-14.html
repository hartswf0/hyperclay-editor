<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>STRATA // TERRAIN ENGINE</title>
<style>
    :root {
        /* EARTH & TERRAIN PALETTE */
        --void: #121110;      /* Deep Earth */
        --surface: #1e1c1a;   /* Slate/Stone */
        --border: #33302c;    /* Soil */
        --clay: #c26a4b;      /* Active Warmth */
        --moss: #6b7d5d;      /* Passive Growth */
        --sand: #e6dcc8;      /* UI Primary */
        --slate: #5e6870;     /* UI Secondary */
        --h-unit: 160px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
    
    body {
        margin: 0; background: var(--void); color: var(--sand);
        font-family: 'Inter', -apple-system, monospace; overflow: hidden;
        height: 100vh; display: flex; flex-direction: column;
    }

    /* --- TOP BAR: TEMPO & MINIMAP --- */
    #dashboard {
        height: 50px; background: var(--surface);
        border-bottom: 1px solid var(--border);
        display: grid;
        grid-template-columns: 120px 1fr 140px;
        align-items: center; padding: 0 15px;
        z-index: 100;
    }

    /* TEMPO CONTROL */
    .tempo-box {
        display: flex; flex-direction: column; align-items: center;
        cursor: ns-resize; border-right: 1px solid var(--border);
    }
    .tempo-val { font-size: 18px; font-weight: 900; letter-spacing: -1px; color: var(--clay); }
    .tempo-label { font-size: 8px; text-transform: uppercase; color: var(--slate); }

    /* MINIMAP / ACTIVITY MONITOR */
    .minimap {
        padding: 0 20px; display: flex; align-items: center; gap: 4px;
        height: 100%;
    }
    .map-bar {
        flex: 1; height: 12px; background: #2a2825; border-radius: 1px;
        position: relative; overflow: hidden;
    }
    .map-fill {
        position: absolute; left: 0; top: 0; bottom: 0;
        background: var(--moss); width: 0%; opacity: 0.3;
        transition: width 0.1s;
    }
    .map-trigger {
        position: absolute; right: 2px; top: 2px; width: 8px; height: 8px;
        border-radius: 50%; background: var(--clay); opacity: 0;
    }
    .active-trigger { animation: flash 0.4s ease-out; }
    @keyframes flash { from { opacity: 1; transform: scale(1.5); } to { opacity: 0; transform: scale(1); } }

    /* --- MAIN INSTRUMENT SURFACE --- */
    #surface {
        flex: 1; position: relative; background: #000;
        display: flex; flex-direction: column; overflow: hidden;
    }

    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

    /* FLOATING DIALS */
    .knob-rack {
        position: absolute; left: 20px; bottom: 20px;
        display: flex; gap: 20px; pointer-events: none;
    }
    .knob {
        pointer-events: auto; width: 50px; height: 70px;
        display: flex; flex-direction: column; align-items: center;
    }
    .knob-circle {
        width: 44px; height: 44px; border-radius: 50%;
        border: 2px solid var(--border); background: var(--surface);
        position: relative; cursor: ns-resize;
    }
    .knob-indicator {
        position: absolute; top: 4px; left: 50%; width: 2px; height: 12px;
        background: var(--clay); transform-origin: 50% 18px;
        transform: rotate(var(--rot, 0deg));
    }
    .knob-label { font-size: 9px; margin-top: 6px; color: var(--slate); letter-spacing: 1px; }

    /* TRANSPORT FAB */
    #transport {
        position: absolute; right: 20px; bottom: 20px;
        width: 60px; height: 60px; border-radius: 50%;
        background: var(--clay); color: var(--void);
        display: grid; place-items: center; font-size: 24px;
        cursor: pointer; box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        z-index: 10;
    }
    #transport.playing { background: var(--sand); }

    .help-hint {
        position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
        font-size: 10px; color: var(--border); text-transform: uppercase;
        letter-spacing: 2px; pointer-events: none;
    }

</style>
</head>
<body>

<div id="dashboard">
    <div class="tempo-box" id="tempo-ctrl">
        <div class="tempo-val" id="bpm-display">110</div>
        <div class="tempo-label">BPM // TEMPO</div>
    </div>
    <div class="minimap" id="minimap-container">
        <!-- Minimap bars for different frequency strata -->
    </div>
    <div class="btn" style="text-align:right; border:none; color:var(--clay)" id="btn-reset">RESET MESH</div>
</div>

<div id="surface">
    <div class="help-hint">Sculpt terrain to define sequence geometry</div>
    <canvas id="main-cv"></canvas>
    
    <div class="knob-rack">
        <div class="knob">
            <div class="knob-circle" data-param="force" data-val="15"><div class="knob-indicator"></div></div>
            <div class="knob-label">FORCE</div>
        </div>
        <div class="knob">
            <div class="knob-circle" data-param="size" data-val="80"><div class="knob-indicator"></div></div>
            <div class="knob-label">RADIUS</div>
        </div>
        <div class="knob">
            <div class="knob-circle" data-param="grit" data-val="40"><div class="knob-indicator"></div></div>
            <div class="knob-label">GRIT</div>
        </div>
    </div>

    <div id="transport">▶</div>
</div>

<script>
/**
 * TERRAIN ENGINE // STRATA v2
 * High-precision sculpting & sequencing
 */

const state = {
    bpm: 110,
    playing: false,
    params: { force: 15, size: 80, grit: 40 },
    pts: [],
    seqStep: 0,
    lastTime: 0,
    w: 0, h: 0,
    mouse: { x: 0, y: 0, down: false }
};

const Audio = {
    ctx: null,
    master: null,
    init() {
        if (this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.5;
        this.master.connect(this.ctx.destination);
    },
    playNote(yNorm, grit) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        // Pitch: Geological scale (C Major Pentatonic)
        const scale = [0, 2, 4, 7, 9, 12, 14, 16, 19, 21];
        const idx = Math.floor((1 - yNorm) * scale.length);
        const freq = 65.41 * Math.pow(2, (scale[idx] || 0) / 12); // Starting at C2

        osc.type = grit > 60 ? 'sawtooth' : 'triangle';
        osc.frequency.setValueAtTime(freq, t);
        
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.2, t + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

        osc.connect(gain);
        gain.connect(this.master);
        osc.start(t);
        osc.stop(t + 0.5);
        
        // Trigger Minimap Visual
        const mapIdx = Math.floor(yNorm * 8);
        const bar = document.querySelectorAll('.map-trigger')[mapIdx];
        if(bar) {
            bar.classList.remove('active-trigger');
            void bar.offsetWidth; // trigger reflow
            bar.classList.add('active-trigger');
        }
    }
};

// Setup Minimap
const mapContainer = document.getElementById('minimap-container');
for(let i=0; i<12; i++) {
    const bar = document.createElement('div');
    bar.className = 'map-bar';
    bar.innerHTML = `<div class="map-fill"></div><div class="map-trigger"></div>`;
    mapContainer.appendChild(bar);
}

const cv = document.getElementById('main-cv');
const ctx = cv.getContext('2d');

function resize() {
    state.w = cv.width = window.innerWidth;
    state.h = cv.height = window.innerHeight;
    initMesh();
}

function initMesh() {
    state.pts = [];
    const cols = 48; // High resolution sequencer
    const rows = 12;
    for(let r=0; r<=rows; r++) {
        for(let c=0; c<=cols; c++) {
            const x = (c/cols) * state.w;
            const y = (r/rows) * state.h;
            state.pts.push({ x, y, ox: x, oy: y, c, r });
        }
    }
}

// Interaction
cv.addEventListener('pointerdown', e => { state.mouse.down = true; Audio.init(); });
window.addEventListener('pointerup', () => state.mouse.down = false);
cv.addEventListener('pointermove', e => {
    state.mouse.x = e.clientX;
    state.mouse.y = e.clientY - 50; // Offset for top bar
    if(state.mouse.down) sculpt();
});

function sculpt() {
    const r2 = state.params.size * state.params.size;
    state.pts.forEach(p => {
        const dx = p.x - state.mouse.x;
        const dy = p.y - state.mouse.y;
        const d2 = dx*dx + dy*dy;
        if(d2 < r2) {
            const dist = Math.sqrt(d2);
            const force = (1 - dist/state.params.size) * (state.params.force * 0.2);
            p.y += (state.mouse.y - p.y) * force;
        }
    });
}

// Dials Logic
document.querySelectorAll('.knob-circle').forEach(k => {
    let startY = 0;
    let startVal = 0;
    k.addEventListener('pointerdown', e => {
        startY = e.clientY;
        startVal = state.params[k.dataset.param];
        k.setPointerCapture(e.pointerId);
        k.onpointermove = ev => {
            const delta = startY - ev.clientY;
            const newVal = Math.max(0, Math.min(150, startVal + delta));
            state.params[k.dataset.param] = newVal;
            k.style.setProperty('--rot', (newVal * 2) + 'deg');
        };
        k.onpointerup = () => k.onpointermove = null;
    });
});

// Tempo Control
const bpmDisp = document.getElementById('bpm-display');
document.getElementById('tempo-ctrl').addEventListener('pointerdown', e => {
    let startY = e.clientY;
    let startBpm = state.bpm;
    window.onpointermove = ev => {
        const delta = startY - ev.clientY;
        state.bpm = Math.max(40, Math.min(220, startBpm + Math.floor(delta/2)));
        bpmDisp.innerText = state.bpm;
    };
    window.onpointerup = () => window.onpointermove = null;
});

// Transport
const trans = document.getElementById('transport');
trans.onclick = () => {
    Audio.init();
    state.playing = !state.playing;
    trans.classList.toggle('playing', state.playing);
    trans.innerText = state.playing ? '■' : '▶';
};

document.getElementById('btn-reset').onclick = initMesh;

function loop(t) {
    requestAnimationFrame(loop);
    
    // Logic: Sequencer
    if(state.playing && Audio.ctx) {
        const stepDur = 60 / state.bpm / 4; // 16th notes
        const now = Audio.ctx.currentTime;
        if(now - state.lastTime > stepDur) {
            state.lastTime = now;
            state.seqStep = (state.seqStep + 1) % 48;
            
            // Trigger notes based on mesh displacement
            state.pts.forEach(p => {
                if(p.c === state.seqStep) {
                    const diff = Math.abs(p.y - p.oy);
                    if(diff > 15) { // Displacement threshold
                        Audio.playNote(p.y / state.h, state.params.grit);
                    }
                }
            });
        }
    }

    // Render
    ctx.fillStyle = '#121110';
    ctx.fillRect(0, 0, state.w, state.h);

    // Grid Background
    ctx.strokeStyle = '#1e1c1a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<state.w; i+=40) { ctx.moveTo(i, 0); ctx.lineTo(i, state.h); }
    ctx.stroke();

    // Draw Mesh
    ctx.strokeStyle = 'var(--moss)';
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1.5;
    
    const rows = 12;
    const cols = 48;
    for(let r=0; r<=rows; r++) {
        ctx.beginPath();
        for(let c=0; c<=cols; c++) {
            const p = state.pts[r*(cols+1)+c];
            c === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }
    
    // Playhead
    if(state.playing) {
        const x = (state.seqStep / 48) * state.w;
        ctx.globalAlpha = 1;
        ctx.strokeStyle = 'var(--clay)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, state.h); ctx.stroke();
    }
}

window.addEventListener('resize', resize);
resize();
loop();

</script>
</body>
</html>
