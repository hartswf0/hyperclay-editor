<!-- hyperclay-manifold-terrain.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>MANIFOLD // TERRAIN</title>
<style>
  :root {
    /* MANIFOLD PALETTE */
    --bg: #0a0a08;
    --panel: #1a1815;
    --border: #3a3228;
    --accent: #d4a418;  /* Ochre */
    --accent-dim: #b84a39; /* Rust */
    --signal: #4fffa0;   /* Signal Green */
    --text: #c2b280;     /* Sand */
    --text-dim: #635147; /* Umber */
    
    --h: 150px;
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
  
  body {
    margin: 0; background: var(--bg); height: 100vh;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Inter', -apple-system, system-ui, sans-serif;
    overflow: hidden;
  }

  /* RACK CHASSIS */
  .rack {
    width: 100%; max-width: 1200px; height: var(--h);
    background: var(--panel);
    border: 1px solid var(--border);
    display: grid;
    grid-template-columns: 160px 1fr 90px; /* Left | Center | Right */
    box-shadow: 0 20px 50px #000;
  }

  /* --- LEFT: PARAMETERS --- */
  .controls-left {
    padding: 12px;
    display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
    gap: 10px; border-right: 1px solid var(--border);
  }

  .dial-wrapper {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    cursor: ns-resize;
  }
  
  .dial-svg { width: 44px; height: 44px; display: block; }
  .dial-bg { fill: none; stroke: #26221e; stroke-width: 3; }
  .dial-val { 
    fill: none; stroke: var(--accent); stroke-width: 3; stroke-linecap: round;
    stroke-dasharray: 0 100; transform: rotate(-90deg); transform-origin: 50% 50%;
    transition: stroke-dasharray 0.05s ease-out;
  }
  .dial-label { font-size: 9px; color: var(--text-dim); margin-top: 4px; letter-spacing: 1px; font-weight: 600; }

  /* --- CENTER: SCREEN --- */
  .screen-area {
    position: relative; background: #050504; 
    overflow: hidden; cursor: crosshair;
  }
  canvas { display: block; width: 100%; height: 100%; }
  
  /* Floating Toolbar */
  .toolbar {
    position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
    display: flex; flex-direction: column; gap: 8px; z-index: 10;
  }
  
  .tool-btn {
    width: 32px; height: 32px; background: rgba(26, 24, 21, 0.9);
    border: 1px solid var(--border); border-radius: 4px;
    color: var(--text-dim); font-size: 14px; display: grid; place-items: center;
    cursor: pointer; transition: all 0.2s;
  }
  
  .tool-btn:hover { border-color: var(--text); color: var(--text); }
  .tool-btn.active {
    border-color: var(--accent); color: var(--accent);
    box-shadow: 0 0 10px rgba(212, 164, 24, 0.2);
  }

  /* --- RIGHT: TRANSPORT & SCOPE --- */
  .controls-right {
    border-left: 1px solid var(--border);
    display: flex; flex-direction: column;
    padding: 10px; gap: 10px;
    background: #11100f; align-items: center;
  }

  /* TEMPO DISPLAY */
  .tempo-box {
    width: 100%; background: #080808; border: 1px solid var(--border);
    height: 24px; display: flex; align-items: center; justify-content: center;
    color: var(--accent); font-size: 11px; letter-spacing: 1px;
    cursor: ns-resize; border-radius: 2px;
  }
  .tempo-label { font-size: 8px; color: var(--text-dim); margin-right: 4px; }

  /* MINIMAP (OSCILLOSCOPE) */
  .minimap-container {
    width: 100%; flex: 1; background: #050505; 
    border: 1px solid var(--border); border-radius: 2px;
    position: relative; overflow: hidden;
  }
  #mini-scope { width: 100%; height: 100%; opacity: 0.9; }

  /* TRANSPORT BUTTONS */
  .transport-group {
    display: flex; gap: 8px; justify-content: center; width: 100%;
  }
  
  .btn-rect {
    flex: 1; height: 28px; background: #1a1815; border: 1px solid var(--border);
    color: var(--text-dim); display: grid; place-items: center;
    font-size: 10px; cursor: pointer; border-radius: 2px; transition: all 0.2s;
    letter-spacing: 1px;
  }
  .btn-rect:hover { border-color: var(--accent-dim); color: var(--text); }
  .btn-rect.active { border-color: var(--accent); color: var(--accent); background: rgba(212, 164, 24, 0.15); }
  
  .btn-circle {
    width: 44px; height: 44px; border-radius: 50%;
    border: 2px solid var(--border); display: grid; place-items: center;
    color: var(--text-dim); cursor: pointer; transition: all 0.2s;
    background: #161412; font-size: 14px;
  }
  .btn-circle:hover { border-color: var(--text); color: var(--text); }
  .btn-circle.playing {
    border-color: var(--accent); color: var(--accent);
    background: rgba(212, 164, 24, 0.1);
    box-shadow: 0 0 15px rgba(212, 164, 24, 0.2);
  }

  /* --- RESPONSIVE --- */
  @media (max-width: 600px) {
    .rack { grid-template-columns: 120px 1fr 80px; }
    .dial-svg { width: 36px; height: 36px; }
    .toolbar { left: 5px; gap: 4px; }
    .tool-btn { width: 28px; height: 28px; font-size: 12px; }
  }
</style>
</head>
<body>

<div class="rack">
  
  <!-- LEFT: PARAMETERS -->
  <div class="controls-left">
    <!-- FORCE -->
    <div class="dial-wrapper" id="d-str" data-param="strength" data-min="1" data-max="30" data-val="12">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">FORCE</div>
    </div>
    <!-- SIZE -->
    <div class="dial-wrapper" id="d-rad" data-param="radius" data-min="20" data-max="150" data-val="50">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">SIZE</div>
    </div>
    <!-- TONE -->
    <div class="dial-wrapper" id="d-flt" data-param="filter" data-min="200" data-max="5000" data-val="1200">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">TONE</div>
    </div>
    <!-- FADE -->
    <div class="dial-wrapper" id="d-dec" data-param="release" data-min="100" data-max="1000" data-val="300">
      <svg class="dial-svg" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
        <path class="dial-val" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
      </svg>
      <div class="dial-label">FADE</div>
    </div>
  </div>

  <!-- CENTER: CANVAS -->
  <div class="screen-area" id="screen">
    <canvas id="cv"></canvas>
    
    <div class="toolbar">
      <div class="tool-btn active" data-tool="push" title="Push">●</div>
      <div class="tool-btn" data-tool="pull" title="Pull">○</div>
      <div class="tool-btn" data-tool="noise" title="Noise">∿</div>
      <div class="tool-btn" data-tool="smooth" title="Smooth">≈</div>
    </div>
  </div>

  <!-- RIGHT: CONTROLS -->
  <div class="controls-right">
    <!-- TEMPO -->
    <div class="tempo-box" id="tempo-control" title="Drag to change BPM">
      <span class="tempo-label">BPM</span> <span id="tempo-val">110</span>
    </div>
    
    <!-- MINIMAP / SCOPE -->
    <div class="minimap-container">
      <canvas id="mini-scope"></canvas>
    </div>

    <!-- TRANSPORT -->
    <div class="btn-circle" id="btn-play">▶</div>
    
    <div class="transport-group">
      <div class="btn-rect" id="btn-mode">SCULPT</div>
      <div class="btn-rect" id="btn-clr">CLR</div>
    </div>
  </div>

</div>

<script>
/**
 * HYPERCLAY MANIFOLD // TERRAIN ENGINE
 * Unified Design & Architecture
 */

const CFG = {
  cols: 16, // Steps
  rows: 8,  // Pitch quantization
  color: '#d4a418'
};

const params = {
  strength: 12, radius: 50, filter: 1200, release: 300,
  tempo: 110
};

const state = {
  playing: false,
  mode: 'sculpt', // sculpt | seq
  tool: 'push',
  mx: 0, my: 0,
  down: false,
  pulling: false,
  step: 0,
  lastTime: 0
};

// --- AUDIO ENGINE ---
const Audio = {
  ctx: null,
  analyser: null,
  bufferLength: 0,
  dataArray: null,
  
  init() {
    if(this.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AC();
    
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.4;
    
    // Analyser for Minimap
    this.analyser = this.ctx.createAnalyser();
    this.analyser.fftSize = 256;
    this.bufferLength = this.analyser.frequencyBinCount;
    this.dataArray = new Uint8Array(this.bufferLength);
    
    this.master.connect(this.analyser);
    this.analyser.connect(this.ctx.destination);
  },

  playNote(yNorm) {
    if(!this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const flt = this.ctx.createBiquadFilter();
    const gain = this.ctx.createGain();
    
    // Scale Logic
    const scale = [0, 2, 4, 7, 9, 12];
    const idx = Math.floor((1-yNorm) * (scale.length)); 
    const note = scale[Math.max(0, Math.min(idx, scale.length-1))];
    const freq = 110 * Math.pow(2, note/12); // A2 Root

    osc.frequency.setValueAtTime(freq, t);
    osc.type = 'sawtooth'; // Manifold signature sound
    
    flt.type = 'lowpass';
    flt.frequency.value = params.filter;
    flt.Q.value = 4;
    
    const dur = params.release / 1000;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + dur);

    osc.connect(flt).connect(gain).connect(this.master);
    osc.start(t); osc.stop(t + dur + 0.1);
  }
};

// --- CANVAS & MESH ---
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const scopeCv = document.getElementById('mini-scope');
const scopeCtx = scopeCv.getContext('2d');
let W, H, pts = [], cells = [];

function resize() {
  const rect = cv.parentElement.getBoundingClientRect();
  W = cv.width = rect.width;
  H = cv.height = rect.height;
  
  // Scope Resize
  const sRect = scopeCv.parentElement.getBoundingClientRect();
  scopeCv.width = sRect.width;
  scopeCv.height = sRect.height;

  initGrid();
}

function initGrid() {
  pts = [];
  // Create organic mesh points (High res for smooth lines)
  const pRows = 10, pCols = 30;
  for(let r=0; r<=pRows; r++) {
    for(let c=0; c<=pCols; c++) {
      const x = (c/pCols) * W;
      const y = (r/pRows) * H;
      pts.push({x, y, ox:x, oy:y});
    }
  }
  
  cells = [];
  // Create sequencer cells (16 steps)
  const cellW = W/16;
  const cellH = H;
  for(let i=0; i<16; i++) {
    cells.push({ x: i*cellW, w: cellW, active: false, triggerY: 0 });
  }
}

// --- INTERACTION ---
function sculpt(x, y) {
  const r2 = params.radius * params.radius;
  pts.forEach(p => {
    const dx = p.x - x;
    const dy = p.y - y;
    if(dx*dx + dy*dy < r2) {
      const d = Math.sqrt(dx*dx + dy*dy);
      const f = (1 - d/params.radius) * (params.strength * 0.5);
      
      if (state.tool === 'push') {
        p.y += (y - p.y) * 0.1 * f; 
      } else if (state.tool === 'pull') {
        p.y -= (y - p.y) * 0.1 * f;
      } else if (state.tool === 'noise') {
        p.y += (Math.random() - 0.5) * f * 2;
      } else if (state.tool === 'smooth') {
        p.y += (p.oy - p.y) * 0.1 * f;
      }
      
      // Clamp to screen
      p.y = Math.max(0, Math.min(H, p.y));
    }
  });
}

function checkCells() {
  // Determine if a cell is active based on mesh distortion
  cells.forEach((c, i) => {
    // Find points in this cell column
    const colPts = pts.filter(p => p.x >= c.x && p.x < c.x + c.w);
    let maxDist = 0;
    let avgY = 0;
    colPts.forEach(p => {
      const dist = Math.abs(p.y - p.oy);
      if(dist > maxDist) maxDist = dist;
      avgY += p.y;
    });
    
    // Threshold for activation
    if(maxDist > 10) {
      c.active = true;
      c.triggerY = avgY / colPts.length;
    } else {
      c.active = false;
    }
  });
}

// Event Listeners
cv.addEventListener('pointerdown', e => {
  Audio.init();
  state.down = true;
  state.mx = e.offsetX; state.my = e.offsetY;
  cv.setPointerCapture(e.pointerId);
  
  if(state.mode === 'sculpt') {
    sculpt(state.mx, state.my);
    if(Math.random() > 0.8) Audio.playNote(state.my/H);
  } else {
    // Manual Trigger in Seq mode
    Audio.playNote(state.my/H);
  }
});

cv.addEventListener('pointermove', e => {
  state.mx = e.offsetX; state.my = e.offsetY;
  if(state.down && state.mode === 'sculpt') sculpt(state.mx, state.my);
});

window.addEventListener('pointerup', () => state.down = false);
window.addEventListener('resize', resize);

// --- CONTROLS LOGIC ---
// Dials
document.querySelectorAll('.dial-wrapper').forEach(el => {
  let startY, startVal;
  const param = el.dataset.param;
  const min = parseFloat(el.dataset.min);
  const max = parseFloat(el.dataset.max);
  
  const update = (v) => {
    params[param] = v;
    const pct = (v - min)/(max - min);
    el.querySelector('.dial-val').style.strokeDasharray = `${pct*100} 100`;
  };
  
  // Init visual
  update(parseFloat(el.dataset.val));

  el.addEventListener('pointerdown', e => {
    startY = e.clientY; startVal = params[param];
    el.setPointerCapture(e.pointerId);
    el.onpointermove = ev => {
      const d = startY - ev.clientY;
      const val = Math.max(min, Math.min(max, startVal + (d/100)*(max-min)));
      update(val);
    };
    el.onpointerup = () => el.onpointermove = null;
  });
});

// Tempo Drag
const tempoEl = document.getElementById('tempo-control');
const tempoValEl = document.getElementById('tempo-val');
let tempoStartY, tempoStartVal;
tempoEl.addEventListener('pointerdown', e => {
  tempoStartY = e.clientY;
  tempoStartVal = params.tempo;
  tempoEl.setPointerCapture(e.pointerId);
  tempoEl.onpointermove = ev => {
    const d = tempoStartY - ev.clientY;
    params.tempo = Math.floor(Math.max(60, Math.min(240, tempoStartVal + d)));
    tempoValEl.innerText = params.tempo;
  };
  tempoEl.onpointerup = () => tempoEl.onpointermove = null;
});

// Tools
document.querySelectorAll('.tool-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.tool = btn.dataset.tool;
  });
});

// Buttons
const btnPlay = document.getElementById('btn-play');
btnPlay.onclick = () => {
  Audio.init();
  state.playing = !state.playing;
  btnPlay.classList.toggle('playing', state.playing);
  btnPlay.innerText = state.playing ? '■' : '▶';
  if(state.playing && Audio.ctx.state === 'suspended') Audio.ctx.resume();
};

const btnMode = document.getElementById('btn-mode');
btnMode.onclick = () => {
  state.mode = state.mode === 'sculpt' ? 'seq' : 'sculpt';
  btnMode.innerText = state.mode.toUpperCase();
  btnMode.classList.toggle('active', state.mode === 'seq');
};

document.getElementById('btn-clr').onclick = () => {
  initGrid();
};

// --- RENDER LOOP ---
function drawScope() {
  const w = scopeCv.width;
  const h = scopeCv.height;
  scopeCtx.fillStyle = '#050505';
  scopeCtx.fillRect(0,0,w,h);
  
  if(!Audio.analyser) return;
  
  Audio.analyser.getByteTimeDomainData(Audio.dataArray);
  
  scopeCtx.lineWidth = 1;
  scopeCtx.strokeStyle = state.playing ? '#4fffa0' : '#444';
  scopeCtx.beginPath();
  
  const sliceWidth = w * 1.0 / Audio.bufferLength;
  let x = 0;
  
  for(let i=0; i<Audio.bufferLength; i++) {
    const v = Audio.dataArray[i] / 128.0;
    const y = v * h/2;
    if(i===0) scopeCtx.moveTo(x,y);
    else scopeCtx.lineTo(x,y);
    x += sliceWidth;
  }
  scopeCtx.stroke();
  
  // Grid lines
  scopeCtx.fillStyle = 'rgba(255,255,255,0.05)';
  scopeCtx.fillRect(0, h/2, w, 1);
}

function loop() {
  requestAnimationFrame(loop);
  
  // Logic
  checkCells();
  
  if(state.playing && Audio.ctx) {
    const now = Audio.ctx.currentTime;
    const stepTime = 60 / params.tempo / 4; // 16th notes
    if(now - state.lastTime > stepTime) {
      state.lastTime = now;
      state.step = (state.step + 1) % 16;
      
      const c = cells[state.step];
      if(c.active) Audio.playNote(c.triggerY / H);
    }
  }

  // Draw Main
  ctx.fillStyle = '#050504';
  ctx.fillRect(0,0,W,H);
  
  // Draw Grid
  ctx.strokeStyle = '#1a1815';
  ctx.lineWidth = 1;
  cells.forEach(c => {
    ctx.beginPath(); ctx.moveTo(c.x, 0); ctx.lineTo(c.x, H); ctx.stroke();
  });
  
  // Draw Mesh
  ctx.strokeStyle = '#d4a418';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  // Horizontal lines (rows)
  const pRows = 10, pCols = 30;
  for(let r=0; r<=pRows; r++) {
    for(let c=0; c<=pCols; c++) {
      const p = pts[r*(pCols+1)+c];
      if(c===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
  }
  ctx.stroke();
  
  // Highlight Active Cells
  cells.forEach((c, i) => {
    if(c.active) {
      ctx.fillStyle = 'rgba(212, 164, 24, 0.15)';
      ctx.fillRect(c.x, 0, c.w, H);
    }
  });

  // Playhead
  if(state.playing) {
    const x = (state.step / 16) * W;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  
  // Draw Cursor
  if(state.down && state.mode === 'sculpt') {
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(state.mx, state.my, params.radius, 0, Math.PI*2); ctx.stroke();
  }
  
  // Draw Scope
  drawScope();
}

resize();
loop();
</script>
</body>
</html>
