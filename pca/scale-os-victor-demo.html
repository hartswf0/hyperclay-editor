<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ScaleOS + Victor Toolkit Demo</title>
<style>
:root { --bg: #0D1B2A; --fg: #F9F9F9; --accent: #36CFC9; --warn: #FFB400; }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { background: var(--bg); color: var(--fg); font-family: 'Inter', sans-serif; overflow: hidden; }
#canvas { position: fixed; inset: 0; }
.victor-ui { position: fixed; inset: 0; pointer-events: none; z-index: 100; }
.view-switcher { position: absolute; top: 20px; left: 20px; display: flex; gap: 8px; pointer-events: auto; }
.view-switcher button { background: rgba(54, 207, 201, 0.2); border: 2px solid var(--accent); color: var(--fg); padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
.view-switcher button.active { background: var(--accent); color: var(--bg); }
.controls-panel { position: absolute; top: 80px; left: 20px; background: rgba(13, 27, 42, 0.95); border: 2px solid var(--accent); border-radius: 12px; padding: 20px; width: 320px; pointer-events: auto; max-height: calc(100vh - 100px); overflow-y: auto; }
.panel-title { font-size: 1.2rem; font-weight: 800; color: var(--accent); margin-bottom: 16px; }
.parameter-scrubber { margin-bottom: 20px; }
.parameter-scrubber label { display: block; font-weight: 600; margin-bottom: 8px; color: var(--warn); }
.scrubber-controls { display: flex; gap: 8px; align-items: center; }
.scrubber-controls input[type="range"] { flex: 1; height: 6px; border-radius: 3px; background: rgba(54, 207, 201, 0.3); outline: none; -webkit-appearance: none; appearance: none; }
.scrubber-controls input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--accent); cursor: pointer; }
.scrubber-controls input[type="number"] { width: 70px; background: rgba(0, 0, 0, 0.4); border: 1px solid var(--accent); color: var(--fg); padding: 4px 8px; border-radius: 4px; font-size: 0.9rem; }
.property-panel { background: rgba(255, 180, 0, 0.1); border-left: 4px solid var(--warn); padding: 12px; border-radius: 4px; margin-bottom: 16px; font-size: 0.9rem; }
.property-row { display: flex; justify-content: space-between; margin-bottom: 6px; }
.property-label { opacity: 0.8; }
.property-value { font-weight: 700; color: var(--warn); }
.view-container { position: absolute; top: 80px; right: 20px; width: 420px; background: rgba(13, 27, 42, 0.95); border: 2px solid var(--accent); border-radius: 12px; padding: 20px; pointer-events: auto; display: none; }
.view-container.active { display: block; }
.symbolic-view pre { background: rgba(0, 0, 0, 0.6); padding: 12px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem; line-height: 1.6; }
.keyword { color: #ff6b35; } .variable { color: #36cfc9; } .number { color: #ffb400; }
canvas.graph { width: 100%; height: 200px; background: rgba(0, 0, 0, 0.4); border-radius: 6px; }
.export-btn { background: var(--warn); color: var(--bg); border: none; padding: 10px 20px; border-radius: 8px; font-weight: 700; cursor: pointer; margin-top: 16px; width: 100%; }
.intro-btn { position: absolute; top: 20px; right: 20px; background: var(--warn); color: var(--bg); border: none; padding: 12px 24px; border-radius: 8px; font-weight: 700; font-size: 1.1rem; cursor: pointer; pointer-events: auto; z-index: 200; transition: all 0.3s; box-shadow: 0 4px 12px rgba(255,180,0,0.4); }
.intro-btn:hover { transform: scale(1.05); box-shadow: 0 6px 16px rgba(255,180,0,0.6); }
.intro-btn.playing { background: #ff6b35; }
.title-overlay { position: fixed; inset: 0; pointer-events: none; z-index: 150; display: none; }
.title-overlay.active { display: block; }
.title-text { position: absolute; font-family: 'Impact', 'Arial Black', sans-serif; font-weight: 900; letter-spacing: 0.05em; text-transform: uppercase; opacity: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
.title-line { position: absolute; background: var(--warn); transform-origin: left center; }

@media (max-width: 768px) {
  .view-switcher { flex-wrap: wrap; width: calc(100% - 40px); }
  .view-switcher button { flex: 1; min-width: 75px; padding: 6px 10px; font-size: 0.85rem; }
  .controls-panel { top: 140px; left: 10px; right: 10px; width: auto; max-height: 40vh; }
  .view-container { top: auto; bottom: 10px; left: 10px; right: 10px; width: auto; max-height: 45vh; }
  .panel-title { font-size: 1rem; }
  .property-panel { font-size: 0.85rem; }
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="title-overlay" id="title-overlay"></div>

<div class="victor-ui">
  <button class="intro-btn" id="play-intro">‚ñ∂ Play Intro</button>
  
  <div class="view-switcher">
    <button class="active" data-view="visual">Visual</button>
    <button data-view="symbolic">Symbolic</button>
    <button data-view="graph">Graph</button>
  </div>
  
  <div class="controls-panel">
    <div class="panel-title">üöö ScaleOS Controls</div>
    <div id="scaling-law"></div>
    <div id="mass-coupling"></div>
    
    <div class="property-panel">
      <div style="font-weight: 700; color: var(--warn); margin-bottom: 8px;">Selected Truck Properties</div>
      <div class="property-row"><span class="property-label">Visual Size:</span><span class="property-value" id="visual-size">100%</span></div>
      <div class="property-row"><span class="property-label">Actual Mass:</span><span class="property-value" id="actual-mass">1000kg</span></div>
      <div class="property-row"><span class="property-label">Scale Factor:</span><span class="property-value" id="scale-factor">1.0x</span></div>
      <div class="property-row"><span class="property-label">Distance to Camera:</span><span class="property-value" id="distance">0m</span></div>
    </div>
    
    <button class="export-btn" id="export-btn">üì¶ Export Config</button>
  </div>
  
  <div class="view-container" data-view="symbolic">
    <div class="panel-title">üìù Symbolic View</div>
    <div class="symbolic-view"><pre id="symbolic-content"></pre></div>
  </div>
  
  <div class="view-container" data-view="graph">
    <div class="panel-title">üìä Scale vs Distance</div>
    <canvas id="graph-canvas" class="graph"></canvas>
  </div>
</div>

<script type="importmap">
{"imports": {"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const canvas = document.getElementById('canvas');
const scene = new THREE.Scene();
// Billout's poster-like sky - flat, even blue
scene.background = new THREE.Color(0x6a8aaa);
// Fog emphasizes scale deception - near objects pop, far fade
scene.fog = new THREE.FogExp2(0x6a8aaa, 0.016);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
camera.position.set(0, 8, 15);

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;

const state = { scalingLaw: 0.15, massCoupling: 0, selectedTruck: null };

// Scene
const cliff = new THREE.Mesh(new THREE.BoxGeometry(20, 8, 30), new THREE.MeshStandardMaterial({ color: 0x4a7c59 }));
cliff.position.set(-10, 3, 0);
cliff.receiveShadow = true;
scene.add(cliff);

const beach = new THREE.Mesh(new THREE.PlaneGeometry(30, 40), new THREE.MeshStandardMaterial({ color: 0xe8d4a0 }));
beach.rotation.x = -Math.PI / 2;
beach.position.x = 5;
beach.receiveShadow = true;
scene.add(beach);

const sea = new THREE.Mesh(new THREE.PlaneGeometry(50, 50, 32, 32), new THREE.MeshStandardMaterial({ color: 0x1e90ff, transparent: true, opacity: 0.7 }));
sea.rotation.x = -Math.PI / 2;
sea.position.set(20, -0.5, 0);
scene.add(sea);

// Trucks
const trucks = [];
const colors = [0xff6b35, 0x36cfc9, 0xffb400, 0x9966ff, 0x00e0a4, 0xff3366, 0x00ff88];
for (let i = 0; i < 7; i++) {
  const truck = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 3), new THREE.MeshStandardMaterial({ color: colors[i] }));
  body.castShadow = true;
  truck.add(body);
  truck.position.set(-5 + i * 2, 0.5, -10 + i * 3);
  truck.userData = { isTruck: true, baseMass: 1000, originalScale: 1 };
  scene.add(truck);
  trucks.push(truck);
}

// Minimal ambient - let spotlights define trucks
scene.add(new THREE.AmbientLight(0xa8a8a8, 0.3));
scene.add(new THREE.HemisphereLight(0x6a8aaa, 0xc8b89f, 0.4));

// Main sun - warm orange for truck definition
const sun = new THREE.DirectionalLight(0xffaa66, 1.2);
sun.position.set(20, 30, 10);
sun.castShadow = true;
scene.add(sun);

// Controls
function createScrubber(container, label, min, max, value, onChange) {
  const div = document.createElement('div');
  div.className = 'parameter-scrubber';
  div.innerHTML = `<label>${label}</label><div class="scrubber-controls"><input type="range" min="${min}" max="${max}" step="${(max-min)/100}" value="${value}"><input type="number" min="${min}" max="${max}" step="${(max-min)/100}" value="${value}"></div>`;
  const [slider, number] = div.querySelectorAll('input');
  const handle = e => { slider.value = number.value = e.target.value; onChange(+e.target.value); };
  slider.oninput = number.oninput = handle;
  container.appendChild(div);
}

createScrubber(document.getElementById('scaling-law'), 'Scaling Factor', 0, 0.3, state.scalingLaw, v => state.scalingLaw = v);
createScrubber(document.getElementById('mass-coupling'), 'Mass Coupling', 0, 1, state.massCoupling, v => state.massCoupling = v);

// Symbolic View
function updateSymbolic(truck) {
  const dist = camera.position.distanceTo(truck.position);
  const scale = Math.max(0.2, 2 / (1 + dist * state.scalingLaw));
  const mass = state.massCoupling === 0 ? truck.userData.baseMass : truck.userData.baseMass * scale;
  
  document.getElementById('symbolic-content').textContent = 
`const distToCamera = ${dist.toFixed(2)};
const scalingLaw = ${state.scalingLaw.toFixed(3)};

const visualScale = max(0.2, 2 / (1 + dist * scalingLaw));
// visualScale = ${scale.toFixed(3)}

const massCoupling = ${state.massCoupling.toFixed(2)};
const actualMass = baseMass * (coupling === 0 ? 1 : scale);
// actualMass = ${mass.toFixed(0)}kg

// SURREAL: Size decoupled from mass!`;
}

// Graph
const graphCanvas = document.getElementById('graph-canvas');
const ctx = graphCanvas.getContext('2d');
graphCanvas.width = 380;
graphCanvas.height = 200;

function updateGraph() {
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(0, 0, 380, 200);
  ctx.strokeStyle = '#36cfc9';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let d = 0; d <= 50; d += 0.5) {
    const x = (d / 50) * 380;
    const scale = Math.max(0.2, 2 / (1 + d * state.scalingLaw));
    const y = 200 - scale * 180;
    d === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Expected linear
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(0, 200);
  ctx.lineTo(380, 20);
  ctx.stroke();
  ctx.setLineDash([]);
}

document.getElementById('export-btn').onclick = () => {
  const blob = new Blob([JSON.stringify({ scalingLaw: state.scalingLaw, massCoupling: state.massCoupling }, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'scale-config.json';
  a.click();
};

document.querySelectorAll('.view-switcher button').forEach(btn => {
  btn.onclick = () => {
    document.querySelectorAll('.view-switcher button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    document.querySelectorAll('.view-container').forEach(c => c.classList.remove('active'));
    const vc = document.querySelector(`.view-container[data-view="${btn.dataset.view}"]`);
    if (vc) vc.classList.add('active');
  };
});

function animate() {
  requestAnimationFrame(animate);
  
  trucks.forEach(truck => {
    const dist = camera.position.distanceTo(truck.position);
    const scale = Math.max(0.2, 2 / (1 + dist * state.scalingLaw));
    truck.scale.setScalar(scale);
    
    if (truck === state.selectedTruck) {
      const mass = state.massCoupling === 0 ? truck.userData.baseMass : truck.userData.baseMass * scale;
      document.getElementById('visual-size').textContent = `${(scale * 100).toFixed(0)}%`;
      document.getElementById('actual-mass').textContent = `${mass.toFixed(0)}kg`;
      document.getElementById('scale-factor').textContent = `${scale.toFixed(2)}x`;
      document.getElementById('distance').textContent = `${dist.toFixed(1)}m`;
      updateSymbolic(truck);
    }
  });
  
  updateGraph();
  controls.update();
  renderer.render(scene, camera);
}

state.selectedTruck = trucks[0];

// ===== TITLE SEQUENCE SYSTEM =====

class TitleSequence {
  constructor(camera, scene, duration = 12) {
    this.camera = camera;
    this.scene = scene;
    this.duration = duration;
    this.isPlaying = false;
    this.originalCameraPos = camera.position.clone();
    this.originalCameraRot = camera.rotation.clone();
    this.textSprites = [];
    this.geometricShapes = [];
  }
  
  createTextSprite(text, color = '#FFB400', size = 120) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1024;
    canvas.height = 256;
    
    ctx.font = `600 ${size}px 'Helvetica Neue', 'Futura', 'Arial', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Outline
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 8;
    ctx.strokeText(text, 512, 128);
    
    // Fill
    ctx.fillStyle = color;
    ctx.fillText(text, 512, 128);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    
    const sprite = new THREE.Sprite(
      new THREE.SpriteMaterial({ 
        map: texture, 
        transparent: true,
        opacity: 0
      })
    );
    sprite.scale.set(10, 2.5, 1);
    
    this.scene.add(sprite);
    this.textSprites.push(sprite);
    return sprite;
  }
  
  addGeometricLine(start, end, color = 0xFFB400) {
    const points = [start, end];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ 
      color, 
      linewidth: 3,
      transparent: true,
      opacity: 0
    });
    const line = new THREE.Line(geometry, material);
    this.scene.add(line);
    this.geometricShapes.push(line);
    return line;
  }
  
  lerp(a, b, t) {
    return a + (b - a) * t;
  }
  
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }
  
  play() {
    if (this.isPlaying) return;
    this.isPlaying = true;
    
    const playBtn = document.getElementById('play-intro');
    playBtn.classList.add('playing');
    playBtn.textContent = '‚è∏ Playing...';
    
    // Hide UI during sequence
    document.querySelector('.view-switcher').style.opacity = '0';
    document.querySelector('.controls-panel').style.opacity = '0';
    
    // Store original controls state
    const controlsEnabled = controls.enabled;
    controls.enabled = false;
    
    this.runScaleOSSequence(() => {
      // Cleanup
      this.isPlaying = false;
      playBtn.classList.remove('playing');
      playBtn.textContent = '‚ñ∂ Play Intro';
      
      document.querySelector('.view-switcher').style.opacity = '1';
      document.querySelector('.controls-panel').style.opacity = '1';
      controls.enabled = controlsEnabled;
      
      // Remove sprites
      this.textSprites.forEach(s => this.scene.remove(s));
      this.geometricShapes.forEach(s => this.scene.remove(s));
      this.textSprites = [];
      this.geometricShapes = [];
      
      // Reset camera
      camera.position.copy(this.originalCameraPos);
      camera.rotation.copy(this.originalCameraRot);
    });
  }
  
  runScaleOSSequence(onComplete) {
    const startTime = Date.now();
    const duration = this.duration * 1000;
    
    // Select featured truck (middle one)
    const featuredTruck = trucks[3];
    const truckPos = featuredTruck.position;
    
    // Create text elements
    const text1 = this.createTextSprite('SIZE', '#FF6B35', 140);
    const text2 = this.createTextSprite('DECEIVES', '#36CFC9', 130);
    const text3 = this.createTextSprite('MASS', '#FFB400', 140);
    const text4 = this.createTextSprite('PERSISTS', '#36CFC9', 130);
    
    // Create geometric lines
    const line1 = this.addGeometricLine(
      new THREE.Vector3(-10, 5, 0),
      new THREE.Vector3(10, 5, 0)
    );
    const line2 = this.addGeometricLine(
      new THREE.Vector3(-10, -5, 0),
      new THREE.Vector3(10, -5, 0)
    );
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const ease = this.easeInOutCubic(t);
      
      // === ACT 1: Extreme Close-up (0-3s) ===
      if (t < 0.25) {
        const t1 = t / 0.25;
        camera.position.set(
          truckPos.x + 3,
          truckPos.y + 1,
          truckPos.z + 3
        );
        camera.lookAt(truckPos);
        camera.fov = this.lerp(60, 30, t1); // Zoom in
        camera.updateProjectionMatrix();
        
        // "SIZE" appears
        text1.position.set(truckPos.x, truckPos.y + 8, truckPos.z);
        text1.material.opacity = Math.min(t1 * 4, 1);
        text1.scale.setScalar(this.lerp(0.5, 1, t1) * 10);
      }
      
      // === ACT 2: Pull Back Reveal (3-6s) ===
      else if (t < 0.5) {
        const t2 = (t - 0.25) / 0.25;
        camera.position.set(
          this.lerp(truckPos.x + 3, truckPos.x, t2),
          this.lerp(truckPos.y + 1, 12, t2),
          this.lerp(truckPos.z + 3, truckPos.z + 20, t2)
        );
        camera.lookAt(truckPos);
        camera.fov = this.lerp(30, 60, t2); // Zoom out
        camera.updateProjectionMatrix();
        
        text1.position.set(truckPos.x - 8, truckPos.y + 10, truckPos.z);
        text1.material.opacity = 1;
        
        // "DECEIVES" fades in
        text2.position.set(truckPos.x + 8, truckPos.y + 8, truckPos.z);
        text2.material.opacity = t2;
        text2.scale.setScalar(this.lerp(0.5, 1, t2) * 10);
      }
      
      // === ACT 3: Dolly Zoom Effect (6-9s) ===
      else if (t < 0.75) {
        const t3 = (t - 0.5) / 0.25;
        
        // Dramatic dolly zoom (Hitchcock effect)
        const distance = this.lerp(25, 15, t3);
        camera.position.set(0, 12, distance);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        camera.fov = this.lerp(60, 80, t3);
        camera.updateProjectionMatrix();
        
        // Fade out old text
        text1.material.opacity = 1 - t3;
        text2.material.opacity = 1 - t3;
        
        // "MASS" appears at bottom
        text3.position.set(0, -5, 0);
        text3.material.opacity = t3;
        text3.scale.setScalar(this.lerp(0.5, 1, t3) * 12);
        
        // Lines appear
        line1.material.opacity = t3;
        line2.material.opacity = t3;
      }
      
      // === ACT 4: Final Composition (9-12s) ===
      else {
        const t4 = (t - 0.75) / 0.25;
        camera.position.set(0, 8, 15);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        camera.fov = 60;
        camera.updateProjectionMatrix();
        
        text3.position.set(0, 5, 0);
        text3.material.opacity = 1;
        
        // "PERSISTS" slides up
        text4.position.set(0, this.lerp(-10, -2, t4), 0);
        text4.material.opacity = t4;
        text4.scale.setScalar(this.lerp(0.5, 1, t4) * 10);
        
        // Fade out at end
        if (t > 0.95) {
          const fadeOut = (t - 0.95) / 0.05;
          text3.material.opacity = 1 - fadeOut;
          text4.material.opacity = 1 - fadeOut;
          line1.material.opacity = 1 - fadeOut;
          line2.material.opacity = 1 - fadeOut;
        }
      }
      
      if (t < 1) {
        requestAnimationFrame(animate);
      } else {
        onComplete();
      }
    };
    
    animate();
  }
}

const titleSequence = new TitleSequence(camera, scene, 12);

document.getElementById('play-intro').onclick = () => {
  if (!titleSequence.isPlaying) {
    titleSequence.play();
  }
};

// ===== END TITLE SEQUENCE =====

animate();

window.onresize = () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};
</script>

</body>
</html>
