<!-- hyperclay-manifold-module.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>MANIFOLD // MODULE</title>
<style>
  :root {
    --bg: #0a0a08;
    --panel: #1a1815;
    --border: #3a3228;
    --accent: #d4a418; /* ochre */
    --accent-dim: #b84a39; /* rust */
    --text: #c2b280; /* sand */
    --text-dim: #635147; /* umber */
    --h: 140px;
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
  
  body {
    margin: 0; background: var(--bg); height: 100vh;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Inter', -apple-system, system-ui, sans-serif;
    overflow: hidden;
  }

  .rack {
    width: 100%; max-width: 1200px; height: var(--h);
    background: var(--panel);
    border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);
    display: grid;
    grid-template-columns: 160px 1fr 80px;
    box-shadow: 0 10px 30px #000;
  }

  .controls-left {
    padding: 12px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 8px;
    border-right: 1px solid var(--border);
  }

  .dial-wrapper {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  
  .dial-svg {
    width: 44px; height: 44px; cursor: ns-resize; touch-action: none;
  }
  
  .dial-bg {
    fill: none; stroke: #1a1815; stroke-width: 3;
  }
  
  .dial-val {
    fill: none; stroke: var(--accent); stroke-width: 3; stroke-linecap: round;
    stroke-dasharray: 0 100; transform: rotate(-90deg); transform-origin: 50% 50%;
    transition: stroke-dasharray 0.1s;
  }
  
  .dial-label {
    font-size: 8px; color: var(--text-dim); margin-top: 2px; letter-spacing: 1px;
  }

  .screen-area {
    position: relative; background: #000; overflow: hidden; cursor: crosshair;
  }
  
  canvas { display: block; width: 100%; height: 100%; }
  
  .toolbar {
    position: absolute; left: 8px; top: 50%; transform: translateY(-50%);
    display: flex; flex-direction: column; gap: 6px; z-index: 10;
  }
  
  .tool-btn {
    width: 32px; height: 32px; background: rgba(26, 24, 21, 0.8);
    border: 1px solid var(--border); border-radius: 4px;
    color: var(--text-dim); font-size: 16px; display: grid; place-items: center;
    cursor: pointer; transition: all 0.2s;
  }
  
  .tool-btn.active {
    border-color: var(--accent); color: var(--accent);
    box-shadow: 0 0 8px rgba(212, 164, 24, 0.3);
  }

  .controls-right {
    border-left: 1px solid var(--border);
    display: flex; flex-direction: column;
    align-items: center; justify-content: space-evenly;
    padding: 12px;
  }
  
  .btn-rect {
    width: 56px; height: 28px;
    background: #111; border: 1px solid var(--border);
    color: var(--text-dim); font-size: 9px; letter-spacing: 1px;
    display: grid; place-items: center; cursor: pointer;
    border-radius: 2px; transition: all 0.2s;
  }
  
  .btn-rect:hover {
    border-color: var(--accent-dim); color: var(--accent);
  }
  
  .btn-circle {
    width: 40px; height: 40px; border-radius: 50%;
    border: 2px solid var(--border); display: grid; place-items: center;
    color: var(--text-dim); cursor: pointer; transition: all 0.2s;
  }
  
  .btn-circle.playing {
    border-color: var(--accent); color: var(--accent);
    background: rgba(212, 164, 24, 0.1);
  }

  @media (max-width: 600px) {
    .rack { grid-template-columns: 140px 1fr 70px; }
    .dial-svg { width: 36px; height: 36px; }
    .toolbar { left: 5px; gap: 4px; }
    .tool-btn { width: 28px; height: 28px; font-size: 14px; }
  }
</style>
<base target="_blank">
</head>
<body>

<div class="rack">
  
  <!-- LEFT: DIALS -->
  <div class="controls-left">
    <div class="dial-wrapper">
      <svg class="dial-svg" data-param="strength" data-min="1" data-max="20" data-val="8" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
        <path class="dial-val" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
      </svg>
      <div class="dial-label">FORCE</div>
    </div>
    
    <div class="dial-wrapper">
      <svg class="dial-svg" data-param="radius" data-min="20" data-max="150" data-val="60" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
        <path class="dial-val" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
      </svg>
      <div class="dial-label">SIZE</div>
    </div>
    
    <div class="dial-wrapper">
      <svg class="dial-svg" data-param="filter" data-min="200" data-max="8000" data-val="2000" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
        <path class="dial-val" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
      </svg>
      <div class="dial-label">TONE</div>
    </div>
    
    <div class="dial-wrapper">
      <svg class="dial-svg" data-param="release" data-min="100" data-max="1000" data-val="400" viewBox="0 0 36 36">
        <path class="dial-bg" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
        <path class="dial-val" d="M18 2.0845 A 15.9155 15.9155 0 0 1 18 33.9155" />
      </svg>
      <div class="dial-label">DECAY</div>
    </div>
  </div>

  <!-- CENTER: CANVAS -->
  <div class="screen-area" id="screen">
    <canvas id="cv"></canvas>
    
    <div class="toolbar">
      <div class="tool-btn active" data-tool="push" title="Push">●</div>
      <div class="tool-btn" data-tool="pull" title="Pull">○</div>
      <div class="tool-btn" data-tool="noise" title="Noise">∿</div>
      <div class="tool-btn" data-tool="smooth" title="Smooth">≈</div>
    </div>
  </div>

  <!-- RIGHT: TRANSPORT -->
  <div class="controls-right">
    <div class="btn-rect" id="btn-clear">CLEAR</div>
    <div class="btn-circle" id="btn-play">▶</div>
    <div class="btn-rect" id="btn-mode">SCULPT</div>
  </div>

</div>

<script>
// === CONFIGURATION ===
const CONFIG = new URLSearchParams(window.location.search);
const MODULE_ID = CONFIG.get('id') || 'module-' + Math.random().toString(36).substr(2, 9);
const MODULE_TYPE = CONFIG.get('type') || 'bass';
const MODULE_SPECS = {
  bass: { root: 110, osc: 'sine', filter: 'lowpass', label: 'BASS', color: '#d4a418' },
  lead: { root: 220, osc: 'triangle', filter: 'bandpass', label: 'LEAD', color: '#6c7d8c' },
  texture: { root: 165, osc: 'sawtooth', filter: 'highpass', label: 'TEXTURE', color: '#8a9a5b' }
}[MODULE_TYPE] || MODULE_SPECS.bass;

// === STATE ===
const state = {
  tool: 'push',
  mode: 'sculpt',
  transport: false,
  dragging: false,
  pulling: false,
  mx: 0, my: 0,
  seqStep: 0,
  lastStepTime: 0,
  rackLocked: false
};

const params = {
  strength: 8,
  radius: 60,
  filter: 2000,
  release: 400,
  tempo: 100
};

// === AUDIO ===
let audio = null, master = null, delay = null, fb = null;

function initAudio() {
  if(audio) return;
  const AC = window.AudioContext || window.webkitAudioContext;
  audio = new AC();
  master = audio.createGain();
  master.gain.value = 0.3;
  master.connect(audio.destination);
  
  delay = audio.createDelay();
  delay.delayTime.value = 0.3;
  fb = audio.createGain();
  fb.gain.value = 0.3;
  delay.connect(fb);
  fb.connect(delay);
  delay.connect(master);
}

// === CANVAS & RACK ===
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
let W = 0, H = 0, cols = 0, rows = 0, pts = [], seqCells = [];

function resize() {
  const rect = document.getElementById('screen').getBoundingClientRect();
  W = rect.width; H = rect.height;
  cv.width = W; cv.height = H;
  
  // Fixed 8 rows for horizontal flow, variable columns
  rows = 8;
  cols = Math.floor(W / 25);
  initMesh();
  initSequenceCells();
}
window.addEventListener('resize', resize);

function initMesh() {
  pts = [];
  for(let r=0; r<=rows; r++) {
    for(let c=0; c<=cols; c++) {
      const x = (c / cols) * W;
      const y = (r / rows) * H;
      pts.push({ x, y, ox: x, oy: y });
    }
  }
}

function initSequenceCells() {
  seqCells = [];
  for(let r=0; r<rows; r++) {
    for(let c=0; c<cols; c++) {
      const i = r*(cols+1) + c;
      const p1 = pts[i], p2 = pts[i+1], p3 = pts[i+cols+1], p4 = pts[i+cols+2];
      if(p1 && p2 && p3 && p4) {
        seqCells.push({
          corners: [p1, p2, p4, p3],
          active: false,
          row: r,
          col: c
        });
      }
    }
  }
}

// === SEQUENCER LOGIC ===
function tick() {
  if(!state.transport || !audio) return;
  
  const now = audio.currentTime;
  const stepTime = 60 / params.tempo / 4;
  
  if(now - state.lastStepTime > stepTime) {
    state.lastStepTime = now;
    state.seqStep = (state.seqStep + 1) % cols;
    
    // Play active cells in current step
    seqCells.forEach(cell => {
      if(cell.active && cell.col === state.seqStep) {
        const intensity = (cell.corners[0].y / H);
        playNote(intensity);
      }
    });
  }
}

function playNote(intensity) {
  const osc = audio.createOscillator();
  const gain = audio.createGain();
  const filter = audio.createBiquadFilter();

  osc.type = MODULE_SPECS.osc;
  filter.type = MODULE_SPECS.filter;
  
  const scale = [0, 2, 4, 7, 9, 12, 14, 16];
  const degree = Math.floor(intensity * (scale.length - 1));
  osc.frequency.value = MODULE_SPECS.root * Math.pow(2, scale[degree] / 12);
  
  filter.frequency.value = params.filter;
  filter.Q.value = 1 + (intensity * 5);
  
  const now = audio.currentTime;
  const atk = 0.01, rel = params.release / 1000;
  
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.25, now + atk);
  gain.gain.exponentialRampToValueAtTime(0.001, now + atk + rel);
  
  osc.connect(filter).connect(gain).connect(master).connect(delay);
  osc.start(now); osc.stop(now + atk + rel + 0.1);
}

// === RENDER ===
function render() {
  // Clear with gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0a0a08');
  grad.addColorStop(1, '#1a1815');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  // Base grid (subtle)
  ctx.strokeStyle = MODULE_SPECS.color + '10';
  ctx.lineWidth = 1;
  for(let c=0; c<=cols; c++) {
    const x = (c / cols) * W;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for(let r=0; r<=rows; r++) {
    const y = (r / rows) * H;
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }
  
  // Active mesh (visible in module color)
  ctx.strokeStyle = MODULE_SPECS.color;
  ctx.lineWidth = 2;
  for(let r=0; r<=rows; r++) {
    ctx.beginPath();
    for(let c=0; c<=cols; c++) {
      const p = pts[r*(cols+1)+c];
      c === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }
  for(let c=0; c<=cols; c++) {
    ctx.beginPath();
    for(let r=0; r<=rows; r++) {
      const p = pts[r*(cols+1)+c];
      r === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }
  
  // Sequencer cells (clickable quads)
  seqCells.forEach(cell => {
    const isCurrentStep = cell.col === state.seqStep;
    
    ctx.beginPath();
    cell.corners.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
    ctx.closePath();
    
    if(cell.active) {
      ctx.fillStyle = isCurrentStep ? MODULE_SPECS.color : MODULE_SPECS.color + '40';
      ctx.fill();
    } else if(isCurrentStep) {
      ctx.fillStyle = MODULE_SPECS.color + '10';
      ctx.fill();
    }
    
    ctx.strokeStyle = MODULE_SPECS.color + (cell.active ? '80' : '20');
    ctx.stroke();
  });
  
  // Playhead
  if(state.transport) {
    const x = (state.seqStep / cols) * W;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  
  // Cursor
  if(state.dragging && state.mode === 'sculpt') {
    ctx.strokeStyle = state.pulling ? '#b84a39' : MODULE_SPECS.color;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(state.mx, state.my, params.radius, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = ctx.strokeStyle + '20';
    ctx.fill();
  }
}

// === INTERACTION ===
function trackPointer(e) {
  const rect = cv.getBoundingClientRect();
  state.mx = e.clientX - rect.left;
  state.my = e.clientY - rect.top;
}

cv.addEventListener('pointerdown', (e) => {
  initAudio();
  audio.resume();
  state.dragging = true;
  trackPointer(e);
  state.pulling = e.button === 2 || e.shiftKey || e.ctrlKey;
  
  // Check for cell click FIRST (before sculpting)
  for(let i = 0; i < seqCells.length; i++) {
    const cell = seqCells[i];
    // Ray casting for irregular quads
    let inside = false;
    for(let j = 0, k = 3; j < 4; j++) {
      const xi = cell.corners[j].x, yi = cell.corners[j].y;
      const xj = cell.corners[k].x, yj = cell.corners[k].y;
      if(((yi > state.my) !== (yj > state.my)) && 
         (state.mx < (xj-xi)*(state.my-yi)/(yj-yi)+xi)) {
        inside = !inside;
      }
      k = j;
    }
    
    if(inside) {
      // Toggle cell and play immediately
      cell.active = !cell.active;
      if(cell.active) {
        const intensity = (cell.corners[0].y / H);
        playNote(intensity);
      }
      return; // Don't sculpt if clicking a cell
    }
  }
  
  // If not clicking a cell, sculpt
  if(state.mode === 'sculpt') {
    sculpt();
    if(Math.random() > 0.9) playNote(state.my / H);
  }
});

cv.addEventListener('pointermove', (e) => {
  trackPointer(e);
  if(state.dragging && state.mode === 'sculpt') {
    sculpt();
    // Rebuild cells after sculpting to maintain alignment
    initSequenceCells();
  }
});

window.addEventListener('pointerup', () => { state.dragging = false; });

function sculpt() {
  if(!state.dragging || state.mode !== 'sculpt') return;
  
  pts.forEach(p => {
    const dx = p.x - state.mx, dy = p.y - state.my, d2 = dx*dx + dy*dy;
    if(d2 < params.radius * params.radius) {
      const dist = Math.sqrt(d2);
      const force = (1 - dist/params.radius) * params.strength * (state.pulling ? -1 : 1);
      const ang = Math.atan2(dy, dx);
      p.x += Math.cos(ang) * force;
      p.y += Math.sin(ang) * force;
    }
  });
}

// === CONTROLS ===
document.getElementById('btn-play').addEventListener('click', () => {
  initAudio();
  state.transport = !state.transport;
  document.getElementById('btn-play').classList.toggle('playing', state.transport);
  document.getElementById('btn-play').innerText = state.transport ? '■' : '▶';
  if(state.transport) state.lastStepTime = audio.currentTime;
});

document.getElementById('btn-clear').addEventListener('click', () => {
  initMesh(); // Reset geometry
  seqCells.forEach(c => c.active = false); // Clear sequencer
});

document.getElementById('btn-mode').addEventListener('click', () => {
  state.mode = state.mode === 'sculpt' ? 'sequence' : 'sculpt';
  document.getElementById('btn-mode').innerText = state.mode.toUpperCase();
});

document.querySelectorAll('.tool-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    state.tool = btn.dataset.tool;
    state.pulling = state.tool === 'pull';
  });
});

// === DIALS ===
function updateDial(param, value) {
  const el = document.querySelector(`[data-param="${param}"]`);
  const min = parseFloat(el.dataset.min);
  const max = parseFloat(el.dataset.max);
  const pct = (value - min) / (max - min);
  el.querySelector('.dial-val').style.strokeDasharray = `${pct * 100}, 100`;
}

document.querySelectorAll('.dial-svg').forEach(el => {
  el.addEventListener('pointerdown', (e) => {
    const param = el.dataset.param;
    const min = parseFloat(el.dataset.min);
    const max = parseFloat(el.dataset.max);
    let startY = e.clientY;
    let startVal = params[param];
    
    const move = (ev) => {
      const delta = startY - ev.clientY;
      params[param] = clamp(startVal + (delta / 200) * (max - min), min, max);
      updateDial(param, params[param]);
    };
    
    const up = () => {
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
    };
    
    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
  });
});

// === UTILS ===
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

// === LOOP ===
function loop() {
  requestAnimationFrame(loop);
  tick();
  render();
}

// === MESSAGING ===
function postMessage(type, data) {
  window.parent.postMessage({ type, moduleId: MODULE_ID, ...data }, '*');
}

// === INIT ===
resize();
loop();
</script>
</body>
</html>
